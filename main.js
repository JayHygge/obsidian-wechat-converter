/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// services/parity-gate.js
var require_parity_gate = __commonJS({
  "services/parity-gate.js"(exports2, module2) {
    function isStrictHtmlParity(legacyHtml, candidateHtml) {
      return String(legacyHtml || "") === String(candidateHtml || "");
    }
    function findFirstDiffIndex(a, b) {
      const left = String(a || "");
      const right = String(b || "");
      const minLength = Math.min(left.length, right.length);
      for (let i = 0; i < minLength; i += 1) {
        if (left[i] !== right[i])
          return i;
      }
      if (left.length !== right.length)
        return minLength;
      return -1;
    }
    function indexToLineColumn(text, index) {
      const source = String(text || "");
      const safeIndex = Math.max(0, Math.min(source.length, index));
      let line = 1;
      let column = 1;
      for (let i = 0; i < safeIndex; i += 1) {
        if (source[i] === "\n") {
          line += 1;
          column = 1;
        } else {
          column += 1;
        }
      }
      return { line, column };
    }
    function findSyncPoint(left, right, leftIndex, rightIndex, lookahead = 64) {
      const maxLeftOffset = Math.min(lookahead, Math.max(0, left.length - leftIndex));
      const maxRightOffset = Math.min(lookahead, Math.max(0, right.length - rightIndex));
      for (let leftOffset = 0; leftOffset <= maxLeftOffset; leftOffset += 1) {
        for (let rightOffset = 0; rightOffset <= maxRightOffset; rightOffset += 1) {
          const lPos = leftIndex + leftOffset;
          const rPos = rightIndex + rightOffset;
          if (lPos >= left.length || rPos >= right.length)
            continue;
          if (left[lPos] !== right[rPos])
            continue;
          const lNext = lPos + 1;
          const rNext = rPos + 1;
          const nextLooksAligned = lNext >= left.length || rNext >= right.length || left[lNext] === right[rNext];
          if (nextLooksAligned) {
            return { leftIndex: lPos, rightIndex: rPos };
          }
        }
      }
      return null;
    }
    function collectMismatchSegments(left, right, options = {}) {
      const lookahead = Number.isInteger(options.lookahead) ? options.lookahead : 64;
      const maxSegments = Number.isInteger(options.maxSegments) && options.maxSegments > 0 ? options.maxSegments : Number.POSITIVE_INFINITY;
      const snippetContext = Number.isInteger(options.snippetContext) ? options.snippetContext : 60;
      let i = 0;
      let j = 0;
      let segmentCount = 0;
      const segments = [];
      while (i < left.length && j < right.length) {
        if (left[i] === right[j]) {
          i += 1;
          j += 1;
          continue;
        }
        const startLeft = i;
        const startRight = j;
        const sync = findSyncPoint(left, right, i, j, lookahead);
        let endLeft = left.length;
        let endRight = right.length;
        if (sync) {
          endLeft = sync.leftIndex;
          endRight = sync.rightIndex;
          i = sync.leftIndex;
          j = sync.rightIndex;
        } else {
          i = left.length;
          j = right.length;
        }
        const start = Math.max(0, Math.min(startLeft, startRight) - snippetContext);
        const leftLineColumn = indexToLineColumn(left, startLeft);
        const rightLineColumn = indexToLineColumn(right, startRight);
        segmentCount += 1;
        if (segments.length < maxSegments) {
          segments.push({
            index: startLeft,
            legacyStart: startLeft,
            legacyEnd: endLeft,
            candidateStart: startRight,
            candidateEnd: endRight,
            legacyLine: leftLineColumn.line,
            legacyColumn: leftLineColumn.column,
            candidateLine: rightLineColumn.line,
            candidateColumn: rightLineColumn.column,
            legacySnippet: left.slice(start, Math.min(left.length, startLeft + snippetContext)),
            candidateSnippet: right.slice(start, Math.min(right.length, startRight + snippetContext))
          });
        }
      }
      if (i < left.length || j < right.length) {
        segmentCount += 1;
        if (segments.length < maxSegments) {
          const leftLineColumn = indexToLineColumn(left, i);
          const rightLineColumn = indexToLineColumn(right, j);
          const start = Math.max(0, Math.min(i, j) - snippetContext);
          segments.push({
            index: i,
            legacyStart: i,
            legacyEnd: left.length,
            candidateStart: j,
            candidateEnd: right.length,
            legacyLine: leftLineColumn.line,
            legacyColumn: leftLineColumn.column,
            candidateLine: rightLineColumn.line,
            candidateColumn: rightLineColumn.column,
            legacySnippet: left.slice(start, Math.min(left.length, i + snippetContext)),
            candidateSnippet: right.slice(start, Math.min(right.length, j + snippetContext))
          });
        }
      }
      return {
        segmentCount,
        segments,
        truncated: Number.isFinite(maxSegments) ? segmentCount > segments.length : false
      };
    }
    function buildParityMismatchDetails(legacyHtml, candidateHtml, contextLength = 80) {
      const left = String(legacyHtml || "");
      const right = String(candidateHtml || "");
      const index = findFirstDiffIndex(left, right);
      if (index === -1) {
        return {
          index: -1,
          legacySnippet: "",
          candidateSnippet: "",
          legacyLength: left.length,
          candidateLength: right.length,
          lengthDelta: 0,
          segmentCount: 0,
          segments: [],
          truncated: false
        };
      }
      const start = Math.max(0, index - contextLength);
      const endLeft = Math.min(left.length, index + contextLength);
      const endRight = Math.min(right.length, index + contextLength);
      const leftLineColumn = indexToLineColumn(left, index);
      const rightLineColumn = indexToLineColumn(right, index);
      const segmentData = collectMismatchSegments(left, right);
      return {
        index,
        legacySnippet: left.slice(start, endLeft),
        candidateSnippet: right.slice(start, endRight),
        legacyLength: left.length,
        candidateLength: right.length,
        lengthDelta: right.length - left.length,
        legacyLine: leftLineColumn.line,
        legacyColumn: leftLineColumn.column,
        candidateLine: rightLineColumn.line,
        candidateColumn: rightLineColumn.column,
        segmentCount: segmentData.segmentCount,
        segments: segmentData.segments,
        truncated: segmentData.truncated
      };
    }
    module2.exports = {
      isStrictHtmlParity,
      findFirstDiffIndex,
      buildParityMismatchDetails
    };
  }
});

// services/render-pipeline.js
var require_render_pipeline = __commonJS({
  "services/render-pipeline.js"(exports2, module2) {
    var { isStrictHtmlParity, buildParityMismatchDetails } = require_parity_gate();
    function pickFlag(flags, primaryKey, legacyKey, defaultValue) {
      if (Object.prototype.hasOwnProperty.call(flags || {}, primaryKey)) {
        return flags[primaryKey];
      }
      if (Object.prototype.hasOwnProperty.call(flags || {}, legacyKey)) {
        return flags[legacyKey];
      }
      return defaultValue;
    }
    var LegacyRenderPipeline = class {
      constructor(converter) {
        this.converter = converter;
      }
      async renderForPreview(markdown, context = {}) {
        if (!this.converter || typeof this.converter.convert !== "function") {
          throw new Error("Legacy converter is not ready");
        }
        if (typeof this.converter.updateSourcePath === "function") {
          this.converter.updateSourcePath(context.sourcePath || "");
        }
        return this.converter.convert(markdown);
      }
      async renderForExport(markdown, context = {}) {
        return {
          html: await this.renderForPreview(markdown, context),
          diagnostics: []
        };
      }
    };
    var NativeRenderPipeline = class {
      constructor({ nativeRenderer, candidateRenderer, legacyPipeline, getFlags }) {
        this.nativeRenderer = candidateRenderer || nativeRenderer;
        this.legacyPipeline = legacyPipeline;
        this.getFlags = typeof getFlags === "function" ? getFlags : () => ({});
      }
      async renderForPreview(markdown, context = {}) {
        const flags = this.getFlags() || {};
        const strictParity = pickFlag(flags, "enforceTripletParity", "enforceNativeParity", false) === true;
        const enableFallback = pickFlag(flags, "tripletFallbackToPhase2", "enableLegacyFallback", true) !== false;
        const mismatchCode = flags.parityErrorCode || "PARITY_MISMATCH";
        const parityTransform = typeof flags.parityTransform === "function" ? flags.parityTransform : null;
        if (typeof this.nativeRenderer !== "function") {
          if (enableFallback && this.legacyPipeline) {
            return this.legacyPipeline.renderForPreview(markdown, context);
          }
          throw new Error("Triplet render pipeline is not implemented yet");
        }
        try {
          const nativeHtml = await this.nativeRenderer(markdown, context);
          if (!strictParity || !this.legacyPipeline) {
            return nativeHtml;
          }
          const legacyHtml = await this.legacyPipeline.renderForPreview(markdown, context);
          const parityLegacyHtml = parityTransform ? parityTransform(legacyHtml, { markdown, context, pipeline: "legacy" }) : legacyHtml;
          const parityNativeHtml = parityTransform ? parityTransform(nativeHtml, { markdown, context, pipeline: "native" }) : nativeHtml;
          if (isStrictHtmlParity(parityLegacyHtml, parityNativeHtml)) {
            return nativeHtml;
          }
          const mismatch = buildParityMismatchDetails(parityLegacyHtml, parityNativeHtml);
          const parityError = new Error(
            `[RenderPipeline] Parity mismatch at index ${mismatch.index} (segments ${mismatch.segmentCount}, delta ${mismatch.lengthDelta})`
          );
          parityError.code = mismatchCode;
          parityError.parity = mismatch;
          if (typeof flags.onParityMismatch === "function") {
            flags.onParityMismatch({
              markdown,
              context,
              mismatch
            });
          }
          if (enableFallback && this.legacyPipeline) {
            console.warn("[RenderPipeline] Triplet parity mismatch, fallback to Phase2 baseline:", mismatch.index);
            return legacyHtml;
          }
          throw parityError;
        } catch (error) {
          if (enableFallback && this.legacyPipeline) {
            console.warn("[RenderPipeline] Triplet render failed, fallback to Phase2 baseline:", (error == null ? void 0 : error.message) || error);
            return this.legacyPipeline.renderForPreview(markdown, context);
          }
          throw error;
        }
      }
      async renderForExport(markdown, context = {}) {
        return {
          html: await this.renderForPreview(markdown, context),
          diagnostics: []
        };
      }
    };
    function createRenderPipelines2({ converter, getFlags, nativeRenderer, candidateRenderer }) {
      const legacyPipeline = new LegacyRenderPipeline(converter);
      const nativePipeline = new NativeRenderPipeline({
        nativeRenderer,
        candidateRenderer,
        legacyPipeline,
        getFlags
      });
      return { legacyPipeline, nativePipeline };
    }
    module2.exports = {
      LegacyRenderPipeline,
      NativeRenderPipeline,
      createRenderPipelines: createRenderPipelines2
    };
  }
});

// services/dependency-loader.js
var require_dependency_loader = __commonJS({
  "services/dependency-loader.js"(exports2, module2) {
    function getAvatarSrc(settings = {}) {
      if (!settings.enableWatermark)
        return "";
      return settings.avatarBase64 || settings.avatarUrl || "";
    }
    function toThemeOptions(settings = {}) {
      return {
        theme: settings.theme,
        themeColor: settings.themeColor,
        customColor: settings.customColor,
        fontFamily: settings.fontFamily,
        fontSize: settings.fontSize,
        macCodeBlock: settings.macCodeBlock,
        codeLineNumber: settings.codeLineNumber,
        sidePadding: settings.sidePadding,
        coloredHeader: settings.coloredHeader
      };
    }
    async function ensureGlobalLibrary({ adapter, path, isReady, execute }) {
      if (isReady())
        return;
      const content = await adapter.read(path);
      execute(content);
    }
    async function loadConverterDependencies({ adapter, basePath, execute, logger = console }) {
      await ensureGlobalLibrary({
        adapter,
        path: `${basePath}/lib/markdown-it.min.js`,
        isReady: () => typeof markdownit !== "undefined",
        execute
      });
      await ensureGlobalLibrary({
        adapter,
        path: `${basePath}/lib/highlight.min.js`,
        isReady: () => typeof hljs !== "undefined",
        execute
      });
      try {
        const mathPath = `${basePath}/lib/mathjax-plugin.js`;
        if (await adapter.exists(mathPath)) {
          const mathContent = await adapter.read(mathPath);
          execute(mathContent);
        }
      } catch (error) {
        logger.error("MathJax plugin load failed:", error);
      }
      const themeContent = await adapter.read(`${basePath}/themes/apple-theme.js`);
      execute(themeContent);
      const converterContent = await adapter.read(`${basePath}/converter.js`);
      execute(converterContent);
      if (!window.AppleTheme)
        throw new Error("AppleTheme failed to load");
      if (!window.AppleStyleConverter)
        throw new Error("AppleStyleConverter failed to load");
    }
    async function buildRenderRuntime2({
      settings,
      app,
      adapter,
      basePath,
      execute = (code) => (0, eval)(code),
      logger = console
    }) {
      await loadConverterDependencies({ adapter, basePath, execute, logger });
      const theme = new window.AppleTheme(toThemeOptions(settings));
      const converter = new window.AppleStyleConverter(
        theme,
        getAvatarSrc(settings),
        settings.showImageCaption,
        app
      );
      await converter.initMarkdownIt();
      return { theme, converter };
    }
    module2.exports = {
      getAvatarSrc,
      toThemeOptions,
      loadConverterDependencies,
      buildRenderRuntime: buildRenderRuntime2
    };
  }
});

// services/markdown-source.js
var require_markdown_source = __commonJS({
  "services/markdown-source.js"(exports2, module2) {
    async function resolveMarkdownSource2({ app, lastActiveFile, MarkdownViewType }) {
      const activeView = app.workspace.getActiveViewOfType(MarkdownViewType);
      if (!activeView && lastActiveFile) {
        try {
          const markdown = await app.vault.read(lastActiveFile);
          return {
            ok: true,
            markdown,
            sourcePath: lastActiveFile.path || ""
          };
        } catch (error) {
          return {
            ok: false,
            reason: "NO_ACTIVE_FILE",
            error
          };
        }
      }
      if (activeView) {
        return {
          ok: true,
          markdown: activeView.editor.getValue(),
          sourcePath: activeView.file ? activeView.file.path : ""
        };
      }
      return {
        ok: false,
        reason: "NO_ACTIVE_FILE"
      };
    }
    module2.exports = {
      resolveMarkdownSource: resolveMarkdownSource2
    };
  }
});

// services/path-utils.js
var require_path_utils = __commonJS({
  "services/path-utils.js"(exports2, module2) {
    function normalizeVaultPath2(vaultPath) {
      if (typeof vaultPath !== "string")
        return "";
      return vaultPath.trim().replace(/\\/g, "/").replace(/\/{2,}/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
    }
    function isAbsolutePathLike2(vaultPath) {
      if (typeof vaultPath !== "string")
        return false;
      const trimmed = vaultPath.trim();
      if (!trimmed)
        return false;
      if (trimmed.startsWith("/"))
        return true;
      return /^[a-zA-Z]:[\\/]/.test(trimmed);
    }
    module2.exports = {
      normalizeVaultPath: normalizeVaultPath2,
      isAbsolutePathLike: isAbsolutePathLike2
    };
  }
});

// services/obsidian-triplet-serializer.js
var require_obsidian_triplet_serializer = __commonJS({
  "services/obsidian-triplet-serializer.js"(exports2, module2) {
    function appendInlineStyle(el, styleText) {
      if (!el || !styleText)
        return;
      const existing = el.getAttribute("style") || "";
      if (!existing) {
        el.setAttribute("style", styleText);
        return;
      }
      const normalized = existing.trim().endsWith(";") ? existing.trim() : `${existing.trim()};`;
      el.setAttribute("style", `${normalized} ${styleText}`);
    }
    function setInlineStyleIfMissing(el, styleText) {
      if (!el || !styleText)
        return;
      const existing = el.getAttribute("style");
      if (existing && existing.trim())
        return;
      el.setAttribute("style", styleText);
    }
    var LEGACY_CALLOUT_ICON_BY_TYPE = {
      note: "\u2139\uFE0F",
      info: "\u2139\uFE0F",
      todo: "\u2611\uFE0F",
      abstract: "\u{1F4C4}",
      summary: "\u{1F4C4}",
      tldr: "\u{1F4C4}",
      tip: "\u{1F4A1}",
      hint: "\u{1F4A1}",
      important: "\u{1F4A1}",
      success: "\u2705",
      check: "\u2705",
      done: "\u2705",
      question: "\u2753",
      help: "\u2753",
      faq: "\u2753",
      warning: "\u26A0\uFE0F",
      caution: "\u26A0\uFE0F",
      attention: "\u26A0\uFE0F",
      failure: "\u274C",
      fail: "\u274C",
      missing: "\u274C",
      danger: "\u{1F6A8}",
      error: "\u274C",
      bug: "\u{1F41B}",
      quote: "\u{1F4AC}",
      cite: "\u{1F4DD}",
      example: "\u{1F4CB}"
    };
    function toTitleCase(value) {
      const text = String(value || "").trim();
      if (!text)
        return "";
      return text.charAt(0).toUpperCase() + text.slice(1);
    }
    function resolveLegacyCalloutIcon(type) {
      const key = String(type || "").trim().toLowerCase();
      if (!key)
        return "\u{1F4CC}";
      return LEGACY_CALLOUT_ICON_BY_TYPE[key] || "\u{1F4CC}";
    }
    function convertObsidianCalloutsToLegacy(container, converter) {
      if (!container || !converter)
        return;
      if (typeof converter.renderCalloutOpen !== "function")
        return;
      const callouts = Array.from(
        container.querySelectorAll("div.callout,aside.callout,blockquote.callout,section.callout")
      );
      if (callouts.length === 0)
        return;
      const getCalloutDepth = (node) => {
        let depth = 0;
        let cursor = (node == null ? void 0 : node.parentElement) || null;
        while (cursor) {
          if (cursor.matches && cursor.matches("div.callout,aside.callout,blockquote.callout,section.callout")) {
            depth += 1;
          }
          cursor = cursor.parentElement;
        }
        return depth;
      };
      callouts.sort((a, b) => {
        const da = getCalloutDepth(a);
        const db = getCalloutDepth(b);
        return db - da;
      });
      for (const callout of callouts) {
        if (!callout || !callout.parentNode)
          continue;
        const typeRaw = callout.getAttribute("data-callout") || callout.getAttribute("data-callout-type") || "";
        const type = String(typeRaw || "").trim().toLowerCase();
        const titleEl = callout.querySelector(":scope > .callout-title .callout-title-inner") || callout.querySelector(":scope > .callout-title-inner") || callout.querySelector(":scope > .callout-title");
        const titleText = String((titleEl == null ? void 0 : titleEl.textContent) || "").trim();
        const title = titleText || toTitleCase(type) || "Callout";
        const contentEl = callout.querySelector(":scope > .callout-content") || callout.querySelector(":scope > .callout-body");
        const contentHtml = contentEl ? contentEl.innerHTML : callout.innerHTML;
        const calloutInfo = {
          type: type || title.toLowerCase(),
          title,
          icon: resolveLegacyCalloutIcon(type || title),
          label: type || title
        };
        let openHtml = "";
        try {
          openHtml = converter.renderCalloutOpen(calloutInfo);
        } catch (error) {
          continue;
        }
        if (!openHtml)
          continue;
        const host = document.createElement("div");
        host.innerHTML = `${openHtml}${contentHtml}</section></section>`;
        const replacementNodes = Array.from(host.childNodes);
        if (replacementNodes.length === 0)
          continue;
        callout.replaceWith(...replacementNodes);
      }
    }
    function sanitizeClassList(el, tagName, finalStage = false) {
      const className = el.getAttribute("class");
      if (!className)
        return;
      const classes = className.split(/\s+/).filter(Boolean);
      let keep = [];
      if (tagName === "section") {
        keep = classes.filter((cls) => cls === "code-snippet__fix");
      } else if (tagName === "img") {
        keep = classes.filter((cls) => cls === "math-formula-image");
      } else if (!finalStage && (tagName === "pre" || tagName === "code")) {
        keep = classes.filter((cls) => cls.startsWith("language-"));
      }
      if (keep.length > 0) {
        el.setAttribute("class", keep.join(" "));
      } else {
        el.removeAttribute("class");
      }
    }
    function pruneObsidianOnlyAttributes(container, { finalStage = false } = {}) {
      if (!container)
        return;
      const getAllowedAttrs = (tagName) => {
        if (tagName === "a")
          return /* @__PURE__ */ new Set(["href", "style"]);
        if (tagName === "img")
          return /* @__PURE__ */ new Set(["src", "alt", "style", "width", "height", "class"]);
        if (tagName === "section")
          return /* @__PURE__ */ new Set(["style", "class"]);
        if (!finalStage && (tagName === "pre" || tagName === "code"))
          return /* @__PURE__ */ new Set(["style", "class"]);
        return /* @__PURE__ */ new Set(["style"]);
      };
      Array.from(container.querySelectorAll("*")).forEach((el) => {
        const tagName = el.tagName.toLowerCase();
        const allowed = getAllowedAttrs(tagName);
        const attrs = Array.from(el.attributes);
        for (const attr of attrs) {
          const name = attr.name.toLowerCase();
          if (name.startsWith("data-") || name === "id" || name === "dir") {
            el.removeAttribute(attr.name);
            continue;
          }
          if (!allowed.has(name)) {
            el.removeAttribute(attr.name);
          }
        }
        sanitizeClassList(el, tagName, finalStage);
        const style = el.getAttribute("style");
        if (style !== null && style.trim() === "") {
          el.removeAttribute("style");
        }
      });
    }
    function normalizeLegacyTagAliases(container) {
      if (!container)
        return;
      const strikeTags = Array.from(container.querySelectorAll("s"));
      for (const sEl of strikeTags) {
        const del = document.createElement("del");
        if (sEl.hasAttributes()) {
          Array.from(sEl.attributes).forEach((attr) => {
            del.setAttribute(attr.name, attr.value);
          });
        }
        del.innerHTML = sEl.innerHTML;
        sEl.replaceWith(del);
      }
    }
    function normalizeLegacyDeleteNesting(container) {
      if (!container)
        return;
      const dels = Array.from(container.querySelectorAll("del"));
      for (const first of dels) {
        if (!first || !first.parentElement)
          continue;
        if (first.parentElement.tagName.toLowerCase() === "del")
          continue;
        if (first.querySelector("del"))
          continue;
        let spacer = first.nextSibling;
        let second = null;
        if (spacer && spacer.nodeType === Node.TEXT_NODE && /^\s*$/.test(spacer.textContent || "")) {
          second = spacer.nextSibling;
        } else if (spacer && spacer.nodeType === Node.ELEMENT_NODE && spacer.tagName.toLowerCase() === "del") {
          second = spacer;
          spacer = null;
        } else {
          continue;
        }
        if (!second || second.nodeType !== Node.ELEMENT_NODE || second.tagName.toLowerCase() !== "del")
          continue;
        const label = (first.textContent || "").trim();
        if (!/[：:]$/.test(label))
          continue;
        if (!/\S/.test(second.textContent || ""))
          continue;
        if (!/\s$/.test(first.textContent || "")) {
          first.appendChild(document.createTextNode(" "));
        }
        first.appendChild(second);
        if (spacer && spacer.parentNode)
          spacer.remove();
      }
    }
    function normalizeLegacyDeleteNestingInHtml(html) {
      if (typeof html !== "string" || html.length === 0)
        return html;
      return html.replace(
        /<del([^>]*)>([^<]*[：:])<\/del>(?:\s|&nbsp;|<br\s*\/?>)*<del([^>]*)>/g,
        (_match, attrs1, label, attrs2) => `<del${attrs1}>${label} <del${attrs2}>`
      );
    }
    function getTagStyle(converter, tagName) {
      if (!converter || typeof converter.getInlineStyle !== "function")
        return "";
      try {
        return converter.getInlineStyle(tagName) || "";
      } catch (error) {
        return "";
      }
    }
    function safeDecodeCaption(text) {
      if (!text || typeof text !== "string")
        return text || "";
      if (!text.includes("%"))
        return text;
      try {
        return decodeURIComponent(text);
      } catch (error) {
        return text;
      }
    }
    function deriveImageCaption(converter, src = "", alt = "") {
      let caption = alt || "";
      if (!caption) {
        if (converter && typeof converter.extractFileName === "function") {
          caption = converter.extractFileName(src);
        } else {
          caption = src.split("/").pop() || "\u56FE\u7247";
        }
      }
      caption = safeDecodeCaption(caption);
      caption = caption.replace(/[?#].*$/, "");
      caption = caption.replace(/\|\s*\d+(x\d+)?\s*$/, "");
      caption = caption.replace(/\.(jpg|jpeg|png|gif|webp|svg|bmp)$/i, "");
      return caption || "\u56FE\u7247";
    }
    function extractWidthHintFromText(text) {
      const value = String(text || "");
      if (!value)
        return "";
      const wikiMatch = value.match(/\|(\d{2,4})(?:x\d+)?(?:\]\]|$)/i);
      if (wikiMatch && wikiMatch[1])
        return wikiMatch[1];
      const styleMatch = value.match(/\b(?:max-)?width\s*[:=]\s*(\d{2,4})\s*px\b/i);
      if (styleMatch && styleMatch[1])
        return styleMatch[1];
      const bareMatch = value.match(/^\s*(\d{2,4})\s*$/);
      if (bareMatch && bareMatch[1])
        return bareMatch[1];
      return "";
    }
    function findImageWidthHintFromAncestors(el) {
      let cursor = el;
      let depth = 0;
      while (cursor && depth < 6) {
        if (cursor.nodeType === Node.ELEMENT_NODE) {
          const attrs = ["width", "data-width", "data-size", "data-image-width", "style", "src", "data-src", "data-href", "title", "aria-label", "alt"];
          for (const key of attrs) {
            const value = cursor.getAttribute(key);
            const width = extractWidthHintFromText(value);
            if (width)
              return width;
          }
          const textWidth = extractWidthHintFromText(cursor.textContent || "");
          if (textWidth)
            return textWidth;
        }
        cursor = cursor.parentElement;
        depth += 1;
      }
      return "";
    }
    function findLegacyAltHintFromAncestors(el, rawAlt = "") {
      const baseAlt = String(rawAlt || "").trim();
      if (!baseAlt)
        return "";
      let cursor = el;
      let depth = 0;
      while (cursor && depth < 6) {
        if (cursor.nodeType === Node.ELEMENT_NODE) {
          const attrs = ["alt", "title", "aria-label", "data-alt", "data-caption"];
          for (const key of attrs) {
            const value = String(cursor.getAttribute(key) || "").trim();
            if (!value)
              continue;
            if (value === baseAlt)
              continue;
            if (value.startsWith(`${baseAlt}|`) && /\|\d{2,4}(x\d+)?\s*$/i.test(value)) {
              return value;
            }
          }
        }
        cursor = cursor.parentElement;
        depth += 1;
      }
      return "";
    }
    function buildLegacyParityImageAlt(imgEl, rawAlt = "") {
      var _a, _b;
      const alt = String(rawAlt || "");
      if (!alt)
        return alt;
      if (/\|\s*\d+(x\d+)?\s*$/.test(alt))
        return alt;
      const ancestorAltHint = findLegacyAltHintFromAncestors(imgEl, alt);
      if (ancestorAltHint) {
        return ancestorAltHint;
      }
      const widthAttr = String(((_a = imgEl == null ? void 0 : imgEl.getAttribute) == null ? void 0 : _a.call(imgEl, "width")) || "").trim();
      if (/^\d+$/.test(widthAttr)) {
        return `${alt}|${widthAttr}`;
      }
      const style = String(((_b = imgEl == null ? void 0 : imgEl.getAttribute) == null ? void 0 : _b.call(imgEl, "style")) || "");
      const styleMatch = style.match(/(?:^|;)\s*width\s*:\s*(\d+)px\b/i);
      if (styleMatch && styleMatch[1]) {
        return `${alt}|${styleMatch[1]}`;
      }
      const ancestorWidth = findImageWidthHintFromAncestors(imgEl);
      if (ancestorWidth) {
        return `${alt}|${ancestorWidth}`;
      }
      return alt;
    }
    function sanitizeAnchorAndImageLinks(container, converter) {
      if (!container)
        return;
      const hasExplicitProtocol = (value) => /^[a-zA-Z][a-zA-Z\d+.-]*:/.test(String(value || ""));
      const canonicalizeRelativeHrefForLegacyParity = (href) => {
        const value = String(href || "").trim();
        if (!value)
          return value;
        if (value.startsWith("#") || value.startsWith("//"))
          return value;
        if (hasExplicitProtocol(value))
          return value;
        let decoded = value;
        try {
          decoded = decodeURI(value);
        } catch (error) {
        }
        return encodeURI(decoded);
      };
      container.querySelectorAll("a[href]").forEach((a) => {
        const href = a.getAttribute("href") || "";
        const safeHref = converter && typeof converter.validateLink === "function" ? converter.validateLink(href, false) : href;
        a.setAttribute("href", canonicalizeRelativeHrefForLegacyParity(safeHref));
      });
    }
    function extractImageEmbedSrc(embedEl) {
      if (!embedEl)
        return "";
      const attrKeys = ["src", "data-src", "data-href", "href"];
      for (const key of attrKeys) {
        const val = embedEl.getAttribute(key);
        if (val && String(val).trim())
          return String(val).trim();
      }
      const text = String(embedEl.textContent || "").trim();
      const wikiMatch = text.match(/^!\[\[([^\]|]+)(?:\|[^\]]+)?\]\]$/);
      if (wikiMatch && wikiMatch[1])
        return String(wikiMatch[1]).trim();
      return "";
    }
    function looksLikeImageSrc(src) {
      const value = String(src || "").trim();
      if (!value)
        return false;
      if (/^(data:image\/|app:\/\/|capacitor:\/\/|https?:\/\/)/i.test(value))
        return true;
      return /\.(png|jpe?g|gif|webp|svg|bmp|avif)(\?|#|$)/i.test(value);
    }
    function materializeImageEmbedPlaceholders(container, converter) {
      if (!container)
        return;
      const embeds = Array.from(container.querySelectorAll("span.internal-embed,span.image-embed,div.internal-embed,div.image-embed"));
      for (const embed of embeds) {
        const hasImg = !!embed.querySelector("img");
        if (hasImg)
          continue;
        const src = extractImageEmbedSrc(embed);
        const forceAsImage = embed.classList.contains("image-embed");
        if (!src || !forceAsImage && !looksLikeImageSrc(src))
          continue;
        let resolvedSrc = normalizeObsidianImageSrcForLegacyParity(src);
        if (converter && typeof converter.resolveImagePath === "function") {
          resolvedSrc = converter.resolveImagePath(resolvedSrc);
        }
        const img = document.createElement("img");
        img.setAttribute("src", resolvedSrc);
        const alt = embed.getAttribute("alt") || "";
        if (alt)
          img.setAttribute("alt", alt);
        const widthHint = findImageWidthHintFromAncestors(embed);
        if (widthHint) {
          img.setAttribute("width", widthHint);
        }
        embed.replaceWith(img);
      }
    }
    function promoteImageEmbedAltHints(container) {
      if (!container)
        return;
      const embeds = Array.from(container.querySelectorAll("span.image-embed,div.image-embed,span.internal-embed,div.internal-embed"));
      for (const embed of embeds) {
        const img = embed.querySelector("img");
        if (!img)
          continue;
        const embedAlt = String(embed.getAttribute("alt") || "").trim();
        const imgAlt = String(img.getAttribute("alt") || "").trim();
        const hasSizedAlt = /\|\s*\d+(x\d+)?\s*$/i.test(embedAlt);
        if (hasSizedAlt) {
          if (!imgAlt || embedAlt.startsWith(`${imgAlt}|`)) {
            img.setAttribute("alt", embedAlt);
          }
        }
        const widthHint = findImageWidthHintFromAncestors(embed);
        if (widthHint && !img.getAttribute("width")) {
          img.setAttribute("width", widthHint);
        }
      }
    }
    function normalizeObsidianImageSrcForLegacyParity(src) {
      const value = String(src || "").trim();
      if (!value)
        return value;
      if (/^app:\/\/obsidian\.md\//i.test(value)) {
        try {
          const parsed = new URL(value);
          const pathname = decodeURIComponent((parsed.pathname || "").replace(/^\/+/, ""));
          return pathname || value;
        } catch (error) {
          return value.replace(/^app:\/\/obsidian\.md\/+/i, "");
        }
      }
      return value;
    }
    function convertPreBlocks(container, converter) {
      if (!container || !converter || typeof converter.createCodeBlock !== "function")
        return;
      const preBlocks = Array.from(container.querySelectorAll("pre"));
      for (const pre of preBlocks) {
        if (pre.closest(".code-snippet__fix"))
          continue;
        const codeEl = pre.querySelector("code");
        const className = `${pre.className || ""} ${(codeEl == null ? void 0 : codeEl.className) || ""}`;
        const langMatch = className.match(/language-([\w-]+)/);
        const lang = langMatch ? langMatch[1] : "text";
        const content = codeEl ? codeEl.textContent || "" : pre.textContent || "";
        const wrapper = document.createElement("div");
        wrapper.innerHTML = converter.createCodeBlock(content, lang);
        const replacement = wrapper.firstElementChild;
        if (replacement) {
          pre.replaceWith(replacement);
        }
      }
    }
    function convertStandaloneImages(container, converter) {
      if (!container)
        return;
      const imgs = Array.from(container.querySelectorAll("img"));
      for (const img of imgs) {
        if (img.closest("figure"))
          continue;
        if (img.getAttribute("alt") === "logo")
          continue;
        if (img.classList.contains("math-formula-image"))
          continue;
        let src = img.getAttribute("src") || "";
        src = normalizeObsidianImageSrcForLegacyParity(src);
        const safeSrc = converter && typeof converter.validateLink === "function" ? converter.validateLink(src, true) : src;
        src = safeSrc;
        if (!looksLikeImageSrc(src)) {
          img.setAttribute("src", safeSrc);
          img.setAttribute("data-owc-skip-style", "1");
          continue;
        }
        if (converter && typeof converter.resolveImagePath === "function") {
          src = converter.resolveImagePath(src);
        }
        const rawAlt = img.getAttribute("alt") || "";
        const alt = buildLegacyParityImageAlt(img, rawAlt);
        const caption = deriveImageCaption(converter, src, alt);
        const figure = document.createElement("figure");
        if (converter && converter.avatarUrl) {
          let figureStyle = getTagStyle(converter, "figure");
          figureStyle = figureStyle.replace("text-align: center;", "text-align: left;");
          appendInlineStyle(figure, figureStyle);
          const header = document.createElement("div");
          appendInlineStyle(header, getTagStyle(converter, "avatar-header"));
          const avatar = document.createElement("img");
          avatar.setAttribute("src", converter.avatarUrl);
          avatar.setAttribute("alt", "logo");
          appendInlineStyle(avatar, getTagStyle(converter, "avatar"));
          const captionEl = document.createElement("span");
          appendInlineStyle(captionEl, getTagStyle(converter, "avatar-caption"));
          captionEl.textContent = caption;
          header.appendChild(avatar);
          header.appendChild(captionEl);
          const spacer = document.createElement("section");
          spacer.setAttribute("style", "display:block;height:8px;line-height:8px;font-size:0;");
          spacer.innerHTML = "&nbsp;";
          const bodyImg2 = document.createElement("img");
          bodyImg2.setAttribute("src", src);
          bodyImg2.setAttribute("alt", alt);
          appendInlineStyle(bodyImg2, getTagStyle(converter, "img"));
          figure.appendChild(header);
          figure.appendChild(spacer);
          figure.appendChild(bodyImg2);
          img.replaceWith(figure);
          continue;
        }
        figure.setAttribute("style", "display:block;margin:16px 0;text-align:center;");
        const bodyImg = document.createElement("img");
        bodyImg.setAttribute("src", src);
        bodyImg.setAttribute("alt", alt);
        appendInlineStyle(bodyImg, getTagStyle(converter, "img"));
        figure.appendChild(bodyImg);
        const showCaption = !converter || converter.showImageCaption !== false;
        if (showCaption) {
          const figcaption = document.createElement("figcaption");
          appendInlineStyle(figcaption, getTagStyle(converter, "figcaption"));
          figcaption.textContent = caption;
          figure.appendChild(figcaption);
        }
        img.replaceWith(figure);
      }
    }
    function trimTrailingWhitespaceInBlockText(container) {
      if (!container)
        return;
      const selector = "p,li,blockquote,h1,h2,h3,h4,h5,h6,figcaption,td,th";
      const blocks = Array.from(container.querySelectorAll(selector));
      for (const block of blocks) {
        let node = block.lastChild;
        while (node) {
          if (node.nodeType === Node.TEXT_NODE) {
            const original = String(node.textContent || "");
            const trimmed = original.replace(/[ \t\u00a0]+$/g, "");
            if (trimmed !== original) {
              if (trimmed) {
                node.textContent = trimmed;
                break;
              }
              const prev = node.previousSibling;
              node.remove();
              node = prev;
              continue;
            }
          }
          break;
        }
      }
    }
    function trimLeadingWhitespaceInBlockText(container) {
      if (!container)
        return;
      const selector = "p,li,blockquote,h1,h2,h3,h4,h5,h6,figcaption,td,th";
      const blocks = Array.from(container.querySelectorAll(selector));
      for (const block of blocks) {
        let node = block.firstChild;
        while (node) {
          if (node.nodeType === Node.TEXT_NODE) {
            const original = String(node.textContent || "");
            const trimmed = original.replace(/^[ \t\u00a0]+/g, "");
            if (trimmed !== original) {
              if (trimmed) {
                node.textContent = trimmed;
                break;
              }
              const next = node.nextSibling;
              node.remove();
              node = next;
              continue;
            }
          }
          break;
        }
      }
    }
    function applyThemeInlineStyles(container, converter) {
      if (!container || !converter)
        return;
      const styledTags = [
        "p",
        "blockquote",
        "pre",
        "code",
        "ul",
        "ol",
        "li",
        "figure",
        "figcaption",
        "img",
        "a",
        "table",
        "thead",
        "th",
        "td",
        "hr",
        "strong",
        "em",
        "del",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6"
      ];
      for (const tag of styledTags) {
        const styleText = getTagStyle(converter, tag);
        if (!styleText)
          continue;
        container.querySelectorAll(tag).forEach((el) => {
          if (tag === "img" && el.getAttribute("data-owc-skip-style") === "1") {
            return;
          }
          setInlineStyleIfMissing(el, styleText);
        });
      }
      const liPStyle = getTagStyle(converter, "li p");
      if (liPStyle) {
        container.querySelectorAll("li > p").forEach((p) => setInlineStyleIfMissing(p, liPStyle));
      }
    }
    function stripDangerousTags(container) {
      if (!container)
        return;
      container.querySelectorAll("script,iframe,object,embed,form,input,button,style").forEach((el) => el.remove());
    }
    function applyLegacyTypographerParity(container, converter) {
      if (!container || !converter || !converter.md)
        return;
      if (typeof converter.md.renderInline !== "function")
        return;
      if (converter.md.options && converter.md.options.typographer !== true)
        return;
      if (typeof document === "undefined")
        return;
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      const decodeHost = document.createElement("div");
      const interestingPattern = /["']|\.{3}|---?|\+-|\((?:c|r|tm)\)/i;
      let node = walker.nextNode();
      while (node) {
        const current = node;
        node = walker.nextNode();
        const parent = current.parentElement;
        if (!parent)
          continue;
        if (parent.closest("pre,code,kbd,samp,script,style,textarea,svg,mjx-container,mjx-math,math"))
          continue;
        const original = String(current.textContent || "");
        if (!original || !interestingPattern.test(original))
          continue;
        let rendered = "";
        try {
          rendered = converter.md.renderInline(original);
        } catch (error) {
          continue;
        }
        if (!rendered || rendered === original)
          continue;
        decodeHost.innerHTML = rendered;
        const normalized = String(decodeHost.textContent || "");
        if (normalized && normalized !== original) {
          current.textContent = normalized;
        }
      }
    }
    function applyLegacyLinkifyParity(container, converter) {
      if (!container || !converter || !converter.md || !converter.md.linkify)
        return;
      if (typeof converter.md.linkify.match !== "function")
        return;
      if (typeof document === "undefined")
        return;
      const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT);
      let node = walker.nextNode();
      while (node) {
        const current = node;
        node = walker.nextNode();
        const parent = current.parentElement;
        if (!parent)
          continue;
        if (parent.closest("a,pre,code,kbd,samp,script,style,textarea,svg,mjx-container,mjx-math,math"))
          continue;
        const original = String(current.textContent || "");
        if (!original || !original.includes("."))
          continue;
        let matches = null;
        try {
          matches = converter.md.linkify.match(original);
        } catch (error) {
          matches = null;
        }
        if (!Array.isArray(matches) || matches.length === 0)
          continue;
        const fragment = document.createDocumentFragment();
        let cursor = 0;
        for (const item of matches) {
          const start = Number.isFinite(item == null ? void 0 : item.index) ? item.index : -1;
          const end = Number.isFinite(item == null ? void 0 : item.lastIndex) ? item.lastIndex : -1;
          if (start < 0 || end <= start || start < cursor || end > original.length)
            continue;
          if (start > cursor) {
            fragment.appendChild(document.createTextNode(original.slice(cursor, start)));
          }
          const displayText = original.slice(start, end);
          const hrefCandidate = String((item == null ? void 0 : item.url) || (item == null ? void 0 : item.text) || displayText || "").trim();
          const href = converter && typeof converter.validateLink === "function" ? converter.validateLink(hrefCandidate, false) : hrefCandidate;
          const a = document.createElement("a");
          a.setAttribute("href", href);
          a.textContent = displayText;
          fragment.appendChild(a);
          cursor = end;
        }
        if (cursor === 0)
          continue;
        if (cursor < original.length) {
          fragment.appendChild(document.createTextNode(original.slice(cursor)));
        }
        current.replaceWith(fragment);
      }
    }
    function serializeObsidianRenderedHtml({ root, converter }) {
      if (typeof document === "undefined") {
        throw new Error("Triplet serializer requires DOM environment");
      }
      const container = document.createElement("div");
      container.innerHTML = root ? root.innerHTML : "";
      materializeImageEmbedPlaceholders(container, converter);
      promoteImageEmbedAltHints(container);
      convertObsidianCalloutsToLegacy(container, converter);
      pruneObsidianOnlyAttributes(container, { finalStage: false });
      normalizeLegacyTagAliases(container);
      normalizeLegacyDeleteNesting(container);
      stripDangerousTags(container);
      applyLegacyLinkifyParity(container, converter);
      applyLegacyTypographerParity(container, converter);
      sanitizeAnchorAndImageLinks(container, converter);
      convertPreBlocks(container, converter);
      convertStandaloneImages(container, converter);
      applyThemeInlineStyles(container, converter);
      pruneObsidianOnlyAttributes(container, { finalStage: true });
      trimLeadingWhitespaceInBlockText(container);
      trimTrailingWhitespaceInBlockText(container);
      let html = container.innerHTML;
      if (converter && typeof converter.fixListParagraphs === "function") {
        html = converter.fixListParagraphs(html);
      }
      if (converter && typeof converter.unwrapFigures === "function") {
        html = converter.unwrapFigures(html);
      }
      if (converter && typeof converter.removeBlockquoteParagraphMargins === "function") {
        html = converter.removeBlockquoteParagraphMargins(html);
      }
      if (converter && typeof converter.fixMathJaxTags === "function") {
        html = converter.fixMathJaxTags(html);
      }
      if (converter && typeof converter.sanitizeHtml === "function") {
        html = converter.sanitizeHtml(html);
      }
      html = normalizeLegacyDeleteNestingInHtml(html);
      const sectionStyle = getTagStyle(converter, "section");
      return `<section style="${sectionStyle}">${html}</section>`;
    }
    module2.exports = {
      serializeObsidianRenderedHtml,
      deriveImageCaption,
      safeDecodeCaption
    };
  }
});

// services/obsidian-triplet-renderer.js
var require_obsidian_triplet_renderer = __commonJS({
  "services/obsidian-triplet-renderer.js"(exports2, module2) {
    var { MarkdownRenderer } = require("obsidian");
    var { serializeObsidianRenderedHtml } = require_obsidian_triplet_serializer();
    function containsLegacyIncompatibleMathMarkup(html) {
      const value = String(html || "");
      return /<mjx-(?:math|container)\b/i.test(value);
    }
    function isFencedBlockDelimiter(line) {
      return /^\s{0,3}(?:`{3,}|~{3,})/.test(String(line || ""));
    }
    function parseFencedBlockDelimiter(line) {
      const value = String(line || "");
      const match = value.match(/^\s{0,3}((`{3,})|(~{3,}))(.*)$/);
      if (!match)
        return null;
      const markerRun = match[1] || "";
      const markerChar = markerRun.charAt(0);
      if (markerChar !== "`" && markerChar !== "~")
        return null;
      return {
        marker: markerChar,
        length: markerRun.length
      };
    }
    function isMathFenceDelimiter(line) {
      return /^\s*\$\$\s*$/.test(String(line || ""));
    }
    function isQuoteLine(line) {
      return /^\s{0,3}(?:>\s?)+/.test(String(line || ""));
    }
    function stripQuotePrefix(line) {
      return String(line || "").replace(/^\s{0,3}(?:>\s?)+/, "");
    }
    function startsNewBlock(trimmedLine) {
      if (!trimmedLine)
        return true;
      if (/^#{1,6}\s/.test(trimmedLine))
        return true;
      if (/^>/.test(trimmedLine))
        return true;
      if (/^([-*_])(?:\s*\1){2,}\s*$/.test(trimmedLine))
        return true;
      if (/^(?:[*+-]|\d+[.)])\s+/.test(trimmedLine))
        return true;
      if (/^\|/.test(trimmedLine))
        return true;
      if (/^<[^>]+>/.test(trimmedLine))
        return true;
      if (isFencedBlockDelimiter(trimmedLine))
        return true;
      return false;
    }
    function isListItemLine(trimmedLine) {
      return /^(?:[*+-]|\d+[.)])\s+/.test(String(trimmedLine || ""));
    }
    function appendLegacyHardBreak(line) {
      const value = String(line || "");
      if (!value)
        return value;
      if (/<br\s*\/?>\s*$/i.test(value))
        return value;
      return `${value.replace(/[ \t]+$/, "")}<br>`;
    }
    function appendQuoteHardBreak(line) {
      const value = String(line || "");
      if (!value)
        return value;
      if (/\\\s*$/.test(value))
        return value;
      return `${value.replace(/[ \t]+$/, "")}\\`;
    }
    function injectHardBreaksForLegacyParity(markdown) {
      const lines = String(markdown || "").split("\n");
      let fenceState = null;
      let inMathFence = false;
      for (let i = 0; i < lines.length - 1; i += 1) {
        const line = lines[i];
        const nextLine = lines[i + 1];
        const fenceDelimiter = parseFencedBlockDelimiter(line);
        if (fenceDelimiter) {
          if (!fenceState) {
            fenceState = fenceDelimiter;
          } else if (fenceDelimiter.marker === fenceState.marker && fenceDelimiter.length >= fenceState.length) {
            fenceState = null;
          }
          continue;
        }
        if (!fenceState && isMathFenceDelimiter(line)) {
          inMathFence = !inMathFence;
          continue;
        }
        if (fenceState || inMathFence)
          continue;
        if (!line || !nextLine)
          continue;
        if (/[ \t]{2,}$/.test(line) || /\\$/.test(line))
          continue;
        if (isQuoteLine(line) && isQuoteLine(nextLine)) {
          const currentQuoteContent = stripQuotePrefix(line).trim();
          const nextQuoteContent = stripQuotePrefix(nextLine).trim();
          if (!currentQuoteContent || !nextQuoteContent)
            continue;
          if (/^\[!/.test(currentQuoteContent) || /^\[!/.test(nextQuoteContent))
            continue;
          lines[i] = appendQuoteHardBreak(line);
          continue;
        }
        const currentTrimmed = line.trim();
        if (startsNewBlock(currentTrimmed) && !isListItemLine(currentTrimmed))
          continue;
        if (startsNewBlock(nextLine.trim()))
          continue;
        lines[i] = appendLegacyHardBreak(line);
      }
      return lines.join("\n");
    }
    function neutralizeUnsafeMarkdownLinks(markdown) {
      const source = String(markdown || "");
      if (!source)
        return source;
      const unsafeLinkPattern = /\[[^\]]+\]\(((?:javascript|vbscript|data):[^)\r\n]*)\)/gi;
      return source.replace(unsafeLinkPattern, (match, _href, offset, fullText) => {
        const prevChar = offset > 0 ? fullText[offset - 1] : "";
        if (prevChar === "!" || prevChar === "\\") {
          return match;
        }
        return `\\${match}`;
      });
    }
    function neutralizePlainWikilinks(markdown) {
      const source = String(markdown || "");
      if (!source)
        return source;
      const escapePlainWikilinks = (value) => String(value || "").replace(/(^|[^!\\])(\[\[[^[\]\r\n]+?\]\])/g, (_match, prefix, wikilink) => {
        return `${prefix}\\${wikilink}`;
      });
      const neutralizeLineOutsideInlineCode = (line) => {
        const value = String(line || "");
        if (!value || !value.includes("[["))
          return value;
        let result = "";
        let cursor = 0;
        const codeSpanPattern = /(`+)([\s\S]*?)(\1)/g;
        let match = codeSpanPattern.exec(value);
        while (match) {
          const [segment] = match;
          const start = match.index;
          const end = start + segment.length;
          result += escapePlainWikilinks(value.slice(cursor, start));
          result += segment;
          cursor = end;
          match = codeSpanPattern.exec(value);
        }
        result += escapePlainWikilinks(value.slice(cursor));
        return result;
      };
      const lines = source.split("\n");
      let fenceState = null;
      let inMathFence = false;
      for (let i = 0; i < lines.length; i += 1) {
        const line = lines[i];
        const fenceDelimiter = parseFencedBlockDelimiter(line);
        if (fenceDelimiter) {
          if (!fenceState) {
            fenceState = fenceDelimiter;
          } else if (fenceDelimiter.marker === fenceState.marker && fenceDelimiter.length >= fenceState.length) {
            fenceState = null;
          }
          continue;
        }
        if (!fenceState && isMathFenceDelimiter(line)) {
          inMathFence = !inMathFence;
          continue;
        }
        if (fenceState || inMathFence)
          continue;
        lines[i] = neutralizeLineOutsideInlineCode(line);
      }
      return lines.join("\n");
    }
    function preprocessMarkdownForTriplet(markdown, converter) {
      let output = String(markdown || "");
      output = output.replace(/^[\t ]+(\$\$)/gm, "$1");
      output = output.replace(/!\[\[([^\[\]|]+)(?:\|([^\[\]]+))?\]\]/g, (match, imagePath, alt) => {
        return `![${alt || ""}](${encodeURI(String(imagePath || "").trim())})`;
      });
      if (converter && typeof converter.stripFrontmatter === "function") {
        output = converter.stripFrontmatter(output);
      }
      output = neutralizeUnsafeMarkdownLinks(output);
      output = neutralizePlainWikilinks(output);
      output = injectHardBreaksForLegacyParity(output);
      return output;
    }
    function countUnresolvedImageEmbeds(root) {
      if (!root)
        return 0;
      const embeds = Array.from(root.querySelectorAll("span.internal-embed,span.image-embed,div.internal-embed,div.image-embed"));
      let unresolved = 0;
      for (const embed of embeds) {
        const isImageEmbed = embed.classList.contains("image-embed");
        const hasImgChild = !!embed.querySelector("img");
        if (isImageEmbed && !hasImgChild) {
          unresolved += 1;
        }
      }
      return unresolved;
    }
    async function waitForTripletDomToSettle(root, options = {}) {
      const timeoutMs = Number.isFinite(options.timeoutMs) ? options.timeoutMs : 500;
      const intervalMs = Number.isFinite(options.intervalMs) ? options.intervalMs : 16;
      const start = Date.now();
      let previousSnapshot = "";
      let stableCount = 0;
      while (Date.now() - start < timeoutMs) {
        const unresolved = countUnresolvedImageEmbeds(root);
        const snapshot = `${unresolved}:${root ? root.innerHTML : ""}`;
        if (unresolved === 0 && snapshot === previousSnapshot) {
          stableCount += 1;
          if (stableCount >= 2)
            return;
        } else {
          stableCount = 0;
        }
        previousSnapshot = snapshot;
        await new Promise((resolve) => setTimeout(resolve, intervalMs));
      }
    }
    async function renderByObsidianMarkdownRenderer({
      app,
      markdown,
      sourcePath,
      targetEl,
      component = null,
      markdownRenderer = MarkdownRenderer
    }) {
      if (!markdownRenderer) {
        throw new Error("Obsidian MarkdownRenderer is not available");
      }
      if (typeof markdownRenderer.renderMarkdown === "function") {
        await markdownRenderer.renderMarkdown(markdown, targetEl, sourcePath || "", component);
        return;
      }
      if (typeof markdownRenderer.render === "function") {
        if (!app)
          throw new Error("Obsidian app instance is required for MarkdownRenderer.render");
        await markdownRenderer.render(app, markdown, targetEl, sourcePath || "", component);
        return;
      }
      throw new Error("Obsidian MarkdownRenderer does not expose renderMarkdown/render");
    }
    async function renderObsidianTripletMarkdown2({
      app,
      converter,
      markdown,
      sourcePath = "",
      component = null,
      markdownRenderer = MarkdownRenderer,
      serializer = serializeObsidianRenderedHtml
    }) {
      if (typeof document === "undefined") {
        throw new Error("Triplet renderer requires DOM environment");
      }
      if (!converter) {
        throw new Error("Triplet renderer requires converter runtime");
      }
      const container = document.createElement("div");
      const preparedMarkdown = preprocessMarkdownForTriplet(markdown, converter);
      await renderByObsidianMarkdownRenderer({
        app,
        markdown: preparedMarkdown,
        sourcePath,
        targetEl: container,
        component,
        markdownRenderer
      });
      await waitForTripletDomToSettle(container);
      const serializedHtml = serializer({
        root: container,
        converter,
        sourcePath,
        app
      });
      if (containsLegacyIncompatibleMathMarkup(serializedHtml) && typeof converter.convert === "function") {
        if (typeof converter.updateSourcePath === "function") {
          converter.updateSourcePath(sourcePath);
        }
        return converter.convert(markdown);
      }
      return serializedHtml;
    }
    module2.exports = {
      containsLegacyIncompatibleMathMarkup,
      neutralizeUnsafeMarkdownLinks,
      neutralizePlainWikilinks,
      preprocessMarkdownForTriplet,
      injectHardBreaksForLegacyParity,
      waitForTripletDomToSettle,
      renderByObsidianMarkdownRenderer,
      renderObsidianTripletMarkdown: renderObsidianTripletMarkdown2
    };
  }
});

// services/wechat-sync.js
var require_wechat_sync = __commonJS({
  "services/wechat-sync.js"(exports2, module2) {
    function createWechatSyncService2(deps) {
      const {
        createApi,
        srcToBlob,
        processAllImages,
        processMathFormulas,
        cleanHtmlForDraft,
        cleanupConfiguredDirectory,
        getFirstImageFromArticle
      } = deps;
      return {
        async syncToDraft({
          account,
          proxyUrl,
          currentHtml,
          activeFile,
          publishMeta,
          sessionCoverBase64,
          sessionDigest,
          onStatus,
          onImageProgress,
          onMathProgress
        }) {
          const api = createApi(account.appId, account.appSecret, proxyUrl);
          if (onStatus)
            onStatus("cover");
          const coverSrc = sessionCoverBase64 || publishMeta.coverSrc || getFirstImageFromArticle();
          if (!coverSrc) {
            throw new Error("\u672A\u8BBE\u7F6E\u5C01\u9762\u56FE\uFF0C\u540C\u6B65\u5931\u8D25\u3002\u8BF7\u5728\u5F39\u7A97\u4E2D\u4E0A\u4F20\u5C01\u9762\u3002");
          }
          const coverBlob = await srcToBlob(coverSrc);
          const coverRes = await api.uploadCover(coverBlob);
          const thumbMediaId = coverRes.media_id;
          if (onStatus)
            onStatus("images");
          let processedHtml = await processAllImages(currentHtml, api, (current, total) => {
            if (onImageProgress)
              onImageProgress(current, total);
          }, {
            accountId: account.id || ""
          });
          if (processedHtml.includes("mjx-container") || processedHtml.includes("<svg")) {
            if (onStatus)
              onStatus("math");
            processedHtml = await processMathFormulas(processedHtml, api, (current, total) => {
              if (onMathProgress)
                onMathProgress(current, total);
            });
          }
          const cleanedHtml = cleanHtmlForDraft(processedHtml);
          const base64Count = (cleanedHtml.match(/src=["']data:image/g) || []).length;
          if (base64Count > 0) {
            throw new Error(`\u68C0\u6D4B\u5230 ${base64Count} \u5F20\u56FE\u7247\u672A\u6210\u529F\u4E0A\u4F20\uFF08\u4ECD\u4E3A Base64 \u683C\u5F0F\uFF09\uFF0C\u8FD9\u4F1A\u5BFC\u81F4\u540C\u6B65\u5931\u8D25\u3002\u5EFA\u8BAE\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\u5E76\u91CD\u8BD5\u3002`);
          }
          const title = activeFile ? activeFile.basename : "\u65E0\u6807\u9898\u6587\u7AE0";
          const article = {
            title: title.substring(0, 64),
            content: cleanedHtml,
            thumb_media_id: thumbMediaId,
            author: account.author || "",
            digest: sessionDigest || "\u4E00\u952E\u540C\u6B65\u81EA Obsidian"
          };
          if (onStatus)
            onStatus("draft");
          await api.createDraft(article);
          const cleanupResult = await cleanupConfiguredDirectory(activeFile);
          return {
            article,
            cleanupResult
          };
        }
      };
    }
    module2.exports = {
      createWechatSyncService: createWechatSyncService2
    };
  }
});

// services/sync-context.js
var require_sync_context = __commonJS({
  "services/sync-context.js"(exports2, module2) {
    function resolveSyncAccount2({ accounts, selectedAccountId, defaultAccountId }) {
      const list = Array.isArray(accounts) ? accounts : [];
      const accountId = selectedAccountId || defaultAccountId;
      return list.find((account) => account.id === accountId) || null;
    }
    function toSyncFriendlyMessage2(errorMessage = "") {
      if (errorMessage.includes("45002")) {
        return "\u6587\u7AE0\u592A\u957F\uFF0C\u5FAE\u4FE1\u63A5\u53E3\u62D2\u6536\u3002\u5EFA\u8BAE\u5206\u7BC7\u53D1\u9001\uFF0C\u6216\u4F7F\u7528\u63D2\u4EF6\u9876\u90E8\u7684\u300C\u590D\u5236\u300D\u6309\u94AE\u624B\u52A8\u7C98\u8D34\u5230\u516C\u4F17\u53F7\u540E\u53F0\u3002";
      }
      return errorMessage;
    }
    module2.exports = {
      resolveSyncAccount: resolveSyncAccount2,
      toSyncFriendlyMessage: toSyncFriendlyMessage2
    };
  }
});

// services/wechat-media.js
var require_wechat_media = __commonJS({
  "services/wechat-media.js"(exports2, module2) {
    function hashBytesFNV1a(bytes) {
      let hash = 2166136261;
      for (let i = 0; i < bytes.length; i++) {
        hash ^= bytes[i];
        hash = Math.imul(hash, 16777619);
      }
      return (hash >>> 0).toString(16).padStart(8, "0");
    }
    async function computeBlobFingerprint(blob) {
      if (!blob || typeof blob.arrayBuffer !== "function")
        return "unknown";
      const buffer = await blob.arrayBuffer();
      const bytes = new Uint8Array(buffer);
      const contentHash = hashBytesFNV1a(bytes);
      const type = blob.type || "application/octet-stream";
      return `${type}:${bytes.length}:${contentHash}`;
    }
    function getCachedEntry(cache, key) {
      if (!cache || !cache.has(key))
        return null;
      const value = cache.get(key);
      if (typeof value === "string") {
        return { url: value, fingerprint: "" };
      }
      if (value && typeof value === "object" && typeof value.url === "string") {
        return value;
      }
      return null;
    }
    async function processAllImages({
      html,
      api,
      progressCallback,
      pMap: pMap2,
      srcToBlob,
      imageUploadCache,
      cacheNamespace = ""
    }) {
      const div = document.createElement("div");
      div.innerHTML = html;
      const imgs = Array.from(div.querySelectorAll("img"));
      const uniqueUrls = /* @__PURE__ */ new Set();
      const urlMap = /* @__PURE__ */ new Map();
      for (const img of imgs) {
        if (img.src)
          uniqueUrls.add(img.src);
      }
      const total = uniqueUrls.size;
      let completed = 0;
      const tasks = Array.from(uniqueUrls);
      await pMap2(tasks, async (src) => {
        const cacheKey = `${cacheNamespace}::${src}`;
        const cached = getCachedEntry(imageUploadCache, cacheKey);
        try {
          const blob = await srcToBlob(src);
          const fingerprint = await computeBlobFingerprint(blob);
          if (cached && cached.fingerprint && cached.fingerprint === fingerprint && cached.url) {
            urlMap.set(src, cached.url);
            completed++;
            if (progressCallback) {
              progressCallback(completed, total);
            }
            return;
          }
          const res = await api.uploadImage(blob);
          urlMap.set(src, res.url);
          if (imageUploadCache) {
            imageUploadCache.set(cacheKey, {
              url: res.url,
              fingerprint
            });
          }
        } catch (error) {
          if (error.isFatal)
            throw error;
          if (cached && cached.url) {
            console.warn("\u56FE\u7247\u8BFB\u53D6\u5931\u8D25\uFF0C\u4F7F\u7528\u7F13\u5B58\u94FE\u63A5\u515C\u5E95:", src);
            urlMap.set(src, cached.url);
          } else {
            console.error("\u56FE\u7247\u5904\u7406\u5931\u8D25\uFF0C\u5DF2\u8DF3\u8FC7:", src, error);
          }
        }
        completed++;
        if (progressCallback) {
          progressCallback(completed, total);
        }
      }, 3);
      for (const img of imgs) {
        if (urlMap.has(img.src)) {
          img.src = urlMap.get(img.src);
        }
      }
      return div.innerHTML;
    }
    async function processMathFormulas({
      html,
      api,
      progressCallback,
      pMap: pMap2,
      simpleHash,
      svgUploadCache,
      svgToPngBlob
    }) {
      const container = document.createElement("div");
      container.style.position = "absolute";
      container.style.left = "-9999px";
      container.style.top = "0";
      container.style.width = "800px";
      container.innerHTML = html;
      document.body.appendChild(container);
      try {
        const mathNodes = Array.from(container.querySelectorAll("svg"));
        if (mathNodes.length === 0)
          return html;
        const total = mathNodes.length;
        let completed = 0;
        await pMap2(mathNodes, async (svg) => {
          try {
            const svgStr = new XMLSerializer().serializeToString(svg);
            const styleAttr = svg.getAttribute("style") || "";
            const fillAttr = svg.getAttribute("fill") || "";
            const fingerprint = simpleHash(svgStr + styleAttr + fillAttr);
            let wechatUrl = "";
            let logicalWidth, logicalHeight, rawStyle;
            if (svgUploadCache.has(fingerprint)) {
              const cachedData = svgUploadCache.get(fingerprint);
              wechatUrl = cachedData.url;
              logicalWidth = cachedData.width;
              logicalHeight = cachedData.height;
              rawStyle = cachedData.style;
            } else {
              const result = await svgToPngBlob(svg);
              const res = await api.uploadImage(result.blob);
              wechatUrl = res.url;
              logicalWidth = result.width;
              logicalHeight = result.height;
              rawStyle = result.style;
              svgUploadCache.set(fingerprint, {
                url: wechatUrl,
                width: logicalWidth,
                height: logicalHeight,
                style: rawStyle
              });
            }
            const img = document.createElement("img");
            img.src = wechatUrl;
            img.className = "math-formula-image";
            if (logicalWidth)
              img.setAttribute("width", logicalWidth);
            if (logicalHeight)
              img.setAttribute("height", logicalHeight);
            let finalStyle = "display: inline-block; margin: 0 2px;";
            const svgStyle = svg.getAttribute("style");
            if (svgStyle)
              finalStyle += svgStyle;
            const parent = svg.parentElement;
            if (parent && parent.tagName.toLowerCase().includes("mjx")) {
              const parentStyle = parent.getAttribute("style");
              if (parentStyle)
                finalStyle += parentStyle;
              img.setAttribute("style", finalStyle);
              parent.replaceWith(img);
            } else {
              if (rawStyle)
                finalStyle += rawStyle;
              img.setAttribute("style", finalStyle);
              svg.replaceWith(img);
            }
            completed++;
            if (progressCallback)
              progressCallback(completed, total);
          } catch (error) {
            if (error.isFatal)
              throw error;
            console.error("\u516C\u5F0F\u8F6C\u6362\u5931\u8D25\uFF0C\u4FDD\u7559\u539FSVG:", error);
          }
        }, 3);
        return container.innerHTML;
      } finally {
        document.body.removeChild(container);
      }
    }
    module2.exports = {
      processAllImages,
      processMathFormulas
    };
  }
});

// services/wechat-html-cleaner.js
var require_wechat_html_cleaner = __commonJS({
  "services/wechat-html-cleaner.js"(exports2, module2) {
    function cleanHtmlForDraft(html) {
      const div = document.createElement("div");
      div.innerHTML = html;
      const getInlineLabelPrefixInfo = (container) => {
        if (!container)
          return null;
        const nodes = Array.from(container.childNodes);
        const firstElementIdx = nodes.findIndex((node) => node.nodeType === Node.ELEMENT_NODE);
        if (firstElementIdx === -1)
          return null;
        const hasOnlyWhitespaceBefore = nodes.slice(0, firstElementIdx).every((node) => node.nodeType === Node.TEXT_NODE && !node.textContent.trim());
        if (!hasOnlyWhitespaceBefore)
          return null;
        const firstElement = nodes[firstElementIdx];
        if (!["STRONG", "CODE"].includes(firstElement.tagName))
          return null;
        const elementText = (firstElement.textContent || "").trim();
        if (/[：:]$/.test(elementText)) {
          return { firstElementIdx, prefixEndIdx: firstElementIdx };
        }
        const nextNode = nodes[firstElementIdx + 1];
        if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
          const nextText = nextNode.textContent || "";
          if (/^\s*[：:]/.test(nextText)) {
            return { firstElementIdx, prefixEndIdx: firstElementIdx + 1 };
          }
        }
        return null;
      };
      const hasInlineLabelPrefix = (container) => !!getInlineLabelPrefixInfo(container);
      const collapseLabelBreakInParagraph = (paragraph) => {
        const prefixInfo = getInlineLabelPrefixInfo(paragraph);
        if (!prefixInfo)
          return;
        const nodes = Array.from(paragraph.childNodes);
        const startIdx = prefixInfo.prefixEndIdx + 1;
        if (prefixInfo.prefixEndIdx > prefixInfo.firstElementIdx) {
          const colonNode = nodes[prefixInfo.prefixEndIdx];
          if (colonNode && colonNode.nodeType === Node.TEXT_NODE) {
            colonNode.textContent = (colonNode.textContent || "").replace(/^\s*([：:])\s*/, "$1 ");
          }
        }
        let sawBreak = false;
        for (let i = startIdx; i < nodes.length; i += 1) {
          const node = nodes[i];
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "BR") {
            node.remove();
            sawBreak = true;
            continue;
          }
          if (node.nodeType === Node.TEXT_NODE) {
            if (!node.textContent.trim())
              continue;
            const hasLeadingWhitespace = /^\s+/.test(node.textContent);
            if (sawBreak || hasLeadingWhitespace) {
              node.textContent = node.textContent.replace(/^\s+/, " ");
            }
            return;
          }
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (sawBreak)
              paragraph.insertBefore(document.createTextNode(" "), node);
            return;
          }
        }
      };
      const isInlineOnlyParagraph = (paragraph) => {
        if (!paragraph)
          return false;
        const blockLikeTags = /* @__PURE__ */ new Set(["UL", "OL", "TABLE", "PRE", "BLOCKQUOTE", "SECTION", "FIGURE", "DIV", "P"]);
        return !Array.from(paragraph.querySelectorAll("*")).some((el) => blockLikeTags.has(el.tagName));
      };
      const unwrapSimpleListParagraphs = (li) => {
        const hasDirectNestedList = Array.from(li.children).some((child) => child.tagName === "UL" || child.tagName === "OL");
        if (hasDirectNestedList)
          return;
        const meaningfulChildren = Array.from(li.childNodes).filter(
          (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
        );
        if (meaningfulChildren.length === 0)
          return;
        const allInlineParagraphs = meaningfulChildren.every(
          (node) => node.nodeType === Node.ELEMENT_NODE && node.tagName === "P" && isInlineOnlyParagraph(node)
        );
        if (!allInlineParagraphs)
          return;
        const fragment = document.createDocumentFragment();
        meaningfulChildren.forEach((paragraph, index) => {
          while (paragraph.firstChild) {
            fragment.appendChild(paragraph.firstChild);
          }
          if (index < meaningfulChildren.length - 1) {
            fragment.appendChild(document.createTextNode(" "));
          }
        });
        while (li.firstChild) {
          li.removeChild(li.firstChild);
        }
        li.appendChild(fragment);
      };
      const collapseLabelBreakInListItem = (li) => {
        const prefixInfo = getInlineLabelPrefixInfo(li);
        if (!prefixInfo)
          return;
        const nodes = Array.from(li.childNodes);
        const startIdx = prefixInfo.prefixEndIdx + 1;
        if (prefixInfo.prefixEndIdx > prefixInfo.firstElementIdx) {
          const colonNode = nodes[prefixInfo.prefixEndIdx];
          if (colonNode && colonNode.nodeType === Node.TEXT_NODE) {
            colonNode.textContent = (colonNode.textContent || "").replace(/^\s*([：:])\s*/, "$1 ");
          }
        }
        let sawBreak = false;
        for (let i = startIdx; i < nodes.length; i += 1) {
          const node = nodes[i];
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "BR") {
            node.remove();
            sawBreak = true;
            continue;
          }
          if (node.nodeType === Node.TEXT_NODE) {
            if (!node.textContent.trim())
              continue;
            const hasLeadingWhitespace = /^\s+/.test(node.textContent);
            if (sawBreak || hasLeadingWhitespace) {
              node.textContent = node.textContent.replace(/^\s+/, " ");
            }
            return;
          }
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (sawBreak)
              li.insertBefore(document.createTextNode(" "), node);
            return;
          }
        }
      };
      const convertLeadingStrongOrCodeToSpan = (li) => {
        const getFirstMeaningfulNode = (container) => {
          if (!container)
            return null;
          return Array.from(container.childNodes).find(
            (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
          ) || null;
        };
        let firstNode = getFirstMeaningfulNode(li);
        if (!firstNode)
          return;
        if (firstNode.nodeType === Node.ELEMENT_NODE && firstNode.tagName === "P") {
          firstNode = getFirstMeaningfulNode(firstNode);
        }
        if (!firstNode || firstNode.nodeType !== Node.ELEMENT_NODE)
          return;
        if (!["STRONG", "CODE"].includes(firstNode.tagName))
          return;
        const span = document.createElement("span");
        const currentStyle = firstNode.getAttribute("style") || "";
        const cleanedStyle = currentStyle.replace(/display\s*:\s*[^;]+;?/gi, "").replace(/width\s*:\s*[^;]+;?/gi, "").replace(/float\s*:\s*[^;]+;?/gi, "").trim();
        const normalizedStyle = cleanedStyle ? `${cleanedStyle}${cleanedStyle.trim().endsWith(";") ? "" : ";"}` : "";
        const extraStyle = firstNode.tagName === "CODE" ? " margin:0 2px !important; vertical-align:baseline;" : "";
        span.setAttribute("style", `${normalizedStyle}display:inline !important; width:auto !important; float:none !important;${extraStyle}`);
        span.innerHTML = firstNode.innerHTML;
        firstNode.replaceWith(span);
      };
      const wrapLeadingLabelInBlockSpan = (li) => {
        const hasDirectNestedList = Array.from(li.children).some((child) => child.tagName === "UL" || child.tagName === "OL");
        if (hasDirectNestedList)
          return;
        const nodes = Array.from(li.childNodes).filter(
          (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
        );
        if (nodes.length < 2)
          return;
        const firstNode = nodes[0];
        if (firstNode.nodeType !== Node.ELEMENT_NODE)
          return;
        if (firstNode.tagName !== "SPAN")
          return;
        const firstText = (firstNode.textContent || "").trim();
        const secondNode = nodes[1];
        const secondText = secondNode.nodeType === Node.TEXT_NODE ? secondNode.textContent || "" : "";
        const hasColon = /[：:]$/.test(firstText) || /^\s*[：:]/.test(secondText);
        if (!hasColon)
          return;
        const wrapper = document.createElement("span");
        const liStyle = li.getAttribute("style") || "";
        const lineHeightMatch = liStyle.match(/line-height:\s*[^;]+/i);
        const lineHeight = lineHeightMatch ? `${lineHeightMatch[0]};` : "";
        wrapper.setAttribute("style", `display:block;margin:0;padding:0;${lineHeight}`);
        while (li.firstChild) {
          wrapper.appendChild(li.firstChild);
        }
        li.appendChild(wrapper);
      };
      const mergeLabelParagraphs = (li) => {
        const directParagraphs = Array.from(li.children).filter((child) => child.tagName === "P");
        if (directParagraphs.length < 2)
          return;
        if (!hasInlineLabelPrefix(directParagraphs[0]))
          return;
        if (!isInlineOnlyParagraph(directParagraphs[0]) || !isInlineOnlyParagraph(directParagraphs[1]))
          return;
        const first = directParagraphs[0];
        const second = directParagraphs[1];
        if (!second.textContent || !second.textContent.trim())
          return;
        while (second.firstChild && second.firstChild.nodeType === Node.TEXT_NODE && !second.firstChild.textContent.trim()) {
          second.removeChild(second.firstChild);
        }
        if (first.lastChild && first.lastChild.nodeType === Node.TEXT_NODE) {
          first.lastChild.textContent = first.lastChild.textContent.replace(/\s*$/, " ");
        } else {
          first.appendChild(document.createTextNode(" "));
        }
        while (second.firstChild) {
          first.appendChild(second.firstChild);
        }
        second.remove();
      };
      div.querySelectorAll("li").forEach((li) => {
        const directParagraphs = Array.from(li.children).filter((child) => child.tagName === "P");
        directParagraphs.forEach((paragraph) => collapseLabelBreakInParagraph(paragraph));
        mergeLabelParagraphs(li);
        unwrapSimpleListParagraphs(li);
        collapseLabelBreakInListItem(li);
        convertLeadingStrongOrCodeToSpan(li);
        wrapLeadingLabelInBlockSpan(li);
        const hasNestedList = li.querySelector("ul, ol");
        if (!hasNestedList)
          return;
        Array.from(li.children).forEach((child) => {
          if (child.tagName === "P") {
            while (child.firstChild) {
              li.insertBefore(child.firstChild, child);
            }
            child.remove();
          }
        });
        const firstList = Array.from(li.children).find((child) => child.tagName === "UL" || child.tagName === "OL");
        if (!firstList)
          return;
        const nodesBeforeList = [];
        for (let node = li.firstChild; node && node !== firstList; node = node.nextSibling) {
          nodesBeforeList.push(node);
        }
        const meaningfulNodes = nodesBeforeList.filter(
          (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
        );
        if (meaningfulNodes.length === 0)
          return;
        const blockTags = /* @__PURE__ */ new Set(["UL", "OL", "TABLE", "PRE", "BLOCKQUOTE", "SECTION", "FIGURE", "DIV"]);
        const hasBlock = meaningfulNodes.some(
          (node) => node.nodeType === Node.ELEMENT_NODE && blockTags.has(node.tagName)
        );
        if (hasBlock)
          return;
        const wrapper = document.createElement("span");
        const liStyle = li.getAttribute("style") || "";
        const lineHeightMatch = liStyle.match(/line-height:\s*[^;]+/i);
        const lineHeight = lineHeightMatch ? `${lineHeightMatch[0]};` : "";
        wrapper.setAttribute("style", `display:block;margin:0;padding:0;${lineHeight}`);
        meaningfulNodes.forEach((node) => wrapper.appendChild(node));
        li.insertBefore(wrapper, firstList);
      });
      const getListDepth = (list) => {
        let depth = 0;
        let current = list.parentElement;
        while (current) {
          if (current.tagName === "UL" || current.tagName === "OL")
            depth += 1;
          current = current.parentElement;
        }
        return depth;
      };
      const buildPseudoItems = (list, depth) => {
        const fragment = document.createDocumentFragment();
        const isOrdered = list.tagName === "OL";
        let index = 1;
        Array.from(list.children).forEach((li) => {
          if (li.tagName !== "LI")
            return;
          const nestedLists = Array.from(li.children).filter(
            (child) => child.tagName === "UL" || child.tagName === "OL"
          );
          const liStyle = li.getAttribute("style") || "";
          const indent = Math.max(0, depth - 1) * 20;
          const wrapper = document.createElement("p");
          wrapper.setAttribute(
            "style",
            `${liStyle} margin:0 0 4px ${indent}px; padding:0;`
          );
          const contentNodes = [];
          Array.from(li.childNodes).forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE && (node.tagName === "UL" || node.tagName === "OL"))
              return;
            if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "P") {
              const children = Array.from(node.childNodes);
              if (children.length && contentNodes.length) {
                contentNodes.push(document.createTextNode(" "));
              }
              children.forEach((child) => contentNodes.push(child));
              return;
            }
            contentNodes.push(node);
          });
          while (contentNodes.length > 0 && contentNodes[0].nodeType === Node.TEXT_NODE && !contentNodes[0].textContent.trim()) {
            contentNodes.shift();
          }
          if (contentNodes.length > 0 && contentNodes[0].nodeType === Node.TEXT_NODE) {
            contentNodes[0].textContent = contentNodes[0].textContent.replace(/^\s+/, "");
            if (!contentNodes[0].textContent) {
              contentNodes.shift();
            }
          }
          const hasContent = contentNodes.some((node) => {
            if (node.nodeType === Node.TEXT_NODE)
              return node.textContent.trim();
            return true;
          });
          if (hasContent) {
            contentNodes.forEach((node) => {
              if (node.nodeType !== Node.TEXT_NODE)
                return;
              node.textContent = node.textContent.replace(/\s*\n\s*/g, " ").replace(/\s{2,}/g, " ");
              if (!node.textContent.trim()) {
                node.remove();
              }
            });
            const markerText = isOrdered ? `${index}. ` : "\u2022 ";
            const firstText = contentNodes.find((node) => node.nodeType === Node.TEXT_NODE && node.textContent.trim());
            if (firstText) {
              firstText.textContent = markerText + firstText.textContent;
            } else {
              contentNodes.unshift(document.createTextNode(markerText));
            }
            contentNodes.forEach((node) => wrapper.appendChild(node));
            fragment.appendChild(wrapper);
          }
          nestedLists.forEach((nested) => {
            fragment.appendChild(buildPseudoItems(nested, depth + 1));
          });
          index += 1;
        });
        return fragment;
      };
      Array.from(div.querySelectorAll("ul, ol")).forEach((list) => {
        if (!div.contains(list))
          return;
        const depth = getListDepth(list);
        if (depth < 2)
          return;
        const fragment = buildPseudoItems(list, depth);
        list.parentNode.insertBefore(fragment, list);
        list.remove();
      });
      div.querySelectorAll("li > ul, li > ol").forEach((nestedList) => {
        let style = nestedList.getAttribute("style") || "";
        style = style.replace(/margin(-[a-z]+)?:\s*[^;]+;?/gi, "");
        style = "margin: 0; " + style;
        nestedList.setAttribute("style", style);
      });
      div.querySelectorAll("li").forEach((li) => {
        if (!li.textContent.trim() && li.querySelectorAll("img, ul, ol").length === 0) {
          li.remove();
        }
      });
      div.querySelectorAll("ul, ol").forEach((list) => {
        Array.from(list.childNodes).forEach((node) => {
          if (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) {
            node.remove();
          }
        });
      });
      div.querySelectorAll("li").forEach((li) => {
        Array.from(li.childNodes).forEach((node) => {
          if (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) {
            node.remove();
          }
        });
      });
      const forceInlineStyle = (el, extraStyle = "") => {
        const currentStyle = el.getAttribute("style") || "";
        const cleanedStyle = currentStyle.replace(/display\s*:\s*[^;]+;?/gi, "").replace(/width\s*:\s*[^;]+;?/gi, "").replace(/float\s*:\s*[^;]+;?/gi, "").trim();
        const normalizedStyle = cleanedStyle ? `${cleanedStyle}${cleanedStyle.endsWith(";") ? "" : ";"}` : "";
        const finalStyle = `${normalizedStyle}display:inline !important; width:auto !important; float:none !important;${extraStyle}`;
        el.setAttribute("style", finalStyle);
      };
      div.querySelectorAll("li strong").forEach((strong) => {
        forceInlineStyle(strong);
      });
      div.querySelectorAll("li code").forEach((code) => {
        if (code.closest("pre, .code-block, .code-block-code"))
          return;
        forceInlineStyle(code, " margin:0 2px !important; vertical-align:baseline;");
      });
      return div.innerHTML;
    }
    module2.exports = {
      cleanHtmlForDraft
    };
  }
});

// input.js
var { Plugin, MarkdownView, ItemView, Notice } = require("obsidian");
var { PluginSettingTab, Setting } = require("obsidian");
var { createRenderPipelines } = require_render_pipeline();
var { buildRenderRuntime } = require_dependency_loader();
var { resolveMarkdownSource } = require_markdown_source();
var { normalizeVaultPath, isAbsolutePathLike } = require_path_utils();
var { renderObsidianTripletMarkdown } = require_obsidian_triplet_renderer();
var { createWechatSyncService } = require_wechat_sync();
var { resolveSyncAccount, toSyncFriendlyMessage } = require_sync_context();
var { processAllImages: processAllImagesService, processMathFormulas: processMathFormulasService } = require_wechat_media();
var { cleanHtmlForDraft: cleanHtmlForDraftService } = require_wechat_html_cleaner();
var TRIPLET_PARITY_DEBUG_REV = "triplet-parity-r6";
var APPLE_STYLE_VIEW = "apple-style-converter";
var DEFAULT_SETTINGS = {
  theme: "github",
  themeColor: "blue",
  customColor: "#0366d6",
  fontFamily: "sans-serif",
  fontSize: 3,
  macCodeBlock: true,
  codeLineNumber: true,
  avatarUrl: "",
  avatarBase64: "",
  // Base64 编码的本地头像，优先级高于 avatarUrl
  enableWatermark: false,
  showImageCaption: true,
  // 关闭水印时是否显示图片说明文字
  // 多账号支持
  wechatAccounts: [],
  // [{ id, name, appId, appSecret }]
  defaultAccountId: "",
  // 代理设置
  proxyUrl: "",
  // Cloudflare Worker 等代理地址
  // 预览设置
  usePhoneFrame: true,
  // 是否使用手机框预览
  // 三件套渲染开关
  useTripletPipeline: false,
  tripletFallbackToPhase2: true,
  enforceTripletParity: true,
  // 严格零差异门禁
  tripletParityVerboseLog: false,
  // 输出完整差异 payload 到控制台（调试用）
  // 旧字段保留用于迁移检测
  useNativePipeline: false,
  enableLegacyFallback: true,
  enforceNativeParity: true,
  // 排版设置
  sidePadding: 16,
  // 页面两侧留白 (px)
  coloredHeader: false,
  // 标题是否使用主题色
  // 同步后清理资源（默认关闭，避免破坏性行为）
  cleanupAfterSync: false,
  cleanupUseSystemTrash: true,
  cleanupDirTemplate: "",
  // 发送成功后要清理的目录（支持 {{note}}）
  // 旧字段保留用于迁移检测
  wechatAppId: "",
  wechatAppSecret: ""
};
var MAX_ACCOUNTS = 5;
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
async function pMap(array, mapper, concurrency = 3) {
  const results = [];
  const executing = [];
  let isFailed = false;
  for (const item of array) {
    if (isFailed)
      break;
    const p = Promise.resolve().then(() => mapper(item));
    results.push(p);
    const e = p.catch(() => {
      isFailed = true;
    }).then(() => executing.splice(executing.indexOf(e), 1));
    executing.push(e);
    if (executing.length >= concurrency) {
      await Promise.race(executing);
    }
  }
  return Promise.all(results);
}
var WechatAPI = class {
  constructor(appId, appSecret, proxyUrl = "") {
    this.appId = appId;
    this.appSecret = appSecret;
    this.proxyUrl = proxyUrl;
    this.accessToken = "";
    this.expireTime = 0;
  }
  /**
   * 通用重试机制 (仅处理网络层面的不稳定性)
   * 不再处理 Token 逻辑，专注于网络波动和配置错误
   */
  async requestWithRetry(operation, maxRetries = 3) {
    let lastError;
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (error.isFatal)
          throw error;
        const isConfigError = error.message && (error.message.includes("(40013)") || // invalid appid
        error.message.includes("(40125)") || // invalid appsecret
        error.message.includes("invalid appid"));
        if (isConfigError) {
          console.warn(`[WechatAPI] Configuration error detected, aborting retry: ${error.message}`);
          throw error;
        }
        if (error.message && (error.message.includes("45009") || error.message.includes("reach max api daily quota limit"))) {
          const fatalError = new Error("\u5FAE\u4FE1\u63A5\u53E3\u4ECA\u65E5\u989D\u5EA6\u5DF2\u7528\u5B8C (45009)\uFF0C\u8BF7\u660E\u5929\u518D\u8BD5\u6216\u5207\u6362\u8D26\u53F7\u3002");
          fatalError.isFatal = true;
          throw fatalError;
        }
        if (error.message && (error.message.includes("45001") || error.message.includes("media size out of limit"))) {
          const fatalError = new Error("\u5FAE\u4FE1\u540E\u53F0\u7D20\u6750\u5E93\u5DF2\u6EE1 (45001)\u3002\u8BF7\u767B\u5F55\u5FAE\u4FE1\u516C\u4F17\u5E73\u53F0 -> \u7D20\u6750\u7BA1\u7406\uFF0C\u624B\u52A8\u5220\u9664\u65E7\u56FE\u7247\u4EE5\u91CA\u653E\u7A7A\u95F4\u3002");
          fatalError.isFatal = true;
          throw fatalError;
        }
        const isTokenError = error.message && (error.message.includes("40001") || error.message.includes("42001") || error.message.includes("40014"));
        if (isTokenError) {
          throw error;
        }
        const isBusinessError = error.message && error.message.includes("\u5FAE\u4FE1API\u62A5\u9519") && !error.message.includes("(-1)");
        if (isBusinessError) {
          console.warn(`[WechatAPI] Business logic error detected, aborting retry: ${error.message}`);
          throw error;
        }
        console.warn(`[WechatAPI] Network request failed (attempt ${i + 1}/${maxRetries}): ${error.message}`);
        if (i < maxRetries - 1) {
          await sleep(1e3 * (i + 1));
        }
      }
    }
    throw lastError;
  }
  /**
   * 高阶函数：执行带 Token 生命周期管理的操作
   * 负责：获取 Token -> 执行操作 -> 捕获 Token 过期错误 -> 刷新 Token -> 重试
   * @param {Function} action - 接收 token 参数的异步函数
   */
  async actionWithTokenRetry(action) {
    let retryCount = 0;
    const maxRetries = 1;
    while (true) {
      try {
        const token = await this.getAccessToken();
        return await action(token);
      } catch (error) {
        const isTokenExpired = error.message && (error.message.includes("40001") || error.message.includes("42001") || error.message.includes("40014"));
        if (isTokenExpired && retryCount < maxRetries) {
          console.warn(`[WechatAPI] Token expired (${error.message}), refreshing and retrying...`);
          this.accessToken = "";
          retryCount++;
          continue;
        }
        throw error;
      }
    }
  }
  /**
   * 验证代理 URL 安全性 (必须使用 HTTPS)
   */
  validateProxyUrl(proxyUrl) {
    if (proxyUrl && !proxyUrl.toLowerCase().startsWith("https://")) {
      const error = new Error("Security Error: Insecure HTTP proxy blocked. Proxy URL must use HTTPS.");
      error.isFatal = true;
      throw error;
    }
  }
  /**
   * 发送请求（如果配置了代理，通过代理发送）
   * 纯粹的 HTTP 请求封装，不包含重试逻辑
   */
  async sendRequest(url, options = {}) {
    const { requestUrl } = require("obsidian");
    if (this.proxyUrl) {
      this.validateProxyUrl(this.proxyUrl);
      const proxyResponse = await requestUrl({
        url: this.proxyUrl,
        method: "POST",
        body: JSON.stringify({
          url,
          method: options.method || "GET",
          data: options.body ? JSON.parse(options.body) : void 0
        }),
        contentType: "application/json"
      });
      return proxyResponse.json;
    } else {
      const response = await requestUrl({ url, ...options });
      return response.json;
    }
  }
  async getAccessToken() {
    if (this.accessToken && Date.now() < this.expireTime - 3e5) {
      return this.accessToken;
    }
    const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${this.appId}&secret=${this.appSecret}`;
    const data = await this.requestWithRetry(() => this.sendRequest(url));
    if (data.access_token) {
      this.accessToken = data.access_token;
      this.expireTime = Date.now() + data.expires_in * 1e3;
      return this.accessToken;
    } else {
      throw new Error(`\u83B7\u53D6 Token \u5931\u8D25: ${data.errmsg || "\u672A\u77E5\u9519\u8BEF"} (${data.errcode || "??"})`);
    }
  }
  async uploadCover(blob) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=${token}&type=image`;
      return await this.uploadMultipart(url, blob, "media");
    });
  }
  async uploadImage(blob) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=${token}`;
      return await this.uploadMultipart(url, blob, "media");
    });
  }
  async createDraft(article) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/draft/add?access_token=${token}`;
      const data = await this.sendRequest(url, {
        method: "POST",
        body: JSON.stringify({ articles: [article] })
      });
      if (data.media_id) {
        return data;
      }
      throw new Error(`\u521B\u5EFA\u8349\u7A3F\u5931\u8D25: ${data.errmsg || JSON.stringify(data)} (${data.errcode || "N/A"})`);
    });
  }
  async uploadMultipart(url, blob, fieldName) {
    return this.requestWithRetry(async () => {
      const { requestUrl } = require("obsidian");
      const mimeType = blob.type || "image/jpeg";
      const ext = mimeType.includes("gif") ? "gif" : mimeType.includes("png") ? "png" : "jpg";
      if (this.proxyUrl) {
        this.validateProxyUrl(this.proxyUrl);
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        const base64Data = await new Promise((resolve, reject) => {
          reader.onload = () => resolve(reader.result.split(",")[1]);
          reader.onerror = reject;
        });
        const proxyResponse = await requestUrl({
          url: this.proxyUrl,
          method: "POST",
          body: JSON.stringify({
            url,
            method: "UPLOAD",
            // 特殊标记，告诉代理这是文件上传
            fileData: base64Data,
            fileName: `image.${ext}`,
            mimeType,
            fieldName
          }),
          contentType: "application/json"
        });
        const data = proxyResponse.json;
        if (data.media_id || data.url) {
          return data;
        } else {
          throw new Error(`\u5FAE\u4FE1API\u62A5\u9519: ${data.errmsg} (${data.errcode})`);
        }
      } else {
        const boundary = "----ObsidianWechatConverterBoundary" + Math.random().toString(36).substring(2);
        const arrayBuffer = await blob.arrayBuffer();
        const bytes = new Uint8Array(arrayBuffer);
        let header = `--${boundary}\r
`;
        header += `Content-Disposition: form-data; name="${fieldName}"; filename="image.${ext}"\r
`;
        header += `Content-Type: ${mimeType}\r
\r
`;
        const footer = `\r
--${boundary}--\r
`;
        const headerBytes = new TextEncoder().encode(header);
        const footerBytes = new TextEncoder().encode(footer);
        const bodyBytes = new Uint8Array(headerBytes.length + bytes.length + footerBytes.length);
        bodyBytes.set(headerBytes, 0);
        bodyBytes.set(bytes, headerBytes.length);
        bodyBytes.set(footerBytes, headerBytes.length + bytes.length);
        try {
          const response = await requestUrl({
            url,
            method: "POST",
            body: bodyBytes.buffer,
            headers: {
              "Content-Type": `multipart/form-data; boundary=${boundary}`
            }
          });
          const data = response.json;
          if (data.media_id || data.url) {
            return data;
          } else {
            throw new Error(`\u5FAE\u4FE1API\u62A5\u9519: ${data.errmsg} (${data.errcode})`);
          }
        } catch (error) {
          console.error("Upload Error:", error);
          throw new Error(`\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25: ${error.message}`);
        }
      }
    });
  }
};
var AppleStyleView = class extends ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.currentHtml = null;
    this.converter = null;
    this.legacyRenderPipeline = null;
    this.nativeRenderPipeline = null;
    this.theme = null;
    this.lastActiveFile = null;
    this.sessionCoverBase64 = "";
    this.sessionDigest = "";
    this.articleStates = /* @__PURE__ */ new Map();
    this.svgUploadCache = /* @__PURE__ */ new Map();
    this.imageUploadCache = /* @__PURE__ */ new Map();
    this.renderGeneration = 0;
    this.lastParityMismatchNoticeKey = "";
  }
  getViewType() {
    return APPLE_STYLE_VIEW;
  }
  getDisplayText() {
    return "\u{1F4DD} \u5FAE\u4FE1\u6392\u7248\u8F6C\u6362";
  }
  getIcon() {
    return "wand";
  }
  async onOpen() {
    console.log("\u{1F34E} \u8F6C\u6362\u5668\u9762\u677F\u6253\u5F00");
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("apple-converter-container");
    await this.loadDependencies();
    this.createSettingsPanel(container);
    const previewWrapper = container.createEl("div", {
      cls: `apple-preview-wrapper ${this.plugin.settings.usePhoneFrame ? "mode-phone" : "mode-classic"}`
    });
    previewWrapper.addEventListener("click", (e) => {
      if (this.settingsOverlay && this.settingsOverlay.classList.contains("visible")) {
        this.settingsOverlay.classList.remove("visible");
        const btn = container.querySelector('.apple-icon-btn[aria-label="\u6837\u5F0F\u8BBE\u7F6E"]');
        if (btn)
          btn.classList.remove("active");
      }
    });
    if (this.plugin.settings.usePhoneFrame) {
      const phoneFrame = previewWrapper.createEl("div", { cls: "apple-phone-frame" });
      const header = phoneFrame.createEl("div", { cls: "apple-phone-header" });
      header.createEl("span", { cls: "title", text: "\u516C\u4F17\u53F7\u9884\u89C8" });
      header.createEl("span", { cls: "dots", text: "\u2022\u2022\u2022" });
      this.previewContainer = phoneFrame.createEl("div", {
        cls: "apple-converter-preview"
      });
      phoneFrame.createEl("div", { cls: "apple-home-indicator" });
    } else {
      this.previewContainer = previewWrapper.createEl("div", {
        cls: "apple-converter-preview"
      });
    }
    this.setPlaceholder();
    this.registerActiveFileChange();
    const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (activeView)
      this.registerScrollSync(activeView);
    setTimeout(async () => {
      const activeView2 = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (activeView2 && this.converter) {
        await this.convertCurrent(true);
      }
    }, 500);
  }
  /**
   * 监听活动文件切换
   */
  registerActiveFileChange() {
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", async () => {
        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (activeView && activeView.file) {
          this.lastActiveFile = activeView.file;
        }
        this.updateCurrentDoc();
        if (activeView) {
          this.registerScrollSync(activeView);
        }
        if (activeView && this.converter) {
          setTimeout(async () => {
            await this.convertCurrent(true);
          }, 300);
        }
      })
    );
    const debounce = (func, wait) => {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    };
    const debouncedConvert = debounce(async () => {
      if (!this.containerEl.offsetParent)
        return;
      const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (activeView && activeView.file && this.lastActiveFile && activeView.file.path === this.lastActiveFile.path) {
        await this.convertCurrent(true);
      }
    }, 500);
    this.registerEvent(
      this.app.workspace.on("editor-change", debouncedConvert)
    );
  }
  /**
   * 注册同步滚动 (双向: Editor <-> Preview)
   * 采用"原子锁"机制 + "差值检测"机制，彻底解决死循环和精度问题
   */
  registerScrollSync(activeView) {
    if (this.activeEditorScroller && this.editorScrollListener) {
      this.activeEditorScroller.removeEventListener("scroll", this.editorScrollListener);
    }
    if (this.previewContainer && this.previewScrollListener) {
      this.previewContainer.removeEventListener("scroll", this.previewScrollListener);
    }
    this.activeEditorScroller = null;
    this.editorScrollListener = null;
    this.previewScrollListener = null;
    this.ignoreNextPreviewScroll = false;
    this.ignoreNextEditorScroll = false;
    if (!activeView)
      return;
    const editorScroller = activeView.contentEl.querySelector(".cm-scroller");
    if (!editorScroller)
      return;
    this.activeEditorScroller = editorScroller;
    this.editorScrollListener = () => {
      if (!this.containerEl.offsetParent)
        return;
      if (this.ignoreNextEditorScroll) {
        this.ignoreNextEditorScroll = false;
        return;
      }
      if (!this.previewContainer)
        return;
      const editorHeight = editorScroller.scrollHeight - editorScroller.clientHeight;
      const previewHeight = this.previewContainer.scrollHeight - this.previewContainer.clientHeight;
      if (editorHeight <= 0 || previewHeight <= 0)
        return;
      let targetScrollTop;
      if (editorScroller.scrollTop === 0) {
        targetScrollTop = 0;
      } else if (Math.abs(editorScroller.scrollTop - editorHeight) < 2) {
        targetScrollTop = previewHeight;
      } else {
        const ratio = editorScroller.scrollTop / editorHeight;
        targetScrollTop = ratio * previewHeight;
      }
      if (Math.abs(this.previewContainer.scrollTop - targetScrollTop) > 1) {
        this.ignoreNextPreviewScroll = true;
        this.previewContainer.scrollTop = targetScrollTop;
      }
    };
    this.previewScrollListener = () => {
      if (!this.containerEl.offsetParent)
        return;
      if (this.ignoreNextPreviewScroll) {
        this.ignoreNextPreviewScroll = false;
        return;
      }
      const editorHeight = editorScroller.scrollHeight - editorScroller.clientHeight;
      const previewHeight = this.previewContainer.scrollHeight - this.previewContainer.clientHeight;
      if (editorHeight <= 0 || previewHeight <= 0)
        return;
      let targetScrollTop;
      if (this.previewContainer.scrollTop === 0) {
        targetScrollTop = 0;
      } else if (Math.abs(this.previewContainer.scrollTop - previewHeight) < 2) {
        targetScrollTop = editorHeight;
      } else {
        const ratio = this.previewContainer.scrollTop / previewHeight;
        targetScrollTop = ratio * editorHeight;
      }
      if (Math.abs(editorScroller.scrollTop - targetScrollTop) > 1) {
        this.ignoreNextEditorScroll = true;
        editorScroller.scrollTop = targetScrollTop;
      }
    };
    editorScroller.addEventListener("scroll", this.editorScrollListener, { passive: true });
    this.previewContainer.addEventListener("scroll", this.previewScrollListener, { passive: true });
  }
  /**
   * 加载依赖库
   */
  async loadDependencies() {
    const adapter = this.app.vault.adapter;
    const basePath = this.plugin.manifest.dir;
    try {
      const runtime = await buildRenderRuntime({
        settings: this.plugin.settings,
        app: this.app,
        adapter,
        basePath
      });
      this.theme = runtime.theme;
      this.converter = runtime.converter;
      const { legacyPipeline, nativePipeline } = createRenderPipelines({
        converter: this.converter,
        getFlags: () => this.getRenderPipelineFlags(),
        candidateRenderer: async (markdown, context = {}) => {
          return renderObsidianTripletMarkdown({
            app: this.app,
            converter: this.converter,
            markdown,
            sourcePath: context.sourcePath || "",
            component: this
          });
        }
      });
      this.legacyRenderPipeline = legacyPipeline;
      this.nativeRenderPipeline = nativePipeline;
      console.log("\u2705 \u4F9D\u8D56\u52A0\u8F7D\u5B8C\u6210");
    } catch (error) {
      console.error("\u274C \u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25:", error);
      new Notice("\u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 创建设置面板（重构为：顶部工具栏 + 悬浮设置层）
   */
  createSettingsPanel(container) {
    const { setIcon } = require("obsidian");
    const toolbar = container.createEl("div", { cls: "apple-top-toolbar" });
    this.currentDocLabel = toolbar.createEl("div", { cls: "apple-toolbar-title" });
    this.currentDocLabel.createDiv({ text: "\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668", cls: "apple-toolbar-plugin-name" });
    this.docTitleText = this.currentDocLabel.createDiv({ text: "\u672A\u9009\u62E9\u6587\u6863", cls: "apple-toolbar-doc-name" });
    const actions = toolbar.createEl("div", { cls: "apple-toolbar-actions" });
    const createIconBtn = (icon, title, onClick) => {
      const btn = actions.createEl("div", {
        cls: "apple-icon-btn",
        attr: { "aria-label": title }
        // Tooltip
      });
      setIcon(btn, icon);
      btn.addEventListener("click", onClick);
      return btn;
    };
    const settingsBtn = createIconBtn("sliders-horizontal", "\u6837\u5F0F\u8BBE\u7F6E", () => {
      this.settingsOverlay.classList.toggle("visible");
      settingsBtn.classList.toggle("active");
    });
    this.copyBtn = createIconBtn("copy", "\u590D\u5236\u5230\u516C\u4F17\u53F7", () => this.copyHTML());
    const accounts = this.plugin.settings.wechatAccounts || [];
    if (accounts.length > 0) {
      createIconBtn("send", "\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1", () => this.showSyncModal());
    }
    this.settingsOverlay = container.createEl("div", { cls: "apple-settings-overlay" });
    const settingsArea = this.settingsOverlay.createEl("div", { cls: "apple-settings-area" });
    this.createSection(settingsArea, "\u4E3B\u9898", (section) => {
      const grid = section.createEl("div", { cls: "apple-btn-grid" });
      const themes = AppleTheme.getThemeList();
      themes.forEach((t) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-theme ${this.plugin.settings.theme === t.value ? "active" : ""}`,
          text: t.label
        });
        btn.dataset.value = t.value;
        btn.addEventListener("click", () => this.onThemeChange(t.value, grid));
      });
    });
    this.createSection(settingsArea, "\u5B57\u4F53", (section) => {
      const select = section.createEl("select", { cls: "apple-select" });
      [
        { value: "sans-serif", label: "\u65E0\u886C\u7EBF" },
        { value: "serif", label: "\u886C\u7EBF" },
        { value: "monospace", label: "\u7B49\u5BBD" }
      ].forEach((opt) => {
        const option = select.createEl("option", { value: opt.value, text: opt.label });
        if (this.plugin.settings.fontFamily === opt.value)
          option.selected = true;
      });
      select.addEventListener("change", (e) => this.onFontFamilyChange(e.target.value));
    });
    this.createSection(settingsArea, "\u5B57\u53F7", (section) => {
      const grid = section.createEl("div", { cls: "apple-btn-row" });
      const sizeOpts = [
        { value: 1, label: "\u5C0F" },
        { value: 2, label: "\u8F83\u5C0F" },
        { value: 3, label: "\u63A8\u8350" },
        { value: 4, label: "\u8F83\u5927" },
        { value: 5, label: "\u5927" }
      ];
      sizeOpts.forEach((s) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-size ${this.plugin.settings.fontSize === s.value ? "active" : ""}`,
          text: s.label
        });
        btn.dataset.value = s.value;
        btn.addEventListener("click", () => this.onFontSizeChange(s.value, grid));
      });
    });
    this.createSection(settingsArea, "\u4E3B\u9898\u8272", (section) => {
      const grid = section.createEl("div", { cls: "apple-color-grid" });
      const colors = AppleTheme.getColorList();
      colors.forEach((c) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-color ${this.plugin.settings.themeColor === c.value ? "active" : ""}`
        });
        btn.dataset.value = c.value;
        btn.style.setProperty("--btn-color", c.color);
        btn.addEventListener("click", () => this.onColorChange(c.value, grid));
      });
      const customBtn = grid.createEl("button", {
        cls: `apple-btn-custom-text ${this.plugin.settings.themeColor === "custom" ? "active" : ""}`,
        text: "\u81EA\u5B9A\u4E49",
        title: "\u81EA\u5B9A\u4E49\u989C\u8272"
      });
      customBtn.dataset.value = "custom";
      const colorInput = grid.createEl("input", {
        type: "color",
        cls: "apple-color-picker-hidden"
      });
      colorInput.value = this.plugin.settings.customColor || "#000000";
      colorInput.style.visibility = "hidden";
      colorInput.style.width = "0";
      colorInput.style.height = "0";
      colorInput.style.position = "absolute";
      customBtn.addEventListener("click", () => {
        colorInput.click();
      });
      colorInput.addEventListener("input", (e) => {
        customBtn.style.setProperty("--btn-color", e.target.value);
      });
      colorInput.addEventListener("change", async (e) => {
        const newColor = e.target.value;
        customBtn.style.setProperty("--btn-color", newColor);
        this.plugin.settings.customColor = newColor;
        this.theme.update({ customColor: newColor });
        await this.onColorChange("custom", grid);
      });
    });
    this.createSection(settingsArea, "\u6807\u9898\u6837\u5F0F", (section) => {
      section.style.display = "flex";
      section.style.alignItems = "center";
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.coloredHeader;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      section.createEl("span", {
        text: "\u6807\u9898\u4F7F\u7528\u52A0\u6DF1\u4E3B\u9898\u8272",
        attr: {
          style: "font-size: 11px; color: var(--apple-secondary); margin-left: 12px; opacity: 0.8; font-weight: 500; transform: translateY(-1px);"
        }
      });
      checkbox.addEventListener("change", async () => {
        this.plugin.settings.coloredHeader = checkbox.checked;
        await this.plugin.saveSettings();
        this.theme.update({ coloredHeader: checkbox.checked });
        await this.convertCurrent(true);
      });
    });
    this.createSection(settingsArea, "Mac \u98CE\u683C\u4EE3\u7801\u5757", (section) => {
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.macCodeBlock;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      checkbox.addEventListener("change", () => this.onMacCodeBlockChange(checkbox.checked));
    });
    this.createSection(settingsArea, "\u663E\u793A\u4EE3\u7801\u884C\u53F7", (section) => {
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.codeLineNumber;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      checkbox.addEventListener("change", () => this.onCodeLineNumberChange(checkbox.checked));
    });
    this.createSection(settingsArea, "\u9875\u9762\u4E24\u4FA7\u7559\u767D", (section) => {
      const container2 = section.createEl("div", {
        cls: "apple-slider-container",
        style: "width: 100%; display: flex; align-items: center; gap: 10px;"
      });
      const slider = container2.createEl("input", {
        type: "range",
        cls: "apple-slider",
        attr: { min: 0, max: 40, step: 1 }
      });
      slider.value = this.plugin.settings.sidePadding;
      slider.style.flex = "1";
      const valueLabel = container2.createEl("span", {
        text: `${this.plugin.settings.sidePadding}px`,
        style: "font-size: 12px; color: var(--apple-secondary); min-width: 32px; text-align: right;"
      });
      slider.addEventListener("input", async (e) => {
        const val = parseInt(e.target.value);
        valueLabel.setText(`${val}px`);
        this.plugin.settings.sidePadding = val;
        this.theme.update({ sidePadding: val });
        if (this.saveTimeout)
          clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(async () => {
          await this.plugin.saveSettings();
        }, 500);
        await this.convertCurrent(true);
      });
    });
    const captionSetting = new Setting(settingsArea).setName("\u663E\u793A\u56FE\u7247\u8BF4\u660E\u6587\u5B57").setDesc("\u5173\u95ED\u6C34\u5370\u65F6\uFF0C\u5728\u56FE\u7247\u4E0B\u65B9\u663E\u793A\u8BF4\u660E\u6587\u5B57").addToggle((toggle) => toggle.setValue(this.plugin.settings.showImageCaption).onChange(async (value) => {
      this.plugin.settings.showImageCaption = value;
      await this.plugin.saveSettings();
      if (this.converter) {
        this.converter.updateConfig({ showImageCaption: value });
        await this.convertCurrent(true);
      }
    }));
    if (this.plugin.settings.enableWatermark) {
      captionSetting.setDesc("\u56E0\u5168\u5C40\u8BBE\u7F6E\u4E2D\u5DF2\u5F00\u542F\u6C34\u5370\uFF0C\u6B64\u9009\u9879\u9ED8\u8BA4\u5F00\u542F");
      const toggleComp = captionSetting.components[0];
      toggleComp.setValue(true);
      toggleComp.setDisabled(true);
      if (toggleComp.toggleEl) {
        toggleComp.toggleEl.style.pointerEvents = "none";
        toggleComp.toggleEl.style.opacity = "0.6";
        toggleComp.toggleEl.style.filter = "grayscale(100%)";
      }
    }
  }
  /**
   * 创建账号选择器
   */
  createAccountSelector(parent) {
    const accounts = this.plugin.settings.wechatAccounts || [];
    if (accounts.length === 0)
      return;
    const section = parent.createEl("div", { cls: "apple-setting-section wechat-account-selector" });
    section.createEl("label", { cls: "apple-setting-label", text: "\u540C\u6B65\u8D26\u53F7" });
    const select = section.createEl("select", { cls: "wechat-account-select" });
    const defaultId = this.plugin.settings.defaultAccountId;
    for (const account of accounts) {
      const option = select.createEl("option", {
        value: account.id,
        text: account.id === defaultId ? `${account.name} (\u9ED8\u8BA4)` : account.name
      });
      if (account.id === defaultId) {
        option.selected = true;
      }
    }
    this.selectedAccountId = defaultId;
    select.addEventListener("change", (e) => {
      this.selectedAccountId = e.target.value;
    });
  }
  /**
   * 从文章内容中提取第一张图片作为封面
   */
  getFirstImageFromArticle() {
    if (!this.currentHtml)
      return null;
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.currentHtml;
    const imgs = Array.from(tempDiv.querySelectorAll("img"));
    for (const img of imgs) {
      if (img.alt === "logo")
        continue;
      if (img.src)
        return img.src;
    }
    return null;
  }
  /**
   * 获取当前发布上下文文件：
   * 1) 优先当前活动文件
   * 2) 回退到最近一次活动文件（侧边栏切换 tab 后常见）
   */
  getPublishContextFile() {
    var _a, _b, _c;
    const activeFile = (_c = (_b = (_a = this.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.getActiveFile) == null ? void 0 : _c.call(_b);
    if (activeFile)
      return activeFile;
    if (this.lastActiveFile)
      return this.lastActiveFile;
    return null;
  }
  /**
   * 读取当前文档 frontmatter 中的发布元数据
   * @returns {{ excerpt: string, cover: string, cover_dir: string, coverSrc: string|null }}
   */
  getFrontmatterPublishMeta(activeFile) {
    var _a;
    if (!activeFile) {
      return { excerpt: "", cover: "", cover_dir: "", coverSrc: null };
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter;
    const excerpt = this.getFrontmatterString(frontmatter, ["excerpt"]);
    const cover = this.getFrontmatterString(frontmatter, ["cover"]);
    const cover_dir = this.getFrontmatterString(frontmatter, ["cover_dir", "coverDir", "cover-dir", "coverdir", "CoverDIR"]);
    const coverSrc = cover ? this.resolveVaultPathToResourceSrc(cover) : null;
    return { excerpt, cover, cover_dir, coverSrc };
  }
  getFrontmatterString(frontmatter, keys) {
    if (!frontmatter || typeof frontmatter !== "object")
      return "";
    if (!Array.isArray(keys) || keys.length === 0)
      return "";
    const normalizedTargets = new Set(keys.map((key) => this.normalizeFrontmatterKey(key)));
    for (const key of keys) {
      const value = frontmatter[key];
      if (typeof value === "string" && value.trim())
        return value.trim();
    }
    for (const [key, value] of Object.entries(frontmatter)) {
      if (!normalizedTargets.has(this.normalizeFrontmatterKey(key)))
        continue;
      if (typeof value === "string" && value.trim())
        return value.trim();
    }
    return "";
  }
  normalizeFrontmatterKey(key) {
    return String(key || "").toLowerCase().replace(/[_-]/g, "");
  }
  getFrontmatterKeyMap(frontmatter, keys) {
    const result = {};
    if (!frontmatter || typeof frontmatter !== "object")
      return result;
    if (!Array.isArray(keys) || keys.length === 0)
      return result;
    const normalizedTargets = new Set(keys.map((key) => this.normalizeFrontmatterKey(key)));
    for (const [key, value] of Object.entries(frontmatter)) {
      if (!normalizedTargets.has(this.normalizeFrontmatterKey(key)))
        continue;
      if (typeof value !== "string")
        continue;
      const normalizedValue = this.normalizeVaultPath(value);
      if (!normalizedValue)
        continue;
      result[key] = normalizedValue;
    }
    return result;
  }
  isPathInsideDirectory(filePath, dirPath) {
    const file = this.normalizeVaultPath(filePath);
    const dir = this.normalizeVaultPath(dirPath);
    if (!file || !dir)
      return false;
    if (file === dir)
      return true;
    return file.startsWith(`${dir}/`);
  }
  isPathInsideDirectoryByTail(filePath, dirPath) {
    const file = this.normalizeVaultPath(filePath);
    const dir = this.normalizeVaultPath(dirPath);
    if (!file || !dir)
      return false;
    const dirSegments = dir.split("/").filter(Boolean);
    if (dirSegments.length < 2)
      return false;
    for (let i = 1; i <= dirSegments.length - 2; i++) {
      const tailDir = dirSegments.slice(i).join("/");
      if (this.isPathInsideDirectory(file, tailDir)) {
        return true;
      }
    }
    return false;
  }
  shouldClearFrontmatterPathAfterCleanup(pathValue, cleanedDir) {
    const normalized = this.normalizeVaultPath(pathValue);
    if (!normalized)
      return false;
    if (this.isPathInsideDirectory(normalized, cleanedDir))
      return true;
    return this.isPathInsideDirectoryByTail(normalized, cleanedDir);
  }
  async clearInvalidPublishMetaAfterCleanup(activeFile, cleanedDirPath) {
    if (!activeFile || !cleanedDirPath)
      return null;
    const cleanedDir = this.normalizeVaultPath(cleanedDirPath);
    if (!cleanedDir)
      return null;
    try {
      await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
        if (!frontmatter || typeof frontmatter !== "object")
          return;
        const coverMap = this.getFrontmatterKeyMap(frontmatter, ["cover"]);
        const coverDirMap = this.getFrontmatterKeyMap(frontmatter, ["cover_dir", "coverDir", "cover-dir", "coverdir", "CoverDIR"]);
        for (const [key, value] of Object.entries(coverMap)) {
          if (this.shouldClearFrontmatterPathAfterCleanup(value, cleanedDir)) {
            frontmatter[key] = "";
          }
        }
        for (const [key, value] of Object.entries(coverDirMap)) {
          if (this.shouldClearFrontmatterPathAfterCleanup(value, cleanedDir)) {
            frontmatter[key] = "";
          }
        }
      });
    } catch (error) {
      return `\u8D44\u6E90\u5DF2\u5220\u9664\uFF0C\u4F46\u6E05\u7406 frontmatter \u4E2D\u5931\u6548\u7684 cover/cover_dir \u5931\u8D25: ${error.message}`;
    }
    return null;
  }
  /**
   * 将 vault 相对路径解析为可预览/上传的资源 src（通常是 app://）
   */
  resolveVaultPathToResourceSrc(vaultPath) {
    if (typeof vaultPath !== "string")
      return null;
    const normalized = vaultPath.trim().replace(/\\/g, "/").replace(/^\/+/, "");
    if (!normalized)
      return null;
    try {
      const file = this.app.vault.getAbstractFileByPath(normalized);
      if (!file)
        return null;
      if (typeof file.extension !== "string")
        return null;
      return this.app.vault.getResourcePath(file);
    } catch (error) {
      return null;
    }
  }
  normalizeVaultPath(vaultPath) {
    return normalizeVaultPath(vaultPath);
  }
  getCleanupDirTemplate() {
    var _a, _b;
    const raw = typeof ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.cleanupDirTemplate) === "string" ? this.plugin.settings.cleanupDirTemplate : "";
    return this.normalizeVaultPath(raw);
  }
  resolveCleanupDirPath(activeFile) {
    const template = this.getCleanupDirTemplate();
    if (!template) {
      return { path: "", warning: "\u672A\u914D\u7F6E\u6E05\u7406\u76EE\u5F55\uFF0C\u8BF7\u5728\u63D2\u4EF6\u8BBE\u7F6E\u4E2D\u5148\u586B\u5199\u76EE\u5F55\u540E\u518D\u542F\u7528\u81EA\u52A8\u6E05\u7406" };
    }
    const hasNotePlaceholder = /\{\{\s*note\s*\}\}/i.test(template);
    if (hasNotePlaceholder && !activeFile) {
      return { path: "", warning: "\u5F53\u524D\u6CA1\u6709\u6D3B\u52A8\u6587\u6863\uFF0C\u65E0\u6CD5\u89E3\u6790\u6E05\u7406\u76EE\u5F55\u4E2D\u7684 {{note}}" };
    }
    const noteName = ((activeFile == null ? void 0 : activeFile.basename) || "").trim();
    const resolved = template.replace(/\{\{\s*note\s*\}\}/gi, noteName);
    const normalized = this.normalizeVaultPath(resolved);
    if (!normalized) {
      return { path: "", warning: "\u6E05\u7406\u76EE\u5F55\u4E3A\u7A7A\uFF0C\u8BF7\u68C0\u67E5\u8BBE\u7F6E\u503C" };
    }
    return { path: normalized };
  }
  /**
   * 清理目录安全校验：禁止空路径、上跳路径、系统配置目录等危险路径
   */
  isSafeCleanupDirPath(vaultPath) {
    const normalized = this.normalizeVaultPath(vaultPath);
    if (!normalized)
      return false;
    if (normalized === ".")
      return false;
    if (normalized.includes(".."))
      return false;
    if (normalized === ".obsidian" || normalized.startsWith(".obsidian/"))
      return false;
    return true;
  }
  /**
   * 在同步成功后按配置清理目录
   * 失败返回 warning，不抛错（避免影响同步成功状态）
   */
  async cleanupConfiguredDirectory(activeFile) {
    if (!this.plugin.settings.cleanupAfterSync) {
      return { attempted: false };
    }
    const useSystemTrash = this.plugin.settings.cleanupUseSystemTrash !== false;
    const resolved = this.resolveCleanupDirPath(activeFile);
    if (!resolved.path) {
      return { attempted: true, success: false, warning: resolved.warning || "\u672A\u89E3\u6790\u5230\u6E05\u7406\u76EE\u5F55" };
    }
    const normalized = resolved.path;
    if (!this.isSafeCleanupDirPath(normalized)) {
      return { attempted: true, success: false, warning: `\u6E05\u7406\u76EE\u5F55\u4E0D\u5B89\u5168\uFF0C\u5DF2\u8DF3\u8FC7: ${normalized}` };
    }
    const abstractFile = this.app.vault.getAbstractFileByPath(normalized);
    if (!abstractFile) {
      return { attempted: true, success: false, warning: `\u6E05\u7406\u76EE\u5F55\u4E0D\u5B58\u5728: ${normalized}` };
    }
    const isFile = typeof abstractFile.extension === "string";
    if (isFile) {
      return { attempted: true, success: false, warning: `\u6E05\u7406\u8DEF\u5F84\u4E0D\u662F\u76EE\u5F55\uFF0C\u5DF2\u8DF3\u8FC7: ${normalized}` };
    }
    try {
      if (typeof this.app.vault.trash === "function") {
        await this.app.vault.trash(abstractFile, useSystemTrash);
      } else if (typeof this.app.vault.delete === "function") {
        await this.app.vault.delete(abstractFile, true);
      } else {
        throw new Error("\u5F53\u524D Obsidian \u7248\u672C\u4E0D\u652F\u6301\u5220\u9664\u63A5\u53E3");
      }
    } catch (error) {
      return { attempted: true, success: false, warning: `\u5220\u9664\u5931\u8D25 (${normalized}): ${error.message}` };
    }
    const frontmatterWarning = await this.clearInvalidPublishMetaAfterCleanup(activeFile, normalized);
    if (frontmatterWarning) {
      return { attempted: true, success: true, cleanedPath: normalized, warning: frontmatterWarning };
    }
    return { attempted: true, success: true, cleanedPath: normalized };
  }
  /**
   * 创建设置区块
   */
  createSection(parent, label, builder) {
    const section = parent.createEl("div", { cls: "apple-setting-section" });
    section.createEl("label", { cls: "apple-setting-label", text: label });
    const content = section.createEl("div", { cls: "apple-setting-content" });
    builder(content);
  }
  /**
   * 显示同步选项 Modal
   */
  showSyncModal() {
    if (!this.currentHtml) {
      new Notice("\u26A0\uFE0F \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    const { Modal } = require("obsidian");
    const modal = new Modal(this.app);
    modal.titleEl.setText("\u540C\u6B65\u5230\u5FAE\u4FE1\u8349\u7A3F\u7BB1");
    modal.contentEl.addClass("wechat-sync-modal");
    const activeFile = this.getPublishContextFile();
    const currentPath = activeFile ? activeFile.path : null;
    const frontmatterMeta = this.getFrontmatterPublishMeta(activeFile);
    let cachedState = null;
    if (currentPath && this.articleStates.has(currentPath)) {
      cachedState = this.articleStates.get(currentPath);
    }
    const accounts = this.plugin.settings.wechatAccounts || [];
    const defaultId = this.plugin.settings.defaultAccountId;
    let selectedAccountId = defaultId;
    let coverBase64 = (cachedState == null ? void 0 : cachedState.coverBase64) || frontmatterMeta.coverSrc || this.getFirstImageFromArticle();
    this.sessionCoverBase64 = coverBase64;
    const accountSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    accountSection.createEl("label", { text: "\u8D26\u53F7", cls: "wechat-modal-label" });
    const accountSelect = accountSection.createEl("select", { cls: "wechat-account-select" });
    for (const account of accounts) {
      const option = accountSelect.createEl("option", {
        value: account.id,
        text: account.id === defaultId ? `${account.name} (\u9ED8\u8BA4)` : account.name
      });
      if (account.id === defaultId)
        option.selected = true;
    }
    accountSelect.addEventListener("change", (e) => {
      selectedAccountId = e.target.value;
    });
    const coverSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    coverSection.createEl("label", { text: "\u5C01\u9762\u56FE", cls: "wechat-modal-label" });
    const coverContent = coverSection.createDiv({ cls: "wechat-modal-cover-content" });
    const coverPreview = coverContent.createDiv({ cls: "wechat-modal-cover-preview" });
    const updatePreview = () => {
      coverPreview.empty();
      if (coverBase64) {
        coverPreview.createEl("img", { attr: { src: coverBase64 } });
        syncBtn.disabled = false;
        syncBtn.setText("\u5F00\u59CB\u540C\u6B65");
        syncBtn.removeClass("apple-btn-disabled");
      } else {
        coverPreview.createEl("div", {
          text: "\u6682\u65E0\u5C01\u9762",
          cls: "wechat-modal-no-cover"
        });
        syncBtn.disabled = true;
        syncBtn.setText("\u8BF7\u5148\u8BBE\u7F6E\u5C01\u9762");
        syncBtn.addClass("apple-btn-disabled");
      }
    };
    const coverBtns = coverContent.createDiv({ cls: "wechat-modal-cover-btns" });
    const uploadBtn = coverBtns.createEl("button", { text: "\u4E0A\u4F20" });
    const digestSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    digestSection.createEl("label", { text: "\u6587\u7AE0\u6458\u8981\uFF08\u53EF\u9009\uFF09", cls: "wechat-modal-label" });
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.currentHtml || "";
    const autoDigest = (tempDiv.textContent || "").replace(/\s+/g, " ").trim().substring(0, 45);
    const initialDigest = (cachedState == null ? void 0 : cachedState.digest) !== void 0 ? cachedState.digest : frontmatterMeta.excerpt || autoDigest;
    const digestInput = digestSection.createEl("textarea", {
      cls: "wechat-modal-digest-input",
      placeholder: "\u7559\u7A7A\u5219\u81EA\u52A8\u63D0\u53D6\u6587\u7AE0\u524D 45 \u5B57"
    });
    digestInput.value = initialDigest;
    digestInput.rows = 3;
    digestInput.style.width = "100%";
    digestInput.style.resize = "vertical";
    digestInput.maxLength = 120;
    const charCount = digestSection.createEl("div", {
      cls: "wechat-digest-count",
      text: `${digestInput.value.length}/120`,
      style: "text-align: right; font-size: 11px; color: var(--text-muted); margin-top: 4px; opacity: 0.7;"
    });
    digestInput.addEventListener("input", () => {
      charCount.setText(`${digestInput.value.length}/120`);
      if (currentPath) {
        const state = this.articleStates.get(currentPath) || {};
        state.digest = digestInput.value.trim();
        this.articleStates.set(currentPath, { ...state, digest: digestInput.value });
      }
    });
    const btnRow = modal.contentEl.createDiv({ cls: "wechat-modal-buttons" });
    const cancelBtn = btnRow.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.onclick = () => modal.close();
    const syncBtn = btnRow.createEl("button", { text: "\u5F00\u59CB\u540C\u6B65", cls: "mod-cta" });
    updatePreview();
    syncBtn.onclick = async () => {
      if (!coverBase64) {
        new Notice("\u274C \u8BF7\u5148\u8BBE\u7F6E\u5C01\u9762\u56FE");
        return;
      }
      modal.close();
      this.selectedAccountId = selectedAccountId;
      this.sessionCoverBase64 = coverBase64;
      this.sessionDigest = digestInput.value.trim() || autoDigest || "\u4E00\u952E\u540C\u6B65\u81EA Obsidian";
      await this.onSyncToWechat();
    };
    uploadBtn.onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file)
          return;
        const reader = new FileReader();
        reader.onload = (event) => {
          coverBase64 = event.target.result;
          this.sessionCoverBase64 = coverBase64;
          updatePreview();
          if (currentPath) {
            const state = this.articleStates.get(currentPath) || {};
            this.articleStates.set(currentPath, { ...state, coverBase64 });
          }
        };
        reader.readAsDataURL(file);
      };
      input.click();
    };
    modal.open();
  }
  /**
   * 处理同步到微信逻辑
   */
  async onSyncToWechat() {
    const account = resolveSyncAccount({
      accounts: this.plugin.settings.wechatAccounts || [],
      selectedAccountId: this.selectedAccountId,
      defaultAccountId: this.plugin.settings.defaultAccountId
    });
    if (!account) {
      new Notice("\u274C \u8BF7\u5148\u5728\u63D2\u4EF6\u8BBE\u7F6E\u4E2D\u6DFB\u52A0\u5FAE\u4FE1\u516C\u4F17\u53F7\u8D26\u53F7");
      return;
    }
    if (!this.currentHtml) {
      new Notice("\u274C \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    const notice = new Notice(`\u{1F680} \u6B63\u5728\u4F7F\u7528 ${account.name} \u540C\u6B65...`, 0);
    const activeFile = this.getPublishContextFile();
    const publishMeta = this.getFrontmatterPublishMeta(activeFile);
    try {
      const syncService = createWechatSyncService({
        createApi: (appId, appSecret, proxyUrl) => new WechatAPI(appId, appSecret, proxyUrl),
        srcToBlob: this.srcToBlob.bind(this),
        processAllImages: this.processAllImages.bind(this),
        processMathFormulas: this.processMathFormulas.bind(this),
        cleanHtmlForDraft: this.cleanHtmlForDraft.bind(this),
        cleanupConfiguredDirectory: this.cleanupConfiguredDirectory.bind(this),
        getFirstImageFromArticle: this.getFirstImageFromArticle.bind(this)
      });
      const { cleanupResult } = await syncService.syncToDraft({
        account,
        proxyUrl: this.plugin.settings.proxyUrl,
        currentHtml: this.currentHtml,
        activeFile,
        publishMeta,
        sessionCoverBase64: this.sessionCoverBase64,
        sessionDigest: this.sessionDigest,
        onStatus: (stage) => {
          if (stage === "cover")
            notice.setMessage("\u{1F5BC}\uFE0F \u6B63\u5728\u5904\u7406\u5C01\u9762\u56FE...");
          if (stage === "images")
            notice.setMessage("\u{1F4F8} \u6B63\u5728\u540C\u6B65\u6B63\u6587\u56FE\u7247...");
          if (stage === "math")
            notice.setMessage("\u{1F9EE} \u6B63\u5728\u8F6C\u6362\u77E2\u91CF\u56FE/\u6570\u5B66\u516C\u5F0F...");
          if (stage === "draft")
            notice.setMessage("\u{1F4DD} \u6B63\u5728\u53D1\u9001\u5230\u5FAE\u4FE1\u8349\u7A3F\u7BB1...");
        },
        onImageProgress: (current, total) => {
          notice.setMessage(`\u{1F4F8} \u6B63\u5728\u540C\u6B65\u6B63\u6587\u56FE\u7247 (${current}/${total})...`);
        },
        onMathProgress: (current, total) => {
          notice.setMessage(`\u{1F9EE} \u6B63\u5728\u8F6C\u6362\u77E2\u91CF\u56FE/\u6570\u5B66\u516C\u5F0F (${current}/${total})...`);
        }
      });
      notice.hide();
      new Notice("\u2705 \u540C\u6B65\u6210\u529F\uFF01\u8BF7\u524D\u5F80\u5FAE\u4FE1\u516C\u4F17\u53F7\u540E\u53F0\u8349\u7A3F\u7BB1\u67E5\u770B");
      if (cleanupResult == null ? void 0 : cleanupResult.warning) {
        new Notice(`\u26A0\uFE0F \u8D44\u6E90\u6E05\u7406\u5931\u8D25\uFF1A${cleanupResult.warning}`, 7e3);
      }
    } catch (error) {
      notice.hide();
      console.error("Wechat Sync Error:", error);
      const friendlyMsg = toSyncFriendlyMessage(error.message);
      new Notice(`\u274C \u540C\u6B65\u5931\u8D25: ${friendlyMsg}`);
    }
  }
  /**
   * 将各种形式的 src (Base64, URL, 路径) 转为 Blob
   */
  async srcToBlob(src) {
    if (src.startsWith("data:")) {
      const resp = await fetch(src);
      return await resp.blob();
    }
    if (src.startsWith("app://") || src.startsWith("capacitor://")) {
      const resp = await fetch(src);
      return await resp.blob();
    }
    if (src.startsWith("http")) {
      const { requestUrl } = require("obsidian");
      const response = await requestUrl({ url: src });
      const contentType = response.headers["content-type"] || response.headers["Content-Type"] || "image/jpeg";
      return new Blob([response.arrayBuffer], { type: contentType });
    }
    throw new Error("\u4E0D\u652F\u6301\u7684\u56FE\u7247\u6765\u6E90\uFF0C\u8BF7\u5C1D\u8BD5\u91CD\u65B0\u4E0A\u4F20\u5C01\u9762");
  }
  /**
   * 处理 HTML 中的所有图片，上传到微信并替换链接
   * 支持并发上传 (Limit 3) 和进度回调
   */
  async processAllImages(html, api, progressCallback, cacheContext = {}) {
    const accountId = (cacheContext == null ? void 0 : cacheContext.accountId) || "";
    return processAllImagesService({
      html,
      api,
      progressCallback,
      pMap,
      srcToBlob: this.srcToBlob.bind(this),
      imageUploadCache: this.imageUploadCache,
      cacheNamespace: accountId
    });
  }
  /**
   * 处理 HTML 中的数学公式 (MathJax SVG -> Wechat Image)
   * 解决微信接口内容长度限制问题
   */
  async processMathFormulas(html, api, progressCallback) {
    return processMathFormulasService({
      html,
      api,
      progressCallback,
      pMap,
      simpleHash: this.simpleHash.bind(this),
      svgUploadCache: this.svgUploadCache,
      svgToPngBlob: this.svgToPngBlob.bind(this)
    });
  }
  /**
   * 将 SVG 元素转换为高分辨率 PNG Blob
   * 返回: { blob, width, height, style }
   */
  async svgToPngBlob(svgElement, scale = 3) {
    return new Promise((resolve, reject) => {
      try {
        const clonedSvg = svgElement.cloneNode(true);
        const rect = svgElement.getBoundingClientRect();
        let logicalWidth = rect.width;
        let logicalHeight = rect.height;
        const rawWidth = svgElement.getAttribute("width");
        const rawHeight = svgElement.getAttribute("height");
        const rawStyle = svgElement.getAttribute("style");
        if (logicalWidth === 0 || logicalHeight === 0) {
          logicalWidth = parseFloat(rawWidth) || 100;
          logicalHeight = parseFloat(rawHeight) || 20;
        }
        const isMathJax = svgElement.getAttribute("role") === "img" || svgElement.getAttribute("focusable") === "false" || svgElement.classList.contains("MathJax");
        if (isMathJax) {
          clonedSvg.setAttribute("fill", "#333333");
          clonedSvg.style.color = "#333333";
          clonedSvg.querySelectorAll("*").forEach((el) => {
            if (el.getAttribute("fill") === "currentColor" || !el.getAttribute("fill")) {
              el.setAttribute("fill", "#333333");
            }
            if (el.getAttribute("stroke") === "currentColor") {
              el.setAttribute("stroke", "#333333");
            }
          });
        }
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(clonedSvg);
        const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = logicalWidth * scale;
            canvas.height = logicalHeight * scale;
            const ctx = canvas.getContext("2d");
            ctx.scale(scale, scale);
            ctx.drawImage(img, 0, 0, logicalWidth, logicalHeight);
            URL.revokeObjectURL(url);
            canvas.toBlob((blob) => {
              if (blob) {
                resolve({
                  blob,
                  width: logicalWidth,
                  // 返回逻辑宽度 (例如 20.5)
                  height: logicalHeight,
                  style: rawStyle
                });
              } else
                reject(new Error("Canvas conversion failed"));
            }, "image/png");
          } catch (e) {
            reject(e);
          }
        };
        img.onerror = (e) => {
          URL.revokeObjectURL(url);
          reject(new Error("SVG Image load failed"));
        };
        img.src = url;
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * 清理 HTML 以适配微信编辑器
   * 微信编辑器对嵌套列表支持不佳，需要：
   * 1. 处理嵌套列表父级 li 内的段落与行内内容（避免嵌套层级被打散）
   * 2. 将深层嵌套列表转为伪列表（避免微信扁平化）
   * 3. 移除嵌套 ul/ol 的 margin（避免被当成独立块）
   * 4. 移除空的 li 元素和空白文本节点
   */
  cleanHtmlForDraft(html) {
    return cleanHtmlForDraftService(html);
  }
  // === 设置变更处理 ===
  async onThemeChange(value, grid) {
    this.plugin.settings.theme = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ theme: value });
    await this.convertCurrent(true);
  }
  async onFontFamilyChange(value) {
    this.plugin.settings.fontFamily = value;
    await this.plugin.saveSettings();
    this.theme.update({ fontFamily: value });
    await this.convertCurrent(true);
  }
  async onFontSizeChange(value, grid) {
    this.plugin.settings.fontSize = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ fontSize: value });
    await this.convertCurrent(true);
  }
  async onColorChange(value, grid) {
    this.plugin.settings.themeColor = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ themeColor: value });
    await this.convertCurrent(true);
  }
  async onMacCodeBlockChange(checked) {
    this.plugin.settings.macCodeBlock = checked;
    await this.plugin.saveSettings();
    this.theme.update({ macCodeBlock: checked });
    if (this.converter) {
      this.converter.reinit();
      await this.converter.initMarkdownIt();
    }
    await this.convertCurrent(true);
  }
  async onCodeLineNumberChange(checked) {
    this.plugin.settings.codeLineNumber = checked;
    await this.plugin.saveSettings();
    this.theme.update({ codeLineNumber: checked });
    if (this.converter) {
      this.converter.reinit();
      await this.converter.initMarkdownIt();
    }
    await this.convertCurrent(true);
  }
  updateButtonActive(grid, value) {
    grid.querySelectorAll("button").forEach((btn) => {
      btn.classList.toggle("active", btn.dataset.value == value);
    });
  }
  getRenderPipelineFlags() {
    var _a, _b, _c, _d, _e, _f;
    const useTripletPipeline = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.useTripletPipeline) === true;
    const tripletFallbackToPhase2 = ((_d = (_c = this.plugin) == null ? void 0 : _c.settings) == null ? void 0 : _d.tripletFallbackToPhase2) !== false;
    const enforceTripletParity = ((_f = (_e = this.plugin) == null ? void 0 : _e.settings) == null ? void 0 : _f.enforceTripletParity) !== false;
    return {
      useTripletPipeline,
      tripletFallbackToPhase2,
      enforceTripletParity,
      // Backward-compatible aliases for existing tests and fallback paths.
      useNativePipeline: useTripletPipeline,
      enableLegacyFallback: tripletFallbackToPhase2,
      enforceNativeParity: enforceTripletParity,
      parityErrorCode: "TRIPLET_PARITY_MISMATCH",
      parityTransform: (html) => {
        const cleaned = this.cleanHtmlForDraft(html);
        return cleaned.replace(/>\r?\n\s*</g, "><").replace(/\r?\n/g, "");
      },
      onParityMismatch: ({ context, mismatch }) => {
        this.logParityMismatchDetails((context == null ? void 0 : context.sourcePath) || "", mismatch || {});
      }
    };
  }
  getActiveRenderPipeline() {
    const flags = this.getRenderPipelineFlags();
    if (flags.useTripletPipeline && this.nativeRenderPipeline) {
      return this.nativeRenderPipeline;
    }
    return this.legacyRenderPipeline;
  }
  async renderMarkdownForPreview(markdown, sourcePath) {
    const pipeline = this.getActiveRenderPipeline();
    if (!pipeline) {
      throw new Error("\u6E32\u67D3\u7BA1\u7EBF\u672A\u521D\u59CB\u5316");
    }
    return pipeline.renderForPreview(markdown, { sourcePath });
  }
  /**
   * 更新当前文档显示
   */
  updateCurrentDoc() {
    const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (activeView && this.docTitleText) {
      this.docTitleText.setText(activeView.file.basename);
      this.docTitleText.style.color = "var(--apple-primary)";
    } else if (this.lastActiveFile && this.docTitleText) {
      this.docTitleText.setText(this.lastActiveFile.basename);
      this.docTitleText.style.color = "var(--apple-primary)";
    } else if (this.docTitleText) {
      this.docTitleText.setText("\u672A\u9009\u62E9\u6587\u6863");
      this.docTitleText.style.color = "var(--apple-tertiary)";
    }
  }
  /**
   * 设置占位符
   */
  setPlaceholder() {
    this.previewContainer.empty();
    this.previewContainer.removeClass("apple-has-content");
    const placeholder = this.previewContainer.createEl("div", { cls: "apple-placeholder" });
    placeholder.createEl("div", { cls: "apple-placeholder-icon", text: "\u{1F4DD}" });
    placeholder.createEl("h2", { text: "\u5FAE\u4FE1\u516C\u4F17\u53F7\u6392\u7248\u8F6C\u6362\u5668" });
    placeholder.createEl("p", { text: "\u5C06 Markdown \u8F6C\u6362\u4E3A\u7CBE\u7F8E\u7684 HTML\uFF0C\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1" });
    const steps = placeholder.createEl("div", { cls: "apple-steps" });
    steps.createEl("div", { text: "1\uFE0F\u20E3 \u6253\u5F00\u9700\u8981\u8F6C\u6362\u7684 Markdown \u6587\u4EF6" });
    steps.createEl("div", { text: "2\uFE0F\u20E3 \u9884\u89C8\u533A\u4F1A\u81EA\u52A8\u663E\u793A\u8F6C\u6362\u6548\u679C" });
    steps.createEl("div", { text: "3\uFE0F\u20E3 \u70B9\u51FB\u300C\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1\u300D\u5373\u53EF\u53D1\u9001" });
    const note = placeholder.createEl("p", {
      text: "\u6CE8\u610F\uFF1A\u5982\u5F53\u524D\u5DF2\u6253\u5F00\u6587\u6863\u4F46\u672A\u663E\u793A\uFF0C\u8BF7\u91CD\u65B0\u70B9\u51FB\u4E00\u4E0B\u6587\u6863\u5373\u53EF\u89E6\u53D1",
      cls: "apple-placeholder-note"
    });
  }
  showParityMismatchPlaceholder(sourcePath, mismatch = {}) {
    this.currentHtml = null;
    this.previewContainer.empty();
    this.previewContainer.removeClass("apple-has-content");
    const index = Number.isInteger(mismatch.index) ? mismatch.index : -1;
    const segmentCount = Number.isInteger(mismatch.segmentCount) ? mismatch.segmentCount : 0;
    const name = sourcePath ? String(sourcePath).split("/").pop() : "\u5F53\u524D\u6587\u6863";
    const box = this.previewContainer.createEl("div", { cls: "apple-placeholder" });
    box.createEl("div", { cls: "apple-placeholder-icon", text: "\u26A0\uFE0F" });
    box.createEl("h2", { text: "\u4E09\u4EF6\u5957\u6E32\u67D3\u672A\u901A\u8FC7\u96F6\u5DEE\u5F02\u95E8\u7981" });
    box.createEl("p", {
      text: `${name} \u4E0E Phase2 \u57FA\u7EBF\u8F93\u51FA\u5B58\u5728\u5DEE\u5F02\uFF08\u9996\u4E2A index ${index}\uFF0C\u5171 ${segmentCount} \u6BB5\u5DEE\u5F02\uFF09\u3002`
    });
    if (Array.isArray(mismatch.segments) && mismatch.segments.length > 0) {
      const list = box.createEl("ul", { cls: "apple-parity-list" });
      mismatch.segments.slice(0, 3).forEach((seg, idx) => {
        const segIndex = Number.isInteger(seg.index) ? seg.index : -1;
        const lLine = Number.isInteger(seg.legacyLine) ? seg.legacyLine : -1;
        const lCol = Number.isInteger(seg.legacyColumn) ? seg.legacyColumn : -1;
        list.createEl("li", {
          text: `#${idx + 1}: index ${segIndex}\uFF08legacy ${lLine}:${lCol}\uFF09`
        });
      });
    }
    box.createEl("p", {
      cls: "apple-placeholder-note",
      text: "\u5EFA\u8BAE\u5F00\u542F\u201C\u4E09\u4EF6\u5957\u5931\u8D25\u65F6\u56DE\u9000 Phase2\u201D\uFF0C\u6216\u7EE7\u7EED\u5728\u5F53\u524D\u6A21\u5F0F\u4E0B\u5B9A\u4F4D\u5DEE\u5F02\u3002"
    });
    this.updateCurrentDoc();
  }
  logParityMismatchDetails(sourcePath, mismatch = {}) {
    var _a, _b;
    const fileName = sourcePath ? String(sourcePath).split("/").pop() : "\u5F53\u524D\u6587\u6863";
    const index = Number.isInteger(mismatch.index) ? mismatch.index : -1;
    const segmentCount = Number.isInteger(mismatch.segmentCount) ? mismatch.segmentCount : 0;
    const lengthDelta = Number.isInteger(mismatch.lengthDelta) ? mismatch.lengthDelta : 0;
    const legacyLength = Number.isInteger(mismatch.legacyLength) ? mismatch.legacyLength : -1;
    const candidateLength = Number.isInteger(mismatch.candidateLength) ? mismatch.candidateLength : -1;
    const verboseLog = ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.tripletParityVerboseLog) === true;
    console.groupCollapsed(
      `[Triplet Parity] ${fileName} mismatch: index=${index}, segments=${segmentCount}, delta=${lengthDelta}`
    );
    console.warn("[Triplet Parity] summary", {
      sourcePath,
      index,
      segmentCount,
      lengthDelta,
      legacyLength,
      candidateLength,
      truncated: mismatch.truncated === true
    });
    if (Array.isArray(mismatch.segments) && mismatch.segments.length > 0) {
      const maxPreview = 5;
      mismatch.segments.slice(0, maxPreview).forEach((seg, idx) => {
        const segIndex = Number.isInteger(seg.index) ? seg.index : -1;
        const legacyLine = Number.isInteger(seg.legacyLine) ? seg.legacyLine : -1;
        const legacyColumn = Number.isInteger(seg.legacyColumn) ? seg.legacyColumn : -1;
        const candidateLine = Number.isInteger(seg.candidateLine) ? seg.candidateLine : -1;
        const candidateColumn = Number.isInteger(seg.candidateColumn) ? seg.candidateColumn : -1;
        console.warn(`[Triplet Parity] segment #${idx + 1}`, {
          index: segIndex,
          legacy: `${legacyLine}:${legacyColumn}`,
          candidate: `${candidateLine}:${candidateColumn}`,
          legacySnippet: seg.legacySnippet,
          candidateSnippet: seg.candidateSnippet
        });
      });
      if (mismatch.segments.length > maxPreview) {
        console.warn(`[Triplet Parity] ${mismatch.segments.length - maxPreview} more segments omitted from log preview`);
      }
    }
    const fullDetails = {
      revision: TRIPLET_PARITY_DEBUG_REV,
      sourcePath,
      index,
      segmentCount,
      lengthDelta,
      legacyLength,
      candidateLength,
      truncated: mismatch.truncated === true,
      segments: Array.isArray(mismatch.segments) ? mismatch.segments : []
    };
    if (typeof window !== "undefined") {
      window.__OWC_LAST_PARITY_DETAILS = fullDetails;
      window.__OWC_TRIPLET_PARITY_REV = TRIPLET_PARITY_DEBUG_REV;
    }
    if (verboseLog) {
      console.log("[Triplet Parity] full-details", fullDetails);
    }
    console.groupEnd();
    if (verboseLog) {
      console.error("[Triplet Parity] full-details-json", JSON.stringify(fullDetails));
    }
  }
  /**
   * 转换当前文档
   */
  async convertCurrent(silent = false) {
    var _a, _b;
    const generation = ++this.renderGeneration;
    const source = await resolveMarkdownSource({
      app: this.app,
      lastActiveFile: this.lastActiveFile,
      MarkdownViewType: MarkdownView
    });
    if (!source.ok) {
      if (!silent)
        new Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u6587\u4EF6");
      return;
    }
    const markdown = source.markdown;
    const sourcePath = source.sourcePath;
    if (!markdown.trim()) {
      if (!silent)
        new Notice("\u5F53\u524D\u6587\u4EF6\u5185\u5BB9\u4E3A\u7A7A");
      return;
    }
    try {
      if (!silent)
        new Notice("\u26A1 \u6B63\u5728\u8F6C\u6362...");
      const html = await this.renderMarkdownForPreview(markdown, sourcePath);
      if (generation !== this.renderGeneration)
        return;
      this.currentHtml = html;
      this.sessionCoverBase64 = null;
      const scrollTop = this.previewContainer.scrollTop;
      this.previewContainer.innerHTML = html;
      this.previewContainer.scrollTop = scrollTop;
      this.previewContainer.addClass("apple-has-content");
      this.updateCurrentDoc();
      if (!silent)
        new Notice("\u2705 \u8F6C\u6362\u6210\u529F\uFF01");
    } catch (error) {
      console.error("\u8F6C\u6362\u5931\u8D25:", error);
      if (error && (error.code === "TRIPLET_PARITY_MISMATCH" || error.code === "PARITY_MISMATCH")) {
        const index = Number.isInteger((_a = error == null ? void 0 : error.parity) == null ? void 0 : _a.index) ? error.parity.index : -1;
        const segmentCount = Number.isInteger((_b = error == null ? void 0 : error.parity) == null ? void 0 : _b.segmentCount) ? error.parity.segmentCount : 0;
        this.showParityMismatchPlaceholder(sourcePath, error.parity || {});
        const noticeKey = `${sourcePath || ""}:${index}:${segmentCount}`;
        if (!silent || this.lastParityMismatchNoticeKey !== noticeKey) {
          new Notice(`\u26A0\uFE0F \u4E09\u4EF6\u5957\u6E32\u67D3\u4E0E Phase2 \u57FA\u7EBF\u4E0D\u4E00\u81F4\uFF08\u9996\u4E2A index ${index}\uFF0C\u5171 ${segmentCount} \u6BB5\uFF09`);
          this.lastParityMismatchNoticeKey = noticeKey;
        }
        return;
      }
      if (!silent)
        new Notice("\u274C \u8F6C\u6362\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 视图改变大小时触发 (包括侧边栏展开、Tab切换等导致的大小变化)
   */
  onResize() {
    super.onResize();
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    if (!this.containerEl.offsetParent)
      return;
    this.resizeTimeout = setTimeout(() => {
      this.convertCurrent(true);
    }, 300);
  }
  /**
   * 渲染 HTML
   */
  renderHTML(html) {
    this.previewContainer.empty();
    this.previewContainer.innerHTML = html;
  }
  /**
   * 复制 HTML
   */
  async copyHTML() {
    if (this.isCopying)
      return;
    if (!this.currentHtml) {
      new Notice("\u26A0\uFE0F \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    this.isCopying = true;
    if (this.copyBtn) {
      this.copyBtn.classList.add("active");
    }
    try {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = this.currentHtml;
      const images = Array.from(tempDiv.querySelectorAll("img"));
      const localImages = images.filter((img) => img.src.startsWith("app://"));
      if (localImages.length > 0) {
        new Notice("\u23F3 \u6B63\u5728\u5904\u7406\u56FE\u7247...");
      }
      const processed = await this.processImagesToDataURL(tempDiv);
      const cleanedHtml = this.cleanHtmlForDraft(tempDiv.innerHTML);
      const plainDiv = document.createElement("div");
      plainDiv.innerHTML = cleanedHtml;
      const text = plainDiv.textContent || "";
      const htmlContent = cleanedHtml;
      window.__OWC_LAST_CLIPBOARD_HTML = htmlContent;
      window.__OWC_LAST_CLIPBOARD_TEXT = text;
      if (navigator.clipboard && navigator.clipboard.write) {
        try {
          const htmlOnlyItem = new ClipboardItem({
            "text/html": new Blob([htmlContent], { type: "text/html" })
          });
          await navigator.clipboard.write([htmlOnlyItem]);
        } catch (htmlOnlyError) {
          const clipboardItem = new ClipboardItem({
            "text/html": new Blob([htmlContent], { type: "text/html" }),
            "text/plain": new Blob([text], { type: "text/plain" })
          });
          await navigator.clipboard.write([clipboardItem]);
        }
        new Notice("\u2705 \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\uFF01");
        if (this.copyBtn) {
          const { setIcon } = require("obsidian");
          setIcon(this.copyBtn, "check");
          setTimeout(() => {
            if (this.copyBtn) {
              setIcon(this.copyBtn, "copy");
              this.copyBtn.classList.remove("active");
            }
          }, 2e3);
        }
        return;
      }
      throw new Error("Clipboard API unavailable");
    } catch (error) {
      console.error("\u590D\u5236\u5931\u8D25:", error);
      new Notice(`\u274C \u590D\u5236\u5931\u8D25: ${error.message}`);
      if (this.copyBtn) {
        this.copyBtn.classList.remove("active");
      }
    } finally {
      this.isCopying = false;
    }
  }
  /**
   * 将 HTML 中的本地图片转换为 Base64 (Canvas Compressed)
   */
  async processImagesToDataURL(container) {
    const images = Array.from(container.querySelectorAll("img"));
    const localImages = images.filter((img) => img.src.startsWith("app://") || img.src.startsWith("capacitor://"));
    if (localImages.length === 0)
      return false;
    const startTime = Date.now();
    const concurrency = 3;
    for (let i = 0; i < localImages.length; i += concurrency) {
      const chunk = localImages.slice(i, i + concurrency);
      await Promise.all(chunk.map((img) => this.convertImageToLocally(img)));
    }
    const elapsed = Date.now() - startTime;
    const minDuration = 800;
    if (elapsed < minDuration) {
      await new Promise((resolve) => setTimeout(resolve, minDuration - elapsed));
    }
    return true;
  }
  async convertImageToLocally(img) {
    try {
      const response = await fetch(img.src);
      const blob = await response.blob();
      if (blob.size > 10 * 1024 * 1024) {
        new Notice(`\u26A0\uFE0F \u53D1\u73B0\u5927\u56FE (${(blob.size / 1024 / 1024).toFixed(1)}MB)\uFF0C\u5904\u7406\u53EF\u80FD\u8F83\u6162`, 5e3);
      }
      let dataUrl;
      if (blob.type === "image/gif") {
        dataUrl = await this.blobToDataUrl(blob);
      } else {
        dataUrl = await this.blobToJpegDataUrl(blob);
      }
      img.src = dataUrl;
      delete img.dataset.src;
    } catch (error) {
      console.error("Image processing failed:", error);
    }
  }
  // Helper: Direct Blob to Base64 (for GIFs)
  blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  blobToJpegDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(blob);
      const image = new Image();
      image.onload = () => {
        const canvas = document.createElement("canvas");
        let width = image.width;
        let height = image.height;
        if (width > 1920) {
          height = Math.round(height * (1920 / width));
          width = 1920;
        }
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, width, height);
        const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
        URL.revokeObjectURL(url);
        resolve(dataUrl);
      };
      image.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error("Image load failed"));
      };
      image.src = url;
    });
  }
  async onClose() {
    var _a;
    if (this.activeEditorScroller && this.editorScrollListener) {
      this.activeEditorScroller.removeEventListener("scroll", this.editorScrollListener);
    }
    if (this.previewContainer && this.previewScrollListener) {
      this.previewContainer.removeEventListener("scroll", this.previewScrollListener);
    }
    (_a = this.previewContainer) == null ? void 0 : _a.empty();
    if (this.articleStates) {
      this.articleStates.clear();
    }
    if (this.svgUploadCache) {
      this.svgUploadCache.clear();
    }
    if (this.imageUploadCache) {
      this.imageUploadCache.clear();
    }
    console.log("\u{1F34E} \u8F6C\u6362\u5668\u9762\u677F\u5DF2\u5173\u95ED");
  }
  /**
   * 简单的字符串哈希函数 (DJB2算法)
   */
  simpleHash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = hash * 33 ^ str.charCodeAt(i);
    }
    return hash >>> 0;
  }
};
var AppleStyleSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  normalizeVaultPath(vaultPath) {
    return normalizeVaultPath(vaultPath);
  }
  isAbsolutePathLike(vaultPath) {
    return isAbsolutePathLike(vaultPath);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new Setting(containerEl).setDesc("\u66F4\u591A\u6392\u7248\u6837\u5F0F\u9009\u9879\uFF08\u4E3B\u9898\u3001\u5B57\u53F7\u3001\u4EE3\u7801\u5757\u7B49\uFF09\u8BF7\u5728\u63D2\u4EF6\u4FA7\u8FB9\u680F\u9762\u677F\u4E2D\u8FDB\u884C\u8BBE\u7F6E\u3002");
    new Setting(containerEl).setName("\u9884\u89C8\u6A21\u5F0F").setHeading();
    new Setting(containerEl).setName("\u4F7F\u7528\u624B\u673A\u4EFF\u771F\u6846").setDesc("\u5F00\u542F\u540E\uFF0C\u9884\u89C8\u533A\u57DF\u5C06\u663E\u793A\u4E3A iPhone X \u624B\u673A\u6846\u6837\u5F0F\uFF1B\u5173\u95ED\u5219\u6062\u590D\u4E3A\u7ECF\u5178\u5168\u5BBD\u9884\u89C8\u6A21\u5F0F\uFF08\u9700\u91CD\u542F\u63D2\u4EF6\u9762\u677F\u751F\u6548\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.usePhoneFrame).onChange(async (value) => {
      this.plugin.settings.usePhoneFrame = value;
      await this.plugin.saveSettings();
      new Notice("\u8BBE\u7F6E\u5DF2\u4FDD\u5B58\uFF0C\u8BF7\u5173\u95ED\u5E76\u91CD\u65B0\u6253\u5F00\u8F6C\u6362\u5668\u9762\u677F\u4EE5\u751F\u6548");
    }));
    new Setting(containerEl).setName("\u56FE\u7247\u6C34\u5370").setHeading();
    new Setting(containerEl).setName("\u542F\u7528\u56FE\u7247\u6C34\u5370").setDesc("\u5728\u6BCF\u5F20\u56FE\u7247\u4E0A\u65B9\u663E\u793A\u5934\u50CF").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWatermark).onChange(async (value) => {
      this.plugin.settings.enableWatermark = value;
      await this.plugin.saveSettings();
    }));
    const uploadSetting = new Setting(containerEl).setName("\u4E0A\u4F20\u672C\u5730\u5934\u50CF").setDesc(this.plugin.settings.avatarBase64 ? "\u2705 \u5DF2\u4E0A\u4F20\u672C\u5730\u5934\u50CF\uFF08\u4F18\u5148\u4F7F\u7528\uFF09" : "\u9009\u62E9\u672C\u5730\u56FE\u7247\uFF0C\u8F6C\u6362\u4E3A Base64 \u5B58\u50A8\uFF0C\u65E0\u9700\u7F51\u7EDC\u8BF7\u6C42");
    uploadSetting.addButton((button) => button.setButtonText(this.plugin.settings.avatarBase64 ? "\u91CD\u65B0\u4E0A\u4F20" : "\u9009\u62E9\u56FE\u7247").onClick(() => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file)
          return;
        if (file.size > 100 * 1024) {
          new Notice("\u274C \u56FE\u7247\u592A\u5927\uFF0C\u8BF7\u9009\u62E9\u5C0F\u4E8E 100KB \u7684\u56FE\u7247");
          return;
        }
        const reader = new FileReader();
        reader.onload = async (event) => {
          this.plugin.settings.avatarBase64 = event.target.result;
          await this.plugin.saveSettings();
          new Notice("\u2705 \u5934\u50CF\u5DF2\u4E0A\u4F20");
          this.display();
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }));
    if (this.plugin.settings.avatarBase64) {
      uploadSetting.addButton((button) => button.setButtonText("\u6E05\u9664").setWarning().onClick(async () => {
        this.plugin.settings.avatarBase64 = "";
        await this.plugin.saveSettings();
        new Notice("\u5DF2\u6E05\u9664\u672C\u5730\u5934\u50CF");
        this.display();
      }));
    }
    new Setting(containerEl).setName("\u5934\u50CF URL\uFF08\u5907\u7528\uFF09").setDesc("\u5982\u672A\u4E0A\u4F20\u672C\u5730\u5934\u50CF\uFF0C\u5C06\u4F7F\u7528\u6B64 URL").addText((text) => text.setPlaceholder("https://example.com/avatar.jpg").setValue(this.plugin.settings.avatarUrl).onChange(async (value) => {
      this.plugin.settings.avatarUrl = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u5FAE\u4FE1\u516C\u4F17\u53F7\u8D26\u53F7").setDesc("\u8BF7\u5728\u5FAE\u4FE1\u516C\u4F17\u53F7\u540E\u53F0 [\u8BBE\u7F6E\u4E0E\u5F00\u53D1] -> [\u57FA\u672C\u914D\u7F6E] \u4E2D\u83B7\u53D6 AppID \u548C AppSecret\uFF0C\u5E76\u786E\u4FDD\u5DF2\u5C06\u5F53\u524D IP \u52A0\u5165\u767D\u540D\u5355\u3002").setHeading();
    const accounts = this.plugin.settings.wechatAccounts || [];
    const defaultId = this.plugin.settings.defaultAccountId;
    if (accounts.length === 0) {
      containerEl.createEl("p", {
        text: "\u6682\u65E0\u8D26\u53F7\uFF0C\u8BF7\u70B9\u51FB\u4E0B\u65B9\u6309\u94AE\u6DFB\u52A0",
        cls: "setting-item-description",
        attr: { style: "color: var(--text-muted); font-style: italic;" }
      });
    } else {
      const listContainer = containerEl.createDiv({ cls: "wechat-account-list" });
      for (const account of accounts) {
        const isDefault = account.id === defaultId;
        const card = listContainer.createDiv({ cls: "wechat-account-card" });
        const info = card.createDiv({ cls: "wechat-account-info" });
        const nameRow = info.createDiv({ cls: "wechat-account-name-row" });
        nameRow.createSpan({ text: account.name, cls: "wechat-account-name" });
        if (isDefault) {
          nameRow.createSpan({ text: "\u9ED8\u8BA4", cls: "wechat-account-badge" });
        }
        info.createDiv({
          text: `AppID: ${account.appId.substring(0, 8)}...`,
          cls: "wechat-account-appid"
        });
        const actions = card.createDiv({ cls: "wechat-account-actions" });
        if (!isDefault) {
          const defaultBtn = actions.createEl("button", { text: "\u8BBE\u4E3A\u9ED8\u8BA4", cls: "wechat-btn-small" });
          defaultBtn.onclick = async () => {
            this.plugin.settings.defaultAccountId = account.id;
            await this.plugin.saveSettings();
            this.display();
          };
        }
        const editBtn = actions.createEl("button", { text: "\u7F16\u8F91", cls: "wechat-btn-small" });
        editBtn.onclick = () => this.showEditAccountModal(account);
        const testBtn = actions.createEl("button", { text: "\u6D4B\u8BD5", cls: "wechat-btn-small wechat-btn-test" });
        testBtn.onclick = async () => {
          testBtn.disabled = true;
          testBtn.textContent = "\u6D4B\u8BD5\u4E2D...";
          try {
            const api = new WechatAPI(account.appId, account.appSecret, this.plugin.settings.proxyUrl);
            await api.getAccessToken();
            new Notice(`\u2705 ${account.name} \u8FDE\u63A5\u6210\u529F\uFF01`);
          } catch (err) {
            new Notice(`\u274C ${account.name} \u8FDE\u63A5\u5931\u8D25: ${err.message}`);
          }
          testBtn.disabled = false;
          testBtn.textContent = "\u6D4B\u8BD5";
        };
        const deleteBtn = actions.createEl("button", { text: "\u5220\u9664", cls: "wechat-btn-small wechat-btn-danger" });
        deleteBtn.onclick = async () => {
          if (confirm(`\u786E\u5B9A\u8981\u5220\u9664\u8D26\u53F7 "${account.name}" \u5417\uFF1F`)) {
            this.plugin.settings.wechatAccounts = accounts.filter((a) => a.id !== account.id);
            if (account.id === defaultId && this.plugin.settings.wechatAccounts.length > 0) {
              this.plugin.settings.defaultAccountId = this.plugin.settings.wechatAccounts[0].id;
            } else if (this.plugin.settings.wechatAccounts.length === 0) {
              this.plugin.settings.defaultAccountId = "";
            }
            await this.plugin.saveSettings();
            this.display();
          }
        };
      }
    }
    const addBtnContainer = containerEl.createDiv({ cls: "wechat-add-account-container" });
    if (accounts.length < MAX_ACCOUNTS) {
      const addBtn = addBtnContainer.createEl("button", {
        text: "+ \u6DFB\u52A0\u8D26\u53F7",
        cls: "wechat-btn-add"
      });
      addBtn.onclick = () => this.showEditAccountModal(null);
    } else {
      addBtnContainer.createEl("p", {
        text: `\u5DF2\u8FBE\u5230\u6700\u5927\u8D26\u53F7\u6570\u91CF (${MAX_ACCOUNTS})`,
        cls: "setting-item-description",
        attr: { style: "color: var(--text-muted);" }
      });
    }
    new Setting(containerEl).setName("\u9AD8\u7EA7\u8BBE\u7F6E").setHeading();
    new Setting(containerEl).setName("\u542F\u7528 Obsidian \u539F\u751F\u4E09\u4EF6\u5957\u6E32\u67D3").setDesc("\u4E00\u6B21\u6027\u542F\u7528 Source + Render + Export \u4E09\u4EF6\u5957\u94FE\u8DEF\u3002\u5173\u95ED\u65F6\u4F7F\u7528\u5F53\u524D\u7A33\u5B9A Phase2 \u57FA\u7EBF\u6E32\u67D3\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.useTripletPipeline === true).onChange(async (value) => {
      this.plugin.settings.useTripletPipeline = value;
      await this.plugin.saveSettings();
      new Notice(value ? "\u5DF2\u542F\u7528 Obsidian \u539F\u751F\u4E09\u4EF6\u5957\u6E32\u67D3" : "\u5DF2\u5207\u56DE Phase2 \u57FA\u7EBF\u6E32\u67D3");
      const converterView = this.plugin.getConverterView();
      if (converterView) {
        await converterView.convertCurrent(true);
      }
    }));
    new Setting(containerEl).setName("\u4E09\u4EF6\u5957\u5931\u8D25\u65F6\u56DE\u9000 Phase2").setDesc("\u5EFA\u8BAE\u4FDD\u6301\u5F00\u542F\u3002\u4E09\u4EF6\u5957\u6E32\u67D3\u5931\u8D25\u6216\u672A\u901A\u8FC7\u95E8\u7981\u65F6\u81EA\u52A8\u56DE\u9000\uFF0C\u786E\u4FDD\u65E5\u5E38\u53EF\u7528\u6027\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.tripletFallbackToPhase2 !== false).onChange(async (value) => {
      this.plugin.settings.tripletFallbackToPhase2 = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u4E09\u4EF6\u5957\u96F6\u5DEE\u5F02\u95E8\u7981").setDesc("\u5F00\u542F\u540E\u4F1A\u5C06\u4E09\u4EF6\u5957\u8F93\u51FA\u4E0E Phase2 \u57FA\u7EBF\u505A\u5B57\u8282\u7EA7\u5BF9\u6BD4\uFF1B\u4E0D\u4E00\u81F4\u65F6\u6309\u56DE\u9000\u7B56\u7565\u5904\u7406\u3002\u5EFA\u8BAE\u4FDD\u6301\u5F00\u542F\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.enforceTripletParity !== false).onChange(async (value) => {
      this.plugin.settings.enforceTripletParity = value;
      await this.plugin.saveSettings();
      const converterView = this.plugin.getConverterView();
      if (converterView) {
        await converterView.convertCurrent(true);
      }
    }));
    new Setting(containerEl).setName("\u8F93\u51FA\u4E09\u4EF6\u5957\u5B8C\u6574\u5DEE\u5F02\u65E5\u5FD7\uFF08\u8C03\u8BD5\uFF09").setDesc("\u9ED8\u8BA4\u5173\u95ED\u3002\u5F00\u542F\u540E\u4F1A\u628A\u5B8C\u6574\u5DEE\u5F02 payload \u8F93\u51FA\u5230\u63A7\u5236\u53F0\uFF0C\u65E5\u5FD7\u4F53\u79EF\u4F1A\u660E\u663E\u589E\u5927\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.tripletParityVerboseLog === true).onChange(async (value) => {
      this.plugin.settings.tripletParityVerboseLog = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u53D1\u9001\u6210\u529F\u540E\u81EA\u52A8\u6E05\u7406\u8D44\u6E90").setDesc("\u9ED8\u8BA4\u5173\u95ED\u3002\u5F00\u542F\u540E\u4F1A\u5728\u521B\u5EFA\u8349\u7A3F\u6210\u529F\u540E\uFF0C\u5220\u9664\u4F60\u5728\u4E0B\u65B9\u914D\u7F6E\u7684\u76EE\u5F55\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.cleanupAfterSync).onChange(async (value) => {
      this.plugin.settings.cleanupAfterSync = value;
      await this.plugin.saveSettings();
    }));
    let hasWarnedAbsoluteCleanupPath = false;
    new Setting(containerEl).setName("\u6E05\u7406\u76EE\u5F55").setDesc("\u586B\u5199 vault \u5185\u76F8\u5BF9\u8DEF\u5F84\uFF08\u4E0D\u8981\u586B /Users/... \u8FD9\u7C7B\u7EDD\u5BF9\u8DEF\u5F84\uFF09\uFF0C\u652F\u6301 {{note}} \u5360\u4F4D\u7B26\uFF0C\u4F8B\u5982 published/{{note}}_img\u3002").addText((text) => text.setPlaceholder("published/{{note}}_img").setValue(this.plugin.settings.cleanupDirTemplate || "").onChange(async (value) => {
      if (this.isAbsolutePathLike(value)) {
        if (!hasWarnedAbsoluteCleanupPath) {
          new Notice("\u26A0\uFE0F \u6E05\u7406\u76EE\u5F55\u8BF7\u586B\u5199 vault \u5185\u76F8\u5BF9\u8DEF\u5F84\uFF0C\u4E0D\u8981\u4F7F\u7528\u7EDD\u5BF9\u8DEF\u5F84\uFF08\u5982 /Users/... \u6216 C:\\...\uFF09");
          hasWarnedAbsoluteCleanupPath = true;
        }
      } else {
        hasWarnedAbsoluteCleanupPath = false;
      }
      const normalized = this.normalizeVaultPath(value);
      if (normalized.includes("..")) {
        new Notice("\u274C \u6E05\u7406\u76EE\u5F55\u4E0D\u80FD\u5305\u542B ..");
        return;
      }
      this.plugin.settings.cleanupDirTemplate = normalized;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u4F7F\u7528\u7CFB\u7EDF\u56DE\u6536\u7AD9").setDesc("\u5F00\u542F\u65F6\u4F18\u5148\u79FB\u52A8\u5230\u7CFB\u7EDF\u56DE\u6536\u7AD9\uFF1B\u5173\u95ED\u65F6\u76F4\u63A5\u4ECE vault \u5220\u9664\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.cleanupUseSystemTrash !== false).onChange(async (value) => {
      this.plugin.settings.cleanupUseSystemTrash = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("API \u4EE3\u7406\u5730\u5740").setDesc(createFragment((frag) => {
      const descDiv = frag.createDiv();
      descDiv.appendText("\u5982\u679C\u4F60\u7684\u7F51\u7EDC IP \u7ECF\u5E38\u53D8\u5316\uFF0C\u53EF\u914D\u7F6E\u4EE3\u7406\u670D\u52A1\u3002");
      descDiv.createEl("a", {
        text: "\u67E5\u770B\u90E8\u7F72\u6307\u5357",
        href: "https://xiaoweibox.top/chats/wechat-proxy",
        style: "margin-left: 5px;"
      });
      frag.createDiv({
        cls: "wechat-proxy-note",
        style: "margin-top: 6px; font-size: 12px; color: var(--text-muted); background: var(--background-secondary); padding: 8px; border-radius: 4px;"
      }, (el) => {
        el.createSpan({ text: "\u{1F512} \u5B89\u5168\u63D0\u793A\uFF1A\u4EE3\u7406\u670D\u52A1\u5C06\u4E2D\u8F6C\u60A8\u7684\u8BF7\u6C42\u3002\u8BF7\u786E\u4FDD\u4F7F\u7528\u53D7\u4FE1\u4EFB\u7684\u4EE3\u7406\uFF08\u81EA\u5EFA\u6216\u53EF\u9760\u7B2C\u4E09\u65B9\uFF09\uFF0C\u4EE5\u4FDD\u62A4 AppSecret \u5B89\u5168\u3002" });
      });
    })).addText((text) => text.setPlaceholder("https://your-proxy.workers.dev").setValue(this.plugin.settings.proxyUrl).onChange(async (value) => {
      const trimmedValue = value.trim();
      if (trimmedValue && !trimmedValue.startsWith("https://")) {
        new Notice("\u26A0\uFE0F \u5B89\u5168\u98CE\u9669\uFF1A\u4EE3\u7406\u5730\u5740\u5FC5\u987B\u4F7F\u7528 HTTPS \u4EE5\u4FDD\u62A4\u60A8\u7684 AppSecret\u3002");
      }
      this.plugin.settings.proxyUrl = trimmedValue;
      await this.plugin.saveSettings();
    }));
  }
  /**
   * 显示添加/编辑账号的模态框
   */
  showEditAccountModal(account) {
    const { Modal } = require("obsidian");
    const modal = new Modal(this.app);
    modal.titleEl.setText(account ? "\u7F16\u8F91\u8D26\u53F7" : "\u6DFB\u52A0\u8D26\u53F7");
    const form = modal.contentEl.createDiv();
    const nameGroup = form.createDiv({ cls: "wechat-form-group" });
    nameGroup.createEl("label", { text: "\u8D26\u53F7\u540D\u79F0" });
    const nameInput = nameGroup.createEl("input", {
      type: "text",
      placeholder: "\u4F8B\u5982\uFF1A\u6211\u7684\u516C\u4F17\u53F7",
      value: (account == null ? void 0 : account.name) || ""
    });
    const appIdGroup = form.createDiv({ cls: "wechat-form-group" });
    appIdGroup.createEl("label", { text: "AppID" });
    const appIdInput = appIdGroup.createEl("input", {
      type: "text",
      placeholder: "wx...",
      value: (account == null ? void 0 : account.appId) || ""
    });
    const secretGroup = form.createDiv({ cls: "wechat-form-group" });
    secretGroup.createEl("label", { text: "AppSecret" });
    const secretInput = secretGroup.createEl("input", {
      type: "password",
      placeholder: "\u5F00\u53D1\u8005\u5BC6\u94A5",
      value: (account == null ? void 0 : account.appSecret) || ""
    });
    const authorGroup = form.createDiv({ cls: "wechat-form-group" });
    authorGroup.createEl("label", { text: "\u9ED8\u8BA4\u4F5C\u8005\uFF08\u53EF\u9009\uFF09" });
    const authorInput = authorGroup.createEl("input", {
      type: "text",
      placeholder: "\u7559\u7A7A\u5219\u4E0D\u663E\u793A\u4F5C\u8005",
      value: (account == null ? void 0 : account.author) || ""
    });
    const btnRow = form.createDiv({ cls: "wechat-modal-buttons" });
    const cancelBtn = btnRow.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.onclick = () => modal.close();
    const testBtn = btnRow.createEl("button", { text: "\u6D4B\u8BD5\u8FDE\u63A5", cls: "wechat-btn-test" });
    testBtn.onclick = async () => {
      if (!appIdInput.value || !secretInput.value) {
        new Notice("\u8BF7\u586B\u5199 AppID \u548C AppSecret");
        return;
      }
      testBtn.disabled = true;
      testBtn.textContent = "\u6D4B\u8BD5\u4E2D...";
      try {
        const api = new WechatAPI(appIdInput.value.trim(), secretInput.value.trim(), this.plugin.settings.proxyUrl);
        await api.getAccessToken();
        new Notice("\u2705 \u8FDE\u63A5\u6210\u529F\uFF01");
      } catch (err) {
        new Notice(`\u274C \u8FDE\u63A5\u5931\u8D25: ${err.message}`);
      }
      testBtn.disabled = false;
      testBtn.textContent = "\u6D4B\u8BD5\u8FDE\u63A5";
    };
    const saveBtn = btnRow.createEl("button", { text: "\u4FDD\u5B58", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim() || "\u672A\u547D\u540D\u8D26\u53F7";
      const appId = appIdInput.value.trim();
      const appSecret = secretInput.value.trim();
      if (!appId || !appSecret) {
        new Notice("\u8BF7\u586B\u5199 AppID \u548C AppSecret");
        return;
      }
      if (account) {
        account.name = name;
        account.appId = appId;
        account.appSecret = appSecret;
        account.author = authorInput.value.trim();
      } else {
        const newAccount = {
          id: generateId(),
          name,
          appId,
          appSecret,
          author: authorInput.value.trim()
        };
        this.plugin.settings.wechatAccounts.push(newAccount);
        if (this.plugin.settings.wechatAccounts.length === 1) {
          this.plugin.settings.defaultAccountId = newAccount.id;
        }
      }
      await this.plugin.saveSettings();
      modal.close();
      this.display();
      new Notice(account ? "\u2705 \u8D26\u53F7\u5DF2\u66F4\u65B0" : "\u2705 \u8D26\u53F7\u5DF2\u6DFB\u52A0");
    };
    modal.open();
  }
};
var AppleStylePlugin = class extends Plugin {
  async onload() {
    console.log("\u{1F4DD} \u6B63\u5728\u52A0\u8F7D\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668...");
    await this.loadSettings();
    this.registerView(
      APPLE_STYLE_VIEW,
      (leaf) => new AppleStyleView(leaf, this)
    );
    this.addRibbonIcon("wand", "\u{1F4DD} \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668", async () => {
      await this.openConverter();
    });
    this.addCommand({
      id: "open-apple-converter",
      name: "\u6253\u5F00\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668",
      callback: async () => {
        await this.openConverter();
      }
    });
    this.addSettingTab(new AppleStyleSettingTab(this.app, this));
    console.log("\u2705 \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668\u52A0\u8F7D\u5B8C\u6210");
  }
  async openConverter() {
    let leaf = this.app.workspace.getLeavesOfType(APPLE_STYLE_VIEW)[0];
    if (!leaf) {
      const rightLeaf = this.app.workspace.getRightLeaf(false);
      await rightLeaf.setViewState({
        type: APPLE_STYLE_VIEW,
        active: true
      });
      leaf = rightLeaf;
    }
    this.app.workspace.revealLeaf(leaf);
  }
  getConverterView() {
    const leaves = this.app.workspace.getLeavesOfType(APPLE_STYLE_VIEW);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  async loadSettings() {
    const loadedData = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
    let didMigrate = false;
    if (this.settings.wechatAppId && this.settings.wechatAccounts.length === 0) {
      const migratedAccount = {
        id: generateId(),
        name: "\u6211\u7684\u516C\u4F17\u53F7",
        appId: this.settings.wechatAppId,
        appSecret: this.settings.wechatAppSecret
      };
      this.settings.wechatAccounts.push(migratedAccount);
      this.settings.defaultAccountId = migratedAccount.id;
      this.settings.wechatAppId = "";
      this.settings.wechatAppSecret = "";
      didMigrate = true;
      console.log("\u2705 \u5DF2\u5C06\u65E7\u8D26\u53F7\u914D\u7F6E\u8FC1\u79FB\u5230\u65B0\u683C\u5F0F");
    }
    const currentTemplate = normalizeVaultPath(this.settings.cleanupDirTemplate || "");
    const legacyRootDir = normalizeVaultPath(this.settings.cleanupRootDir || "");
    const legacyTarget = this.settings.cleanupTarget;
    if (!currentTemplate && legacyRootDir && legacyTarget === "folder") {
      this.settings.cleanupDirTemplate = `${legacyRootDir}/{{note}}_img`;
      didMigrate = true;
      console.log("\u2705 \u5DF2\u5C06\u65E7\u6E05\u7406\u914D\u7F6E\u8FC1\u79FB\u4E3A\u76EE\u5F55\u6A21\u677F cleanupDirTemplate");
    }
    if (Object.prototype.hasOwnProperty.call(this.settings, "cleanupRootDir")) {
      delete this.settings.cleanupRootDir;
      didMigrate = true;
    }
    if (Object.prototype.hasOwnProperty.call(this.settings, "cleanupTarget")) {
      delete this.settings.cleanupTarget;
      didMigrate = true;
    }
    if (!Object.prototype.hasOwnProperty.call(loadedData, "useTripletPipeline") && Object.prototype.hasOwnProperty.call(loadedData, "useNativePipeline")) {
      this.settings.useTripletPipeline = loadedData.useNativePipeline === true;
      didMigrate = true;
    }
    if (!Object.prototype.hasOwnProperty.call(loadedData, "tripletFallbackToPhase2") && Object.prototype.hasOwnProperty.call(loadedData, "enableLegacyFallback")) {
      this.settings.tripletFallbackToPhase2 = loadedData.enableLegacyFallback !== false;
      didMigrate = true;
    }
    if (!Object.prototype.hasOwnProperty.call(loadedData, "enforceTripletParity") && Object.prototype.hasOwnProperty.call(loadedData, "enforceNativeParity")) {
      this.settings.enforceTripletParity = loadedData.enforceNativeParity !== false;
      didMigrate = true;
    }
    this.settings.useNativePipeline = this.settings.useTripletPipeline === true;
    this.settings.enableLegacyFallback = this.settings.tripletFallbackToPhase2 !== false;
    this.settings.enforceNativeParity = this.settings.enforceTripletParity !== false;
    if (didMigrate) {
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    console.log("\u{1F4DD} \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668\u5DF2\u5378\u8F7D");
  }
};
module.exports = AppleStylePlugin;
module.exports.AppleStyleView = AppleStyleView;
module.exports.WechatAPI = WechatAPI;
module.exports.AppleStyleSettingTab = AppleStyleSettingTab;
