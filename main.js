/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/


// input.js
var { Plugin, MarkdownView, ItemView, Notice } = require("obsidian");
var { PluginSettingTab, Setting } = require("obsidian");
var APPLE_STYLE_VIEW = "apple-style-converter";
var DEFAULT_SETTINGS = {
  theme: "github",
  themeColor: "blue",
  customColor: "#0366d6",
  fontFamily: "sans-serif",
  fontSize: 3,
  macCodeBlock: true,
  codeLineNumber: true,
  avatarUrl: "",
  avatarBase64: "",
  // Base64 编码的本地头像，优先级高于 avatarUrl
  enableWatermark: false,
  showImageCaption: true,
  // 关闭水印时是否显示图片说明文字
  // 多账号支持
  wechatAccounts: [],
  // [{ id, name, appId, appSecret }]
  defaultAccountId: "",
  // 代理设置
  proxyUrl: "",
  // Cloudflare Worker 等代理地址
  // 预览设置
  usePhoneFrame: true,
  // 是否使用手机框预览
  // 排版设置
  sidePadding: 16,
  // 页面两侧留白 (px)
  // 旧字段保留用于迁移检测
  wechatAppId: "",
  wechatAppSecret: ""
};
var MAX_ACCOUNTS = 5;
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
async function pMap(array, mapper, concurrency = 3) {
  const results = [];
  const executing = [];
  let isFailed = false;
  for (const item of array) {
    if (isFailed)
      break;
    const p = Promise.resolve().then(() => mapper(item));
    results.push(p);
    const e = p.catch(() => {
      isFailed = true;
    }).then(() => executing.splice(executing.indexOf(e), 1));
    executing.push(e);
    if (executing.length >= concurrency) {
      await Promise.race(executing);
    }
  }
  return Promise.all(results);
}
var WechatAPI = class {
  constructor(appId, appSecret, proxyUrl = "") {
    this.appId = appId;
    this.appSecret = appSecret;
    this.proxyUrl = proxyUrl;
    this.accessToken = "";
    this.expireTime = 0;
  }
  /**
   * 通用重试机制 (仅处理网络层面的不稳定性)
   * 不再处理 Token 逻辑，专注于网络波动和配置错误
   */
  async requestWithRetry(operation, maxRetries = 3) {
    let lastError;
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        const isConfigError = error.message && (error.message.includes("(40013)") || // invalid appid
        error.message.includes("(40125)") || // invalid appsecret
        error.message.includes("invalid appid"));
        if (isConfigError) {
          console.warn(`[WechatAPI] Configuration error detected, aborting retry: ${error.message}`);
          throw error;
        }
        if (error.message && (error.message.includes("45009") || error.message.includes("reach max api daily quota limit"))) {
          const fatalError = new Error("\u5FAE\u4FE1\u63A5\u53E3\u4ECA\u65E5\u989D\u5EA6\u5DF2\u7528\u5B8C (45009)\uFF0C\u8BF7\u660E\u5929\u518D\u8BD5\u6216\u5207\u6362\u8D26\u53F7\u3002");
          fatalError.isFatal = true;
          throw fatalError;
        }
        if (error.message && (error.message.includes("45001") || error.message.includes("media size out of limit"))) {
          const fatalError = new Error("\u5FAE\u4FE1\u540E\u53F0\u7D20\u6750\u5E93\u5DF2\u6EE1 (45001)\u3002\u8BF7\u767B\u5F55\u5FAE\u4FE1\u516C\u4F17\u5E73\u53F0 -> \u7D20\u6750\u7BA1\u7406\uFF0C\u624B\u52A8\u5220\u9664\u65E7\u56FE\u7247\u4EE5\u91CA\u653E\u7A7A\u95F4\u3002");
          fatalError.isFatal = true;
          throw fatalError;
        }
        const isTokenError = error.message && (error.message.includes("40001") || error.message.includes("42001") || error.message.includes("40014"));
        if (isTokenError) {
          throw error;
        }
        const isBusinessError = error.message && error.message.includes("\u5FAE\u4FE1API\u62A5\u9519") && !error.message.includes("(-1)");
        if (isBusinessError) {
          console.warn(`[WechatAPI] Business logic error detected, aborting retry: ${error.message}`);
          throw error;
        }
        console.warn(`[WechatAPI] Network request failed (attempt ${i + 1}/${maxRetries}): ${error.message}`);
        if (i < maxRetries - 1) {
          await sleep(1e3 * (i + 1));
        }
      }
    }
    throw lastError;
  }
  /**
   * 高阶函数：执行带 Token 生命周期管理的操作
   * 负责：获取 Token -> 执行操作 -> 捕获 Token 过期错误 -> 刷新 Token -> 重试
   * @param {Function} action - 接收 token 参数的异步函数
   */
  async actionWithTokenRetry(action) {
    let retryCount = 0;
    const maxRetries = 1;
    while (true) {
      try {
        const token = await this.getAccessToken();
        return await action(token);
      } catch (error) {
        const isTokenExpired = error.message && (error.message.includes("40001") || error.message.includes("42001") || error.message.includes("40014"));
        if (isTokenExpired && retryCount < maxRetries) {
          console.warn(`[WechatAPI] Token expired (${error.message}), refreshing and retrying...`);
          this.accessToken = "";
          retryCount++;
          continue;
        }
        throw error;
      }
    }
  }
  /**
   * 发送请求（如果配置了代理，通过代理发送）
   * 纯粹的 HTTP 请求封装，不包含重试逻辑
   */
  async sendRequest(url, options = {}) {
    const { requestUrl } = require("obsidian");
    if (this.proxyUrl) {
      const proxyResponse = await requestUrl({
        url: this.proxyUrl,
        method: "POST",
        body: JSON.stringify({
          url,
          method: options.method || "GET",
          data: options.body ? JSON.parse(options.body) : void 0
        }),
        contentType: "application/json"
      });
      return proxyResponse.json;
    } else {
      const response = await requestUrl({ url, ...options });
      return response.json;
    }
  }
  async getAccessToken() {
    if (this.accessToken && Date.now() < this.expireTime - 3e5) {
      return this.accessToken;
    }
    const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${this.appId}&secret=${this.appSecret}`;
    const data = await this.requestWithRetry(() => this.sendRequest(url));
    if (data.access_token) {
      this.accessToken = data.access_token;
      this.expireTime = Date.now() + data.expires_in * 1e3;
      return this.accessToken;
    } else {
      throw new Error(`\u83B7\u53D6 Token \u5931\u8D25: ${data.errmsg || "\u672A\u77E5\u9519\u8BEF"} (${data.errcode || "??"})`);
    }
  }
  async uploadCover(blob) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=${token}&type=image`;
      return await this.uploadMultipart(url, blob, "media");
    });
  }
  async uploadImage(blob) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=${token}`;
      return await this.uploadMultipart(url, blob, "media");
    });
  }
  async createDraft(article) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/draft/add?access_token=${token}`;
      const data = await this.sendRequest(url, {
        method: "POST",
        body: JSON.stringify({ articles: [article] })
      });
      if (data.media_id) {
        return data;
      }
      throw new Error(`\u521B\u5EFA\u8349\u7A3F\u5931\u8D25: ${data.errmsg || JSON.stringify(data)} (${data.errcode || "N/A"})`);
    });
  }
  async uploadMultipart(url, blob, fieldName) {
    return this.requestWithRetry(async () => {
      const { requestUrl } = require("obsidian");
      const mimeType = blob.type || "image/jpeg";
      const ext = mimeType.includes("gif") ? "gif" : mimeType.includes("png") ? "png" : "jpg";
      if (this.proxyUrl) {
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        const base64Data = await new Promise((resolve, reject) => {
          reader.onload = () => resolve(reader.result.split(",")[1]);
          reader.onerror = reject;
        });
        const proxyResponse = await requestUrl({
          url: this.proxyUrl,
          method: "POST",
          body: JSON.stringify({
            url,
            method: "UPLOAD",
            // 特殊标记，告诉代理这是文件上传
            fileData: base64Data,
            fileName: `image.${ext}`,
            mimeType,
            fieldName
          }),
          contentType: "application/json"
        });
        const data = proxyResponse.json;
        if (data.media_id || data.url) {
          return data;
        } else {
          throw new Error(`\u5FAE\u4FE1API\u62A5\u9519: ${data.errmsg} (${data.errcode})`);
        }
      } else {
        const boundary = "----ObsidianWechatConverterBoundary" + Math.random().toString(36).substring(2);
        const arrayBuffer = await blob.arrayBuffer();
        const bytes = new Uint8Array(arrayBuffer);
        let header = `--${boundary}\r
`;
        header += `Content-Disposition: form-data; name="${fieldName}"; filename="image.${ext}"\r
`;
        header += `Content-Type: ${mimeType}\r
\r
`;
        const footer = `\r
--${boundary}--\r
`;
        const headerBytes = new TextEncoder().encode(header);
        const footerBytes = new TextEncoder().encode(footer);
        const bodyBytes = new Uint8Array(headerBytes.length + bytes.length + footerBytes.length);
        bodyBytes.set(headerBytes, 0);
        bodyBytes.set(bytes, headerBytes.length);
        bodyBytes.set(footerBytes, headerBytes.length + bytes.length);
        try {
          const response = await requestUrl({
            url,
            method: "POST",
            body: bodyBytes.buffer,
            headers: {
              "Content-Type": `multipart/form-data; boundary=${boundary}`
            }
          });
          const data = response.json;
          if (data.media_id || data.url) {
            return data;
          } else {
            throw new Error(`\u5FAE\u4FE1API\u62A5\u9519: ${data.errmsg} (${data.errcode})`);
          }
        } catch (error) {
          console.error("Upload Error:", error);
          throw new Error(`\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25: ${error.message}`);
        }
      }
    });
  }
};
var AppleStyleView = class extends ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.currentHtml = null;
    this.converter = null;
    this.theme = null;
    this.lastActiveFile = null;
    this.sessionCoverBase64 = "";
    this.sessionDigest = "";
    this.articleStates = /* @__PURE__ */ new Map();
    this.svgUploadCache = /* @__PURE__ */ new Map();
  }
  getViewType() {
    return APPLE_STYLE_VIEW;
  }
  getDisplayText() {
    return "\u{1F4DD} \u5FAE\u4FE1\u6392\u7248\u8F6C\u6362";
  }
  getIcon() {
    return "wand";
  }
  async onOpen() {
    console.log("\u{1F34E} \u8F6C\u6362\u5668\u9762\u677F\u6253\u5F00");
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("apple-converter-container");
    await this.loadDependencies();
    this.createSettingsPanel(container);
    const previewWrapper = container.createEl("div", {
      cls: `apple-preview-wrapper ${this.plugin.settings.usePhoneFrame ? "mode-phone" : "mode-classic"}`
    });
    if (this.plugin.settings.usePhoneFrame) {
      const phoneFrame = previewWrapper.createEl("div", { cls: "apple-phone-frame" });
      const header = phoneFrame.createEl("div", { cls: "apple-phone-header" });
      header.createEl("span", { cls: "title", text: "\u516C\u4F17\u53F7\u9884\u89C8" });
      header.createEl("span", { cls: "dots", text: "\u2022\u2022\u2022" });
      this.previewContainer = phoneFrame.createEl("div", {
        cls: "apple-converter-preview"
      });
      phoneFrame.createEl("div", { cls: "apple-home-indicator" });
    } else {
      this.previewContainer = previewWrapper.createEl("div", {
        cls: "apple-converter-preview"
      });
    }
    this.setPlaceholder();
    this.registerActiveFileChange();
    const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (activeView)
      this.registerScrollSync(activeView);
    setTimeout(async () => {
      const activeView2 = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (activeView2 && this.converter) {
        await this.convertCurrent(true);
      }
    }, 500);
  }
  /**
   * 监听活动文件切换
   */
  registerActiveFileChange() {
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", async () => {
        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (activeView && activeView.file) {
          this.lastActiveFile = activeView.file;
        }
        this.updateCurrentDoc();
        if (activeView) {
          this.registerScrollSync(activeView);
        }
        if (activeView && this.converter) {
          setTimeout(async () => {
            await this.convertCurrent(true);
          }, 300);
        }
      })
    );
    const debounce = (func, wait) => {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    };
    const debouncedConvert = debounce(async () => {
      if (!this.containerEl.offsetParent)
        return;
      const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (activeView && activeView.file && this.lastActiveFile && activeView.file.path === this.lastActiveFile.path) {
        await this.convertCurrent(true);
      }
    }, 500);
    this.registerEvent(
      this.app.workspace.on("editor-change", debouncedConvert)
    );
  }
  /**
   * 注册同步滚动 (双向: Editor <-> Preview)
   * 采用"原子锁"机制 + "差值检测"机制，彻底解决死循环和精度问题
   */
  registerScrollSync(activeView) {
    if (this.activeEditorScroller && this.editorScrollListener) {
      this.activeEditorScroller.removeEventListener("scroll", this.editorScrollListener);
    }
    if (this.previewContainer && this.previewScrollListener) {
      this.previewContainer.removeEventListener("scroll", this.previewScrollListener);
    }
    this.activeEditorScroller = null;
    this.editorScrollListener = null;
    this.previewScrollListener = null;
    this.ignoreNextPreviewScroll = false;
    this.ignoreNextEditorScroll = false;
    if (!activeView)
      return;
    const editorScroller = activeView.contentEl.querySelector(".cm-scroller");
    if (!editorScroller)
      return;
    this.activeEditorScroller = editorScroller;
    this.editorScrollListener = () => {
      if (!this.containerEl.offsetParent)
        return;
      if (this.ignoreNextEditorScroll) {
        this.ignoreNextEditorScroll = false;
        return;
      }
      if (!this.previewContainer)
        return;
      const editorHeight = editorScroller.scrollHeight - editorScroller.clientHeight;
      const previewHeight = this.previewContainer.scrollHeight - this.previewContainer.clientHeight;
      if (editorHeight <= 0 || previewHeight <= 0)
        return;
      let targetScrollTop;
      if (editorScroller.scrollTop === 0) {
        targetScrollTop = 0;
      } else if (Math.abs(editorScroller.scrollTop - editorHeight) < 2) {
        targetScrollTop = previewHeight;
      } else {
        const ratio = editorScroller.scrollTop / editorHeight;
        targetScrollTop = ratio * previewHeight;
      }
      if (Math.abs(this.previewContainer.scrollTop - targetScrollTop) > 1) {
        this.ignoreNextPreviewScroll = true;
        this.previewContainer.scrollTop = targetScrollTop;
      }
    };
    this.previewScrollListener = () => {
      if (!this.containerEl.offsetParent)
        return;
      if (this.ignoreNextPreviewScroll) {
        this.ignoreNextPreviewScroll = false;
        return;
      }
      const editorHeight = editorScroller.scrollHeight - editorScroller.clientHeight;
      const previewHeight = this.previewContainer.scrollHeight - this.previewContainer.clientHeight;
      if (editorHeight <= 0 || previewHeight <= 0)
        return;
      let targetScrollTop;
      if (this.previewContainer.scrollTop === 0) {
        targetScrollTop = 0;
      } else if (Math.abs(this.previewContainer.scrollTop - previewHeight) < 2) {
        targetScrollTop = editorHeight;
      } else {
        const ratio = this.previewContainer.scrollTop / previewHeight;
        targetScrollTop = ratio * editorHeight;
      }
      if (Math.abs(editorScroller.scrollTop - targetScrollTop) > 1) {
        this.ignoreNextEditorScroll = true;
        editorScroller.scrollTop = targetScrollTop;
      }
    };
    editorScroller.addEventListener("scroll", this.editorScrollListener, { passive: true });
    this.previewContainer.addEventListener("scroll", this.previewScrollListener, { passive: true });
  }
  /**
   * 加载依赖库
   */
  async loadDependencies() {
    const adapter = this.app.vault.adapter;
    const basePath = this.plugin.manifest.dir;
    try {
      if (typeof markdownit === "undefined") {
        const mdContent = await adapter.read(`${basePath}/lib/markdown-it.min.js`);
        (0, eval)(mdContent);
      }
      if (typeof hljs === "undefined") {
        const hljsContent = await adapter.read(`${basePath}/lib/highlight.min.js`);
        (0, eval)(hljsContent);
      }
      try {
        const mathPath = `${basePath}/lib/mathjax-plugin.js`;
        if (await adapter.exists(mathPath)) {
          const mathContent = await adapter.read(mathPath);
          (0, eval)(mathContent);
        } else {
        }
      } catch (e) {
        console.error("MathJax plugin load failed:", e);
      }
      const themeContent = await adapter.read(`${basePath}/themes/apple-theme.js`);
      (0, eval)(themeContent);
      const converterContent = await adapter.read(`${basePath}/converter.js`);
      (0, eval)(converterContent);
      if (!window.AppleTheme)
        throw new Error("AppleTheme failed to load");
      this.theme = new window.AppleTheme({
        theme: this.plugin.settings.theme,
        themeColor: this.plugin.settings.themeColor,
        customColor: this.plugin.settings.customColor,
        fontFamily: this.plugin.settings.fontFamily,
        fontSize: this.plugin.settings.fontSize,
        macCodeBlock: this.plugin.settings.macCodeBlock,
        codeLineNumber: this.plugin.settings.codeLineNumber,
        sidePadding: this.plugin.settings.sidePadding
        // 新增参数
      });
      if (!window.AppleStyleConverter)
        throw new Error("AppleStyleConverter failed to load");
      let avatarSrc = "";
      if (this.plugin.settings.enableWatermark) {
        avatarSrc = this.plugin.settings.avatarBase64 || this.plugin.settings.avatarUrl || "";
      }
      const showCaption = this.plugin.settings.showImageCaption;
      this.converter = new window.AppleStyleConverter(this.theme, avatarSrc, showCaption, this.app);
      await this.converter.initMarkdownIt();
      console.log("\u2705 \u4F9D\u8D56\u52A0\u8F7D\u5B8C\u6210");
    } catch (error) {
      console.error("\u274C \u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25:", error);
      new Notice("\u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 创建设置面板（重构为：顶部工具栏 + 悬浮设置层）
   */
  createSettingsPanel(container) {
    const { setIcon } = require("obsidian");
    const toolbar = container.createEl("div", { cls: "apple-top-toolbar" });
    this.currentDocLabel = toolbar.createEl("div", { cls: "apple-toolbar-title" });
    this.currentDocLabel.createDiv({ text: "\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668", cls: "apple-toolbar-plugin-name" });
    this.docTitleText = this.currentDocLabel.createDiv({ text: "\u672A\u9009\u62E9\u6587\u6863", cls: "apple-toolbar-doc-name" });
    const actions = toolbar.createEl("div", { cls: "apple-toolbar-actions" });
    const createIconBtn = (icon, title, onClick) => {
      const btn = actions.createEl("div", {
        cls: "apple-icon-btn",
        attr: { "aria-label": title }
        // Tooltip
      });
      setIcon(btn, icon);
      btn.addEventListener("click", onClick);
      return btn;
    };
    const settingsBtn = createIconBtn("sliders-horizontal", "\u6837\u5F0F\u8BBE\u7F6E", () => {
      this.settingsOverlay.classList.toggle("visible");
      settingsBtn.classList.toggle("active");
    });
    this.copyBtn = createIconBtn("copy", "\u590D\u5236\u5230\u516C\u4F17\u53F7", () => this.copyHTML());
    const accounts = this.plugin.settings.wechatAccounts || [];
    if (accounts.length > 0) {
      createIconBtn("send", "\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1", () => this.showSyncModal());
    }
    this.settingsOverlay = container.createEl("div", { cls: "apple-settings-overlay" });
    const settingsArea = this.settingsOverlay.createEl("div", { cls: "apple-settings-area" });
    this.createSection(settingsArea, "\u4E3B\u9898", (section) => {
      const grid = section.createEl("div", { cls: "apple-btn-grid" });
      const themes = AppleTheme.getThemeList();
      themes.forEach((t) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-theme ${this.plugin.settings.theme === t.value ? "active" : ""}`,
          text: t.label
        });
        btn.dataset.value = t.value;
        btn.addEventListener("click", () => this.onThemeChange(t.value, grid));
      });
    });
    this.createSection(settingsArea, "\u5B57\u4F53", (section) => {
      const select = section.createEl("select", { cls: "apple-select" });
      [
        { value: "sans-serif", label: "\u65E0\u886C\u7EBF" },
        { value: "serif", label: "\u886C\u7EBF" },
        { value: "monospace", label: "\u7B49\u5BBD" }
      ].forEach((opt) => {
        const option = select.createEl("option", { value: opt.value, text: opt.label });
        if (this.plugin.settings.fontFamily === opt.value)
          option.selected = true;
      });
      select.addEventListener("change", (e) => this.onFontFamilyChange(e.target.value));
    });
    this.createSection(settingsArea, "\u5B57\u53F7", (section) => {
      const grid = section.createEl("div", { cls: "apple-btn-row" });
      const sizes = [
        { value: "\u5C0F", label: "\u5C0F" },
        { value: "\u8F83\u5C0F", label: "\u8F83\u5C0F" },
        { value: "\u63A8\u8350", label: "\u63A8\u8350" },
        { value: "\u8F83\u5927", label: "\u8F83\u5927" },
        { value: "\u5927", label: "\u5927" }
      ];
      const sizeOpts = [
        { value: 1, label: "\u5C0F" },
        { value: 2, label: "\u8F83\u5C0F" },
        { value: 3, label: "\u63A8\u8350" },
        { value: 4, label: "\u8F83\u5927" },
        { value: 5, label: "\u5927" }
      ];
      sizeOpts.forEach((s) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-size ${this.plugin.settings.fontSize === s.value ? "active" : ""}`,
          text: s.label
        });
        btn.dataset.value = s.value;
        btn.addEventListener("click", () => this.onFontSizeChange(s.value, grid));
      });
    });
    this.createSection(settingsArea, "\u4E3B\u9898\u8272", (section) => {
      const grid = section.createEl("div", { cls: "apple-color-grid" });
      const colors = AppleTheme.getColorList();
      colors.forEach((c) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-color ${this.plugin.settings.themeColor === c.value ? "active" : ""}`
        });
        btn.dataset.value = c.value;
        btn.style.setProperty("--btn-color", c.color);
        btn.addEventListener("click", () => this.onColorChange(c.value, grid));
      });
      const customBtn = grid.createEl("button", {
        cls: `apple-btn-custom-text ${this.plugin.settings.themeColor === "custom" ? "active" : ""}`,
        text: "\u81EA\u5B9A\u4E49",
        title: "\u81EA\u5B9A\u4E49\u989C\u8272"
      });
      customBtn.dataset.value = "custom";
      const colorInput = grid.createEl("input", {
        type: "color",
        cls: "apple-color-picker-hidden"
      });
      colorInput.value = this.plugin.settings.customColor || "#000000";
      colorInput.style.visibility = "hidden";
      colorInput.style.width = "0";
      colorInput.style.height = "0";
      colorInput.style.position = "absolute";
      customBtn.addEventListener("click", () => {
        colorInput.click();
      });
      colorInput.addEventListener("input", (e) => {
        customBtn.style.setProperty("--btn-color", e.target.value);
      });
      colorInput.addEventListener("change", async (e) => {
        const newColor = e.target.value;
        customBtn.style.setProperty("--btn-color", newColor);
        this.plugin.settings.customColor = newColor;
        this.theme.update({ customColor: newColor });
        await this.onColorChange("custom", grid);
      });
    });
    this.createSection(settingsArea, "Mac \u98CE\u683C\u4EE3\u7801\u5757", (section) => {
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.macCodeBlock;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      checkbox.addEventListener("change", () => this.onMacCodeBlockChange(checkbox.checked));
    });
    this.createSection(settingsArea, "\u663E\u793A\u4EE3\u7801\u884C\u53F7", (section) => {
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.codeLineNumber;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      checkbox.addEventListener("change", () => this.onCodeLineNumberChange(checkbox.checked));
    });
    this.createSection(settingsArea, "\u9875\u9762\u4E24\u4FA7\u7559\u767D", (section) => {
      const container2 = section.createEl("div", {
        cls: "apple-slider-container",
        style: "width: 100%; display: flex; align-items: center; gap: 10px;"
      });
      const slider = container2.createEl("input", {
        type: "range",
        cls: "apple-slider",
        attr: { min: 0, max: 40, step: 1 }
      });
      slider.value = this.plugin.settings.sidePadding;
      slider.style.flex = "1";
      const valueLabel = container2.createEl("span", {
        text: `${this.plugin.settings.sidePadding}px`,
        style: "font-size: 12px; color: var(--apple-secondary); min-width: 32px; text-align: right;"
      });
      slider.addEventListener("input", async (e) => {
        const val = parseInt(e.target.value);
        valueLabel.setText(`${val}px`);
        this.plugin.settings.sidePadding = val;
        this.theme.update({ sidePadding: val });
        if (this.saveTimeout)
          clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(async () => {
          await this.plugin.saveSettings();
        }, 500);
        await this.convertCurrent(true);
      });
    });
    const captionSetting = new Setting(settingsArea).setName("\u663E\u793A\u56FE\u7247\u8BF4\u660E\u6587\u5B57").setDesc("\u5173\u95ED\u6C34\u5370\u65F6\uFF0C\u5728\u56FE\u7247\u4E0B\u65B9\u663E\u793A\u8BF4\u660E\u6587\u5B57").addToggle((toggle) => toggle.setValue(this.plugin.settings.showImageCaption).onChange(async (value) => {
      this.plugin.settings.showImageCaption = value;
      await this.plugin.saveSettings();
      if (this.converter) {
        this.converter.updateConfig({ showImageCaption: value });
        await this.convertCurrent(true);
      }
    }));
    if (this.plugin.settings.enableWatermark) {
      captionSetting.setDesc("\u56E0\u5168\u5C40\u8BBE\u7F6E\u4E2D\u5DF2\u5F00\u542F\u6C34\u5370\uFF0C\u6B64\u9009\u9879\u9ED8\u8BA4\u5F00\u542F");
      const toggleComp = captionSetting.components[0];
      toggleComp.setValue(true);
      toggleComp.setDisabled(true);
      if (toggleComp.toggleEl) {
        toggleComp.toggleEl.style.pointerEvents = "none";
        toggleComp.toggleEl.style.opacity = "0.6";
        toggleComp.toggleEl.style.filter = "grayscale(100%)";
      }
    }
  }
  /**
   * 创建账号选择器
   */
  createAccountSelector(parent) {
    const accounts = this.plugin.settings.wechatAccounts || [];
    if (accounts.length === 0)
      return;
    const section = parent.createEl("div", { cls: "apple-setting-section wechat-account-selector" });
    section.createEl("label", { cls: "apple-setting-label", text: "\u540C\u6B65\u8D26\u53F7" });
    const select = section.createEl("select", { cls: "wechat-account-select" });
    const defaultId = this.plugin.settings.defaultAccountId;
    for (const account of accounts) {
      const option = select.createEl("option", {
        value: account.id,
        text: account.id === defaultId ? `${account.name} (\u9ED8\u8BA4)` : account.name
      });
      if (account.id === defaultId) {
        option.selected = true;
      }
    }
    this.selectedAccountId = defaultId;
    select.addEventListener("change", (e) => {
      this.selectedAccountId = e.target.value;
    });
  }
  /**
   * 从文章内容中提取第一张图片作为封面
   */
  getFirstImageFromArticle() {
    if (!this.currentHtml)
      return null;
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.currentHtml;
    const imgs = Array.from(tempDiv.querySelectorAll("img"));
    for (const img of imgs) {
      if (img.alt === "logo")
        continue;
      if (img.src)
        return img.src;
    }
    return null;
  }
  /**
   * 创建设置区块
   */
  createSection(parent, label, builder) {
    const section = parent.createEl("div", { cls: "apple-setting-section" });
    section.createEl("label", { cls: "apple-setting-label", text: label });
    const content = section.createEl("div", { cls: "apple-setting-content" });
    builder(content);
  }
  /**
   * 显示同步选项 Modal
   */
  showSyncModal() {
    if (!this.currentHtml) {
      new Notice("\u26A0\uFE0F \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    const { Modal } = require("obsidian");
    const modal = new Modal(this.app);
    modal.titleEl.setText("\u540C\u6B65\u5230\u5FAE\u4FE1\u8349\u7A3F\u7BB1");
    modal.contentEl.addClass("wechat-sync-modal");
    const activeFile = this.app.workspace.getActiveFile();
    const currentPath = activeFile ? activeFile.path : null;
    let cachedState = null;
    if (currentPath && this.articleStates.has(currentPath)) {
      cachedState = this.articleStates.get(currentPath);
    }
    const accounts = this.plugin.settings.wechatAccounts || [];
    const defaultId = this.plugin.settings.defaultAccountId;
    let selectedAccountId = defaultId;
    let coverBase64 = (cachedState == null ? void 0 : cachedState.coverBase64) || this.getFirstImageFromArticle();
    this.sessionCoverBase64 = coverBase64;
    const accountSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    accountSection.createEl("label", { text: "\u8D26\u53F7", cls: "wechat-modal-label" });
    const accountSelect = accountSection.createEl("select", { cls: "wechat-account-select" });
    for (const account of accounts) {
      const option = accountSelect.createEl("option", {
        value: account.id,
        text: account.id === defaultId ? `${account.name} (\u9ED8\u8BA4)` : account.name
      });
      if (account.id === defaultId)
        option.selected = true;
    }
    accountSelect.addEventListener("change", (e) => {
      selectedAccountId = e.target.value;
    });
    const coverSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    coverSection.createEl("label", { text: "\u5C01\u9762\u56FE", cls: "wechat-modal-label" });
    const coverContent = coverSection.createDiv({ cls: "wechat-modal-cover-content" });
    const coverPreview = coverContent.createDiv({ cls: "wechat-modal-cover-preview" });
    const updatePreview = () => {
      coverPreview.empty();
      if (coverBase64) {
        coverPreview.createEl("img", { attr: { src: coverBase64 } });
        syncBtn.disabled = false;
        syncBtn.setText("\u5F00\u59CB\u540C\u6B65");
        syncBtn.removeClass("apple-btn-disabled");
      } else {
        coverPreview.createEl("div", {
          text: "\u6682\u65E0\u5C01\u9762",
          cls: "wechat-modal-no-cover"
        });
        syncBtn.disabled = true;
        syncBtn.setText("\u8BF7\u5148\u8BBE\u7F6E\u5C01\u9762");
        syncBtn.addClass("apple-btn-disabled");
      }
    };
    const coverBtns = coverContent.createDiv({ cls: "wechat-modal-cover-btns" });
    const uploadBtn = coverBtns.createEl("button", { text: "\u4E0A\u4F20" });
    const digestSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    digestSection.createEl("label", { text: "\u6587\u7AE0\u6458\u8981\uFF08\u53EF\u9009\uFF09", cls: "wechat-modal-label" });
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.currentHtml || "";
    const autoDigest = (tempDiv.textContent || "").replace(/\s+/g, " ").trim().substring(0, 45);
    const initialDigest = (cachedState == null ? void 0 : cachedState.digest) !== void 0 ? cachedState.digest : autoDigest;
    const digestInput = digestSection.createEl("textarea", {
      cls: "wechat-modal-digest-input",
      placeholder: "\u7559\u7A7A\u5219\u81EA\u52A8\u63D0\u53D6\u6587\u7AE0\u524D 45 \u5B57"
    });
    digestInput.value = initialDigest;
    digestInput.rows = 3;
    digestInput.style.width = "100%";
    digestInput.style.resize = "vertical";
    digestInput.maxLength = 120;
    const charCount = digestSection.createEl("div", {
      cls: "wechat-digest-count",
      text: `${digestInput.value.length}/120`,
      style: "text-align: right; font-size: 11px; color: var(--text-muted); margin-top: 4px; opacity: 0.7;"
    });
    digestInput.addEventListener("input", () => {
      charCount.setText(`${digestInput.value.length}/120`);
      if (currentPath) {
        const state = this.articleStates.get(currentPath) || {};
        state.digest = digestInput.value.trim();
        this.articleStates.set(currentPath, { ...state, digest: digestInput.value });
      }
    });
    const btnRow = modal.contentEl.createDiv({ cls: "wechat-modal-buttons" });
    const cancelBtn = btnRow.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.onclick = () => modal.close();
    const syncBtn = btnRow.createEl("button", { text: "\u5F00\u59CB\u540C\u6B65", cls: "mod-cta" });
    updatePreview();
    syncBtn.onclick = async () => {
      if (!coverBase64) {
        new Notice("\u274C \u8BF7\u5148\u8BBE\u7F6E\u5C01\u9762\u56FE");
        return;
      }
      modal.close();
      this.selectedAccountId = selectedAccountId;
      this.sessionCoverBase64 = coverBase64;
      this.sessionDigest = digestInput.value.trim() || autoDigest || "\u4E00\u952E\u540C\u6B65\u81EA Obsidian";
      await this.onSyncToWechat();
    };
    uploadBtn.onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file)
          return;
        const reader = new FileReader();
        reader.onload = (event) => {
          coverBase64 = event.target.result;
          this.sessionCoverBase64 = coverBase64;
          updatePreview();
          if (currentPath) {
            const state = this.articleStates.get(currentPath) || {};
            this.articleStates.set(currentPath, { ...state, coverBase64 });
          }
        };
        reader.readAsDataURL(file);
      };
      input.click();
    };
    modal.open();
  }
  /**
   * 处理同步到微信逻辑
   */
  async onSyncToWechat() {
    const accounts = this.plugin.settings.wechatAccounts || [];
    const accountId = this.selectedAccountId || this.plugin.settings.defaultAccountId;
    const account = accounts.find((a) => a.id === accountId);
    if (!account) {
      new Notice("\u274C \u8BF7\u5148\u5728\u63D2\u4EF6\u8BBE\u7F6E\u4E2D\u6DFB\u52A0\u5FAE\u4FE1\u516C\u4F17\u53F7\u8D26\u53F7");
      return;
    }
    if (!this.currentHtml) {
      new Notice("\u274C \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    const notice = new Notice(`\u{1F680} \u6B63\u5728\u4F7F\u7528 ${account.name} \u540C\u6B65...`, 0);
    try {
      const api = new WechatAPI(account.appId, account.appSecret, this.plugin.settings.proxyUrl);
      notice.setMessage("\u{1F5BC}\uFE0F \u6B63\u5728\u5904\u7406\u5C01\u9762\u56FE...");
      const coverSrc = this.sessionCoverBase64 || this.getFirstImageFromArticle();
      if (!coverSrc) {
        throw new Error("\u672A\u8BBE\u7F6E\u5C01\u9762\u56FE\uFF0C\u540C\u6B65\u5931\u8D25\u3002\u8BF7\u5728\u5F39\u7A97\u4E2D\u4E0A\u4F20\u5C01\u9762\u3002");
      }
      const coverBlob = await this.srcToBlob(coverSrc);
      const coverRes = await api.uploadCover(coverBlob);
      const thumb_media_id = coverRes.media_id;
      notice.setMessage("\u{1F4F8} \u6B63\u5728\u540C\u6B65\u6B63\u6587\u56FE\u7247...");
      let processedHtml = await this.processAllImages(this.currentHtml, api, (current, total) => {
        notice.setMessage(`\u{1F4F8} \u6B63\u5728\u540C\u6B65\u6B63\u6587\u56FE\u7247 (${current}/${total})...`);
      });
      if (processedHtml.includes("mjx-container") || processedHtml.includes("<svg")) {
        notice.setMessage("\u{1F9EE} \u6B63\u5728\u8F6C\u6362\u77E2\u91CF\u56FE/\u6570\u5B66\u516C\u5F0F...");
        processedHtml = await this.processMathFormulas(processedHtml, api, (current, total) => {
          notice.setMessage(`\u{1F9EE} \u6B63\u5728\u8F6C\u6362\u77E2\u91CF\u56FE/\u6570\u5B66\u516C\u5F0F (${current}/${total})...`);
        });
      }
      const cleanedHtml = this.cleanHtmlForDraft(processedHtml);
      const activeFile = this.app.workspace.getActiveFile();
      const title = activeFile ? activeFile.basename : "\u65E0\u6807\u9898\u6587\u7AE0";
      const base64Count = (cleanedHtml.match(/src=["']data:image/g) || []).length;
      if (base64Count > 0) {
        throw new Error(`\u68C0\u6D4B\u5230 ${base64Count} \u5F20\u56FE\u7247\u672A\u6210\u529F\u4E0A\u4F20\uFF08\u4ECD\u4E3A Base64 \u683C\u5F0F\uFF09\uFF0C\u8FD9\u4F1A\u5BFC\u81F4\u540C\u6B65\u5931\u8D25\u3002\u5EFA\u8BAE\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\u5E76\u91CD\u8BD5\u3002`);
      }
      notice.setMessage("\u{1F4DD} \u6B63\u5728\u53D1\u9001\u5230\u5FAE\u4FE1\u8349\u7A3F\u7BB1...");
      const article = {
        title: title.substring(0, 64),
        content: cleanedHtml,
        thumb_media_id,
        author: account.author || "",
        digest: this.sessionDigest || "\u4E00\u952E\u540C\u6B65\u81EA Obsidian"
      };
      await api.createDraft(article);
      notice.hide();
      new Notice("\u2705 \u540C\u6B65\u6210\u529F\uFF01\u8BF7\u524D\u5F80\u5FAE\u4FE1\u516C\u4F17\u53F7\u540E\u53F0\u8349\u7A3F\u7BB1\u67E5\u770B");
    } catch (error) {
      notice.hide();
      console.error("Wechat Sync Error:", error);
      let friendlyMsg = error.message;
      if (error.message.includes("45002")) {
        friendlyMsg = "\u6587\u7AE0\u592A\u957F\uFF0C\u5FAE\u4FE1\u63A5\u53E3\u62D2\u6536\u3002\u5EFA\u8BAE\u5206\u7BC7\u53D1\u9001\uFF0C\u6216\u4F7F\u7528\u63D2\u4EF6\u9876\u90E8\u7684\u300C\u590D\u5236\u300D\u6309\u94AE\u624B\u52A8\u7C98\u8D34\u5230\u516C\u4F17\u53F7\u540E\u53F0\u3002";
      }
      new Notice(`\u274C \u540C\u6B65\u5931\u8D25: ${friendlyMsg}`);
    }
  }
  /**
   * 将各种形式的 src (Base64, URL, 路径) 转为 Blob
   */
  async srcToBlob(src) {
    if (src.startsWith("data:")) {
      const resp = await fetch(src);
      return await resp.blob();
    }
    if (src.startsWith("app://") || src.startsWith("capacitor://")) {
      const resp = await fetch(src);
      return await resp.blob();
    }
    if (src.startsWith("http")) {
      const { requestUrl } = require("obsidian");
      const response = await requestUrl({ url: src });
      const contentType = response.headers["content-type"] || response.headers["Content-Type"] || "image/jpeg";
      return new Blob([response.arrayBuffer], { type: contentType });
    }
    throw new Error("\u4E0D\u652F\u6301\u7684\u56FE\u7247\u6765\u6E90\uFF0C\u8BF7\u5C1D\u8BD5\u91CD\u65B0\u4E0A\u4F20\u5C01\u9762");
  }
  /**
   * 处理 HTML 中的所有图片，上传到微信并替换链接
   * 支持并发上传 (Limit 3) 和进度回调
   */
  async processAllImages(html, api, progressCallback) {
    const div = document.createElement("div");
    div.innerHTML = html;
    const imgs = Array.from(div.querySelectorAll("img"));
    const uniqueUrls = /* @__PURE__ */ new Set();
    const urlMap = /* @__PURE__ */ new Map();
    for (const img of imgs) {
      if (img.src)
        uniqueUrls.add(img.src);
    }
    const total = uniqueUrls.size;
    let completed = 0;
    const tasks = Array.from(uniqueUrls);
    await pMap(tasks, async (src) => {
      try {
        const blob = await this.srcToBlob(src);
        const res = await api.uploadImage(blob);
        urlMap.set(src, res.url);
      } catch (error) {
        if (error.isFatal)
          throw error;
        console.error("\u56FE\u7247\u5904\u7406\u5931\u8D25\uFF0C\u5DF2\u8DF3\u8FC7:", src, error);
      }
      completed++;
      if (progressCallback) {
        progressCallback(completed, total);
      }
    }, 3);
    for (const img of imgs) {
      if (urlMap.has(img.src)) {
        img.src = urlMap.get(img.src);
      }
    }
    return div.innerHTML;
  }
  /**
   * 处理 HTML 中的数学公式 (MathJax SVG -> Wechat Image)
   * 解决微信接口内容长度限制问题
   */
  async processMathFormulas(html, api, progressCallback) {
    const container = document.createElement("div");
    container.style.position = "absolute";
    container.style.left = "-9999px";
    container.style.top = "0";
    container.style.width = "800px";
    container.innerHTML = html;
    document.body.appendChild(container);
    try {
      const mathNodes = Array.from(container.querySelectorAll("svg"));
      if (mathNodes.length === 0)
        return html;
      const total = mathNodes.length;
      let completed = 0;
      await pMap(mathNodes, async (svg) => {
        try {
          const svgStr = new XMLSerializer().serializeToString(svg);
          const styleAttr = svg.getAttribute("style") || "";
          const fillAttr = svg.getAttribute("fill") || "";
          const fingerprint = this.simpleHash(svgStr + styleAttr + fillAttr);
          let wechatUrl = "";
          let logicalWidth, logicalHeight, rawStyle;
          if (this.svgUploadCache.has(fingerprint)) {
            const cachedData = this.svgUploadCache.get(fingerprint);
            wechatUrl = cachedData.url;
            logicalWidth = cachedData.width;
            logicalHeight = cachedData.height;
            rawStyle = cachedData.style;
          } else {
            const result = await this.svgToPngBlob(svg);
            const res = await api.uploadImage(result.blob);
            wechatUrl = res.url;
            logicalWidth = result.width;
            logicalHeight = result.height;
            rawStyle = result.style;
            this.svgUploadCache.set(fingerprint, {
              url: wechatUrl,
              width: logicalWidth,
              height: logicalHeight,
              style: rawStyle
            });
          }
          const img = document.createElement("img");
          img.src = wechatUrl;
          img.className = "math-formula-image";
          if (logicalWidth)
            img.setAttribute("width", logicalWidth);
          if (logicalHeight)
            img.setAttribute("height", logicalHeight);
          let finalStyle = "display: inline-block; margin: 0 2px;";
          const svgStyle = svg.getAttribute("style");
          if (svgStyle)
            finalStyle += svgStyle;
          const parent = svg.parentElement;
          if (parent && parent.tagName.toLowerCase().includes("mjx")) {
            const parentStyle = parent.getAttribute("style");
            if (parentStyle)
              finalStyle += parentStyle;
            img.setAttribute("style", finalStyle);
            parent.replaceWith(img);
          } else {
            if (rawStyle)
              finalStyle += rawStyle;
            img.setAttribute("style", finalStyle);
            svg.replaceWith(img);
          }
          completed++;
          if (progressCallback)
            progressCallback(completed, total);
        } catch (error) {
          if (error.isFatal)
            throw error;
          console.error("\u516C\u5F0F\u8F6C\u6362\u5931\u8D25\uFF0C\u4FDD\u7559\u539FSVG:", error);
        }
      }, 3);
      return container.innerHTML;
    } finally {
      document.body.removeChild(container);
    }
  }
  /**
   * 将 SVG 元素转换为高分辨率 PNG Blob
   * 返回: { blob, width, height, style }
   */
  async svgToPngBlob(svgElement, scale = 3) {
    return new Promise((resolve, reject) => {
      try {
        const clonedSvg = svgElement.cloneNode(true);
        const rect = svgElement.getBoundingClientRect();
        let logicalWidth = rect.width;
        let logicalHeight = rect.height;
        const rawWidth = svgElement.getAttribute("width");
        const rawHeight = svgElement.getAttribute("height");
        const rawStyle = svgElement.getAttribute("style");
        if (logicalWidth === 0 || logicalHeight === 0) {
          logicalWidth = parseFloat(rawWidth) || 100;
          logicalHeight = parseFloat(rawHeight) || 20;
        }
        const isMathJax = svgElement.getAttribute("role") === "img" || svgElement.getAttribute("focusable") === "false" || svgElement.classList.contains("MathJax");
        if (isMathJax) {
          clonedSvg.setAttribute("fill", "#333333");
          clonedSvg.style.color = "#333333";
          clonedSvg.querySelectorAll("*").forEach((el) => {
            if (el.getAttribute("fill") === "currentColor" || !el.getAttribute("fill")) {
              el.setAttribute("fill", "#333333");
            }
            if (el.getAttribute("stroke") === "currentColor") {
              el.setAttribute("stroke", "#333333");
            }
          });
        }
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(clonedSvg);
        const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = logicalWidth * scale;
            canvas.height = logicalHeight * scale;
            const ctx = canvas.getContext("2d");
            ctx.scale(scale, scale);
            ctx.drawImage(img, 0, 0, logicalWidth, logicalHeight);
            URL.revokeObjectURL(url);
            canvas.toBlob((blob) => {
              if (blob) {
                resolve({
                  blob,
                  width: logicalWidth,
                  // 返回逻辑宽度 (例如 20.5)
                  height: logicalHeight,
                  style: rawStyle
                });
              } else
                reject(new Error("Canvas conversion failed"));
            }, "image/png");
          } catch (e) {
            reject(e);
          }
        };
        img.onerror = (e) => {
          URL.revokeObjectURL(url);
          reject(new Error("SVG Image load failed"));
        };
        img.src = url;
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * 清理 HTML 以适配微信编辑器
   * 微信编辑器对嵌套列表支持不佳，需要：
   * 1. 处理嵌套列表父级 li 内的段落与行内内容（避免嵌套层级被打散）
   * 2. 将深层嵌套列表转为伪列表（避免微信扁平化）
   * 3. 移除嵌套 ul/ol 的 margin（避免被当成独立块）
   * 4. 移除空的 li 元素和空白文本节点
   */
  cleanHtmlForDraft(html) {
    const div = document.createElement("div");
    div.innerHTML = html;
    div.querySelectorAll("li").forEach((li) => {
      const hasNestedList = li.querySelector("ul, ol");
      if (!hasNestedList)
        return;
      Array.from(li.children).forEach((child) => {
        if (child.tagName === "P") {
          while (child.firstChild) {
            li.insertBefore(child.firstChild, child);
          }
          child.remove();
        }
      });
      const firstList = Array.from(li.children).find((child) => child.tagName === "UL" || child.tagName === "OL");
      if (!firstList)
        return;
      const nodesBeforeList = [];
      for (let node = li.firstChild; node && node !== firstList; node = node.nextSibling) {
        nodesBeforeList.push(node);
      }
      const meaningfulNodes = nodesBeforeList.filter(
        (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
      );
      if (meaningfulNodes.length === 0)
        return;
      const blockTags = /* @__PURE__ */ new Set(["UL", "OL", "TABLE", "PRE", "BLOCKQUOTE", "SECTION", "FIGURE", "DIV"]);
      const hasBlock = meaningfulNodes.some(
        (node) => node.nodeType === Node.ELEMENT_NODE && blockTags.has(node.tagName)
      );
      if (hasBlock)
        return;
      const wrapper = document.createElement("span");
      const liStyle = li.getAttribute("style") || "";
      const lineHeightMatch = liStyle.match(/line-height:\s*[^;]+/i);
      const lineHeight = lineHeightMatch ? `${lineHeightMatch[0]};` : "";
      wrapper.setAttribute("style", `display:block;margin:0;padding:0;${lineHeight}`);
      meaningfulNodes.forEach((node) => wrapper.appendChild(node));
      li.insertBefore(wrapper, firstList);
    });
    const getListDepth = (list) => {
      let depth = 0;
      let current = list.parentElement;
      while (current) {
        if (current.tagName === "UL" || current.tagName === "OL")
          depth += 1;
        current = current.parentElement;
      }
      return depth;
    };
    const buildPseudoItems = (list, depth) => {
      const fragment = document.createDocumentFragment();
      const isOrdered = list.tagName === "OL";
      let index = 1;
      Array.from(list.children).forEach((li) => {
        if (li.tagName !== "LI")
          return;
        const nestedLists = Array.from(li.children).filter(
          (child) => child.tagName === "UL" || child.tagName === "OL"
        );
        const liStyle = li.getAttribute("style") || "";
        const indent = Math.max(0, depth - 1) * 20;
        const wrapper = document.createElement("p");
        wrapper.setAttribute(
          "style",
          `${liStyle} margin:0 0 4px ${indent}px; padding:0;`
        );
        const contentNodes = [];
        Array.from(li.childNodes).forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && (node.tagName === "UL" || node.tagName === "OL"))
            return;
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "P") {
            const children = Array.from(node.childNodes);
            if (children.length && contentNodes.length) {
              contentNodes.push(document.createTextNode(" "));
            }
            children.forEach((child) => contentNodes.push(child));
            return;
          }
          contentNodes.push(node);
        });
        while (contentNodes.length > 0 && contentNodes[0].nodeType === Node.TEXT_NODE && !contentNodes[0].textContent.trim()) {
          contentNodes.shift();
        }
        if (contentNodes.length > 0 && contentNodes[0].nodeType === Node.TEXT_NODE) {
          contentNodes[0].textContent = contentNodes[0].textContent.replace(/^\s+/, "");
          if (!contentNodes[0].textContent) {
            contentNodes.shift();
          }
        }
        const hasContent = contentNodes.some((node) => {
          if (node.nodeType === Node.TEXT_NODE)
            return node.textContent.trim();
          return true;
        });
        if (hasContent) {
          contentNodes.forEach((node) => {
            if (node.nodeType !== Node.TEXT_NODE)
              return;
            node.textContent = node.textContent.replace(/\s*\n\s*/g, " ").replace(/\s{2,}/g, " ");
            if (!node.textContent.trim()) {
              node.remove();
            }
          });
          const markerText = isOrdered ? `${index}. ` : "\u2022 ";
          const firstText = contentNodes.find((node) => node.nodeType === Node.TEXT_NODE && node.textContent.trim());
          if (firstText) {
            firstText.textContent = markerText + firstText.textContent;
          } else {
            contentNodes.unshift(document.createTextNode(markerText));
          }
          contentNodes.forEach((node) => wrapper.appendChild(node));
          fragment.appendChild(wrapper);
        }
        nestedLists.forEach((nested) => {
          fragment.appendChild(buildPseudoItems(nested, depth + 1));
        });
        index += 1;
      });
      return fragment;
    };
    Array.from(div.querySelectorAll("ul, ol")).forEach((list) => {
      if (!div.contains(list))
        return;
      const depth = getListDepth(list);
      if (depth < 2)
        return;
      const fragment = buildPseudoItems(list, depth);
      list.parentNode.insertBefore(fragment, list);
      list.remove();
    });
    div.querySelectorAll("li > ul, li > ol").forEach((nestedList) => {
      let style = nestedList.getAttribute("style") || "";
      style = style.replace(/margin(-[a-z]+)?:\s*[^;]+;?/gi, "");
      style = "margin: 0; " + style;
      nestedList.setAttribute("style", style);
    });
    div.querySelectorAll("li").forEach((li) => {
      if (!li.textContent.trim() && li.querySelectorAll("img, ul, ol").length === 0) {
        li.remove();
      }
    });
    div.querySelectorAll("ul, ol").forEach((list) => {
      Array.from(list.childNodes).forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) {
          node.remove();
        }
      });
    });
    div.querySelectorAll("li").forEach((li) => {
      Array.from(li.childNodes).forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) {
          node.remove();
        }
      });
    });
    return div.innerHTML;
  }
  // === 设置变更处理 ===
  async onThemeChange(value, grid) {
    this.plugin.settings.theme = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ theme: value });
    await this.convertCurrent(true);
  }
  async onFontFamilyChange(value) {
    this.plugin.settings.fontFamily = value;
    await this.plugin.saveSettings();
    this.theme.update({ fontFamily: value });
    await this.convertCurrent(true);
  }
  async onFontSizeChange(value, grid) {
    this.plugin.settings.fontSize = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ fontSize: value });
    await this.convertCurrent(true);
  }
  async onColorChange(value, grid) {
    this.plugin.settings.themeColor = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ themeColor: value });
    await this.convertCurrent(true);
  }
  async onMacCodeBlockChange(checked) {
    this.plugin.settings.macCodeBlock = checked;
    await this.plugin.saveSettings();
    this.theme.update({ macCodeBlock: checked });
    if (this.converter) {
      this.converter.reinit();
      await this.converter.initMarkdownIt();
    }
    await this.convertCurrent(true);
  }
  async onCodeLineNumberChange(checked) {
    this.plugin.settings.codeLineNumber = checked;
    await this.plugin.saveSettings();
    this.theme.update({ codeLineNumber: checked });
    if (this.converter) {
      this.converter.reinit();
      await this.converter.initMarkdownIt();
    }
    await this.convertCurrent(true);
  }
  updateButtonActive(grid, value) {
    grid.querySelectorAll("button").forEach((btn) => {
      btn.classList.toggle("active", btn.dataset.value == value);
    });
  }
  /**
   * 更新当前文档显示
   */
  updateCurrentDoc() {
    const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (activeView && this.docTitleText) {
      this.docTitleText.setText(activeView.file.basename);
      this.docTitleText.style.color = "var(--apple-primary)";
    } else if (this.lastActiveFile && this.docTitleText) {
      this.docTitleText.setText(this.lastActiveFile.basename);
      this.docTitleText.style.color = "var(--apple-primary)";
    } else if (this.docTitleText) {
      this.docTitleText.setText("\u672A\u9009\u62E9\u6587\u6863");
      this.docTitleText.style.color = "var(--apple-tertiary)";
    }
  }
  /**
   * 设置占位符
   */
  setPlaceholder() {
    this.previewContainer.empty();
    this.previewContainer.removeClass("apple-has-content");
    const placeholder = this.previewContainer.createEl("div", { cls: "apple-placeholder" });
    placeholder.createEl("div", { cls: "apple-placeholder-icon", text: "\u{1F4DD}" });
    placeholder.createEl("h2", { text: "\u5FAE\u4FE1\u516C\u4F17\u53F7\u6392\u7248\u8F6C\u6362\u5668" });
    placeholder.createEl("p", { text: "\u5C06 Markdown \u8F6C\u6362\u4E3A\u7CBE\u7F8E\u7684 HTML\uFF0C\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1" });
    const steps = placeholder.createEl("div", { cls: "apple-steps" });
    steps.createEl("div", { text: "1\uFE0F\u20E3 \u6253\u5F00\u9700\u8981\u8F6C\u6362\u7684 Markdown \u6587\u4EF6" });
    steps.createEl("div", { text: "2\uFE0F\u20E3 \u9884\u89C8\u533A\u4F1A\u81EA\u52A8\u663E\u793A\u8F6C\u6362\u6548\u679C" });
    steps.createEl("div", { text: "3\uFE0F\u20E3 \u70B9\u51FB\u300C\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1\u300D\u5373\u53EF\u53D1\u9001" });
    const note = placeholder.createEl("p", {
      text: "\u6CE8\u610F\uFF1A\u5982\u5F53\u524D\u5DF2\u6253\u5F00\u6587\u6863\u4F46\u672A\u663E\u793A\uFF0C\u8BF7\u91CD\u65B0\u70B9\u51FB\u4E00\u4E0B\u6587\u6863\u5373\u53EF\u89E6\u53D1",
      cls: "apple-placeholder-note"
    });
  }
  /**
   * 转换当前文档
   */
  async convertCurrent(silent = false) {
    let activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    let markdown = "";
    let sourcePath = "";
    if (!activeView && this.lastActiveFile) {
      try {
        markdown = await this.app.vault.read(this.lastActiveFile);
        sourcePath = this.lastActiveFile.path;
      } catch (error) {
        if (!silent)
          new Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u6587\u4EF6");
        return;
      }
    } else if (activeView) {
      markdown = activeView.editor.getValue();
      if (activeView.file)
        sourcePath = activeView.file.path;
    } else {
      if (!silent)
        new Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u6587\u4EF6");
      return;
    }
    if (!markdown.trim()) {
      if (!silent)
        new Notice("\u5F53\u524D\u6587\u4EF6\u5185\u5BB9\u4E3A\u7A7A");
      return;
    }
    try {
      if (!silent)
        new Notice("\u26A1 \u6B63\u5728\u8F6C\u6362...");
      if (this.converter)
        this.converter.updateSourcePath(sourcePath);
      const html = await this.converter.convert(markdown);
      this.currentHtml = html;
      this.sessionCoverBase64 = null;
      const scrollTop = this.previewContainer.scrollTop;
      this.previewContainer.innerHTML = html;
      this.previewContainer.scrollTop = scrollTop;
      this.previewContainer.addClass("apple-has-content");
      this.updateCurrentDoc();
      if (!silent)
        new Notice("\u2705 \u8F6C\u6362\u6210\u529F\uFF01");
    } catch (error) {
      console.error("\u8F6C\u6362\u5931\u8D25:", error);
      if (!silent)
        new Notice("\u274C \u8F6C\u6362\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 视图改变大小时触发 (包括侧边栏展开、Tab切换等导致的大小变化)
   */
  onResize() {
    super.onResize();
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    if (!this.containerEl.offsetParent)
      return;
    this.resizeTimeout = setTimeout(() => {
      this.convertCurrent(true);
    }, 300);
  }
  /**
   * 渲染 HTML
   */
  renderHTML(html) {
    this.previewContainer.empty();
    this.previewContainer.innerHTML = html;
  }
  /**
   * 复制 HTML
   */
  async copyHTML() {
    if (this.isCopying)
      return;
    if (!this.currentHtml) {
      new Notice("\u26A0\uFE0F \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    this.isCopying = true;
    if (this.copyBtn) {
      this.copyBtn.classList.add("active");
    }
    try {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = this.currentHtml;
      const images = Array.from(tempDiv.querySelectorAll("img"));
      const localImages = images.filter((img) => img.src.startsWith("app://"));
      if (localImages.length > 0) {
        new Notice("\u23F3 \u6B63\u5728\u5904\u7406\u56FE\u7247...");
      }
      const processed = await this.processImagesToDataURL(tempDiv);
      const cleanedHtml = this.cleanHtmlForDraft(tempDiv.innerHTML);
      const text = tempDiv.textContent || "";
      const htmlContent = cleanedHtml;
      if (navigator.clipboard && navigator.clipboard.write) {
        const clipboardItem = new ClipboardItem({
          "text/html": new Blob([htmlContent], { type: "text/html" }),
          "text/plain": new Blob([text], { type: "text/plain" })
        });
        await navigator.clipboard.write([clipboardItem]);
        new Notice("\u2705 \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\uFF01");
        if (this.copyBtn) {
          const { setIcon } = require("obsidian");
          setIcon(this.copyBtn, "check");
          setTimeout(() => {
            if (this.copyBtn) {
              setIcon(this.copyBtn, "copy");
              this.copyBtn.classList.remove("active");
            }
          }, 2e3);
        }
        return;
      }
      throw new Error("Clipboard API unavailable");
    } catch (error) {
      console.error("\u590D\u5236\u5931\u8D25:", error);
      new Notice(`\u274C \u590D\u5236\u5931\u8D25: ${error.message}`);
      if (this.copyBtn) {
        this.copyBtn.classList.remove("active");
      }
    } finally {
      this.isCopying = false;
    }
  }
  /**
   * 将 HTML 中的本地图片转换为 Base64 (Canvas Compressed)
   */
  async processImagesToDataURL(container) {
    const images = Array.from(container.querySelectorAll("img"));
    const localImages = images.filter((img) => img.src.startsWith("app://") || img.src.startsWith("capacitor://"));
    if (localImages.length === 0)
      return false;
    const startTime = Date.now();
    const concurrency = 3;
    for (let i = 0; i < localImages.length; i += concurrency) {
      const chunk = localImages.slice(i, i + concurrency);
      await Promise.all(chunk.map((img) => this.convertImageToLocally(img)));
    }
    const elapsed = Date.now() - startTime;
    const minDuration = 800;
    if (elapsed < minDuration) {
      await new Promise((resolve) => setTimeout(resolve, minDuration - elapsed));
    }
    return true;
  }
  async convertImageToLocally(img) {
    try {
      const response = await fetch(img.src);
      const blob = await response.blob();
      if (blob.size > 10 * 1024 * 1024) {
        new Notice(`\u26A0\uFE0F \u53D1\u73B0\u5927\u56FE (${(blob.size / 1024 / 1024).toFixed(1)}MB)\uFF0C\u5904\u7406\u53EF\u80FD\u8F83\u6162`, 5e3);
      }
      let dataUrl;
      if (blob.type === "image/gif") {
        dataUrl = await this.blobToDataUrl(blob);
      } else {
        dataUrl = await this.blobToJpegDataUrl(blob);
      }
      img.src = dataUrl;
      delete img.dataset.src;
    } catch (error) {
      console.error("Image processing failed:", error);
    }
  }
  // Helper: Direct Blob to Base64 (for GIFs)
  blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  blobToJpegDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(blob);
      const image = new Image();
      image.onload = () => {
        const canvas = document.createElement("canvas");
        let width = image.width;
        let height = image.height;
        if (width > 1920) {
          height = Math.round(height * (1920 / width));
          width = 1920;
        }
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, width, height);
        const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
        URL.revokeObjectURL(url);
        resolve(dataUrl);
      };
      image.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error("Image load failed"));
      };
      image.src = url;
    });
  }
  async onClose() {
    var _a;
    if (this.activeEditorScroller && this.editorScrollListener) {
      this.activeEditorScroller.removeEventListener("scroll", this.editorScrollListener);
    }
    if (this.previewContainer && this.previewScrollListener) {
      this.previewContainer.removeEventListener("scroll", this.previewScrollListener);
    }
    (_a = this.previewContainer) == null ? void 0 : _a.empty();
    if (this.articleStates) {
      this.articleStates.clear();
    }
    console.log("\u{1F34E} \u8F6C\u6362\u5668\u9762\u677F\u5DF2\u5173\u95ED");
  }
  /**
   * 简单的字符串哈希函数 (DJB2算法)
   */
  simpleHash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = hash * 33 ^ str.charCodeAt(i);
    }
    return hash >>> 0;
  }
};
var AppleStyleSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new Setting(containerEl).setDesc("\u66F4\u591A\u6392\u7248\u6837\u5F0F\u9009\u9879\uFF08\u4E3B\u9898\u3001\u5B57\u53F7\u3001\u4EE3\u7801\u5757\u7B49\uFF09\u8BF7\u5728\u63D2\u4EF6\u4FA7\u8FB9\u680F\u9762\u677F\u4E2D\u8FDB\u884C\u8BBE\u7F6E\u3002");
    new Setting(containerEl).setName("\u9884\u89C8\u6A21\u5F0F").setHeading();
    new Setting(containerEl).setName("\u4F7F\u7528\u624B\u673A\u4EFF\u771F\u6846").setDesc("\u5F00\u542F\u540E\uFF0C\u9884\u89C8\u533A\u57DF\u5C06\u663E\u793A\u4E3A iPhone X \u624B\u673A\u6846\u6837\u5F0F\uFF1B\u5173\u95ED\u5219\u6062\u590D\u4E3A\u7ECF\u5178\u5168\u5BBD\u9884\u89C8\u6A21\u5F0F\uFF08\u9700\u91CD\u542F\u63D2\u4EF6\u9762\u677F\u751F\u6548\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.usePhoneFrame).onChange(async (value) => {
      this.plugin.settings.usePhoneFrame = value;
      await this.plugin.saveSettings();
      new Notice("\u8BBE\u7F6E\u5DF2\u4FDD\u5B58\uFF0C\u8BF7\u5173\u95ED\u5E76\u91CD\u65B0\u6253\u5F00\u8F6C\u6362\u5668\u9762\u677F\u4EE5\u751F\u6548");
    }));
    new Setting(containerEl).setName("\u56FE\u7247\u6C34\u5370").setHeading();
    new Setting(containerEl).setName("\u542F\u7528\u56FE\u7247\u6C34\u5370").setDesc("\u5728\u6BCF\u5F20\u56FE\u7247\u4E0A\u65B9\u663E\u793A\u5934\u50CF").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWatermark).onChange(async (value) => {
      this.plugin.settings.enableWatermark = value;
      await this.plugin.saveSettings();
    }));
    const uploadSetting = new Setting(containerEl).setName("\u4E0A\u4F20\u672C\u5730\u5934\u50CF").setDesc(this.plugin.settings.avatarBase64 ? "\u2705 \u5DF2\u4E0A\u4F20\u672C\u5730\u5934\u50CF\uFF08\u4F18\u5148\u4F7F\u7528\uFF09" : "\u9009\u62E9\u672C\u5730\u56FE\u7247\uFF0C\u8F6C\u6362\u4E3A Base64 \u5B58\u50A8\uFF0C\u65E0\u9700\u7F51\u7EDC\u8BF7\u6C42");
    uploadSetting.addButton((button) => button.setButtonText(this.plugin.settings.avatarBase64 ? "\u91CD\u65B0\u4E0A\u4F20" : "\u9009\u62E9\u56FE\u7247").onClick(() => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file)
          return;
        if (file.size > 100 * 1024) {
          new Notice("\u274C \u56FE\u7247\u592A\u5927\uFF0C\u8BF7\u9009\u62E9\u5C0F\u4E8E 100KB \u7684\u56FE\u7247");
          return;
        }
        const reader = new FileReader();
        reader.onload = async (event) => {
          this.plugin.settings.avatarBase64 = event.target.result;
          await this.plugin.saveSettings();
          new Notice("\u2705 \u5934\u50CF\u5DF2\u4E0A\u4F20");
          this.display();
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }));
    if (this.plugin.settings.avatarBase64) {
      uploadSetting.addButton((button) => button.setButtonText("\u6E05\u9664").setWarning().onClick(async () => {
        this.plugin.settings.avatarBase64 = "";
        await this.plugin.saveSettings();
        new Notice("\u5DF2\u6E05\u9664\u672C\u5730\u5934\u50CF");
        this.display();
      }));
    }
    new Setting(containerEl).setName("\u5934\u50CF URL\uFF08\u5907\u7528\uFF09").setDesc("\u5982\u672A\u4E0A\u4F20\u672C\u5730\u5934\u50CF\uFF0C\u5C06\u4F7F\u7528\u6B64 URL").addText((text) => text.setPlaceholder("https://example.com/avatar.jpg").setValue(this.plugin.settings.avatarUrl).onChange(async (value) => {
      this.plugin.settings.avatarUrl = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u5FAE\u4FE1\u516C\u4F17\u53F7\u8D26\u53F7").setDesc("\u8BF7\u5728\u5FAE\u4FE1\u516C\u4F17\u53F7\u540E\u53F0 [\u8BBE\u7F6E\u4E0E\u5F00\u53D1] -> [\u57FA\u672C\u914D\u7F6E] \u4E2D\u83B7\u53D6 AppID \u548C AppSecret\uFF0C\u5E76\u786E\u4FDD\u5DF2\u5C06\u5F53\u524D IP \u52A0\u5165\u767D\u540D\u5355\u3002").setHeading();
    const accounts = this.plugin.settings.wechatAccounts || [];
    const defaultId = this.plugin.settings.defaultAccountId;
    if (accounts.length === 0) {
      containerEl.createEl("p", {
        text: "\u6682\u65E0\u8D26\u53F7\uFF0C\u8BF7\u70B9\u51FB\u4E0B\u65B9\u6309\u94AE\u6DFB\u52A0",
        cls: "setting-item-description",
        attr: { style: "color: var(--text-muted); font-style: italic;" }
      });
    } else {
      const listContainer = containerEl.createDiv({ cls: "wechat-account-list" });
      for (const account of accounts) {
        const isDefault = account.id === defaultId;
        const card = listContainer.createDiv({ cls: "wechat-account-card" });
        const info = card.createDiv({ cls: "wechat-account-info" });
        const nameRow = info.createDiv({ cls: "wechat-account-name-row" });
        nameRow.createSpan({ text: account.name, cls: "wechat-account-name" });
        if (isDefault) {
          nameRow.createSpan({ text: "\u9ED8\u8BA4", cls: "wechat-account-badge" });
        }
        info.createDiv({
          text: `AppID: ${account.appId.substring(0, 8)}...`,
          cls: "wechat-account-appid"
        });
        const actions = card.createDiv({ cls: "wechat-account-actions" });
        if (!isDefault) {
          const defaultBtn = actions.createEl("button", { text: "\u8BBE\u4E3A\u9ED8\u8BA4", cls: "wechat-btn-small" });
          defaultBtn.onclick = async () => {
            this.plugin.settings.defaultAccountId = account.id;
            await this.plugin.saveSettings();
            this.display();
          };
        }
        const editBtn = actions.createEl("button", { text: "\u7F16\u8F91", cls: "wechat-btn-small" });
        editBtn.onclick = () => this.showEditAccountModal(account);
        const testBtn = actions.createEl("button", { text: "\u6D4B\u8BD5", cls: "wechat-btn-small wechat-btn-test" });
        testBtn.onclick = async () => {
          testBtn.disabled = true;
          testBtn.textContent = "\u6D4B\u8BD5\u4E2D...";
          try {
            const api = new WechatAPI(account.appId, account.appSecret, this.plugin.settings.proxyUrl);
            await api.getAccessToken();
            new Notice(`\u2705 ${account.name} \u8FDE\u63A5\u6210\u529F\uFF01`);
          } catch (err) {
            new Notice(`\u274C ${account.name} \u8FDE\u63A5\u5931\u8D25: ${err.message}`);
          }
          testBtn.disabled = false;
          testBtn.textContent = "\u6D4B\u8BD5";
        };
        const deleteBtn = actions.createEl("button", { text: "\u5220\u9664", cls: "wechat-btn-small wechat-btn-danger" });
        deleteBtn.onclick = async () => {
          if (confirm(`\u786E\u5B9A\u8981\u5220\u9664\u8D26\u53F7 "${account.name}" \u5417\uFF1F`)) {
            this.plugin.settings.wechatAccounts = accounts.filter((a) => a.id !== account.id);
            if (account.id === defaultId && this.plugin.settings.wechatAccounts.length > 0) {
              this.plugin.settings.defaultAccountId = this.plugin.settings.wechatAccounts[0].id;
            } else if (this.plugin.settings.wechatAccounts.length === 0) {
              this.plugin.settings.defaultAccountId = "";
            }
            await this.plugin.saveSettings();
            this.display();
          }
        };
      }
    }
    const addBtnContainer = containerEl.createDiv({ cls: "wechat-add-account-container" });
    if (accounts.length < MAX_ACCOUNTS) {
      const addBtn = addBtnContainer.createEl("button", {
        text: "+ \u6DFB\u52A0\u8D26\u53F7",
        cls: "wechat-btn-add"
      });
      addBtn.onclick = () => this.showEditAccountModal(null);
    } else {
      addBtnContainer.createEl("p", {
        text: `\u5DF2\u8FBE\u5230\u6700\u5927\u8D26\u53F7\u6570\u91CF (${MAX_ACCOUNTS})`,
        cls: "setting-item-description",
        attr: { style: "color: var(--text-muted);" }
      });
    }
    new Setting(containerEl).setName("\u9AD8\u7EA7\u8BBE\u7F6E").setHeading();
    new Setting(containerEl).setName("API \u4EE3\u7406\u5730\u5740").setDesc(createFragment((frag) => {
      const descDiv = frag.createDiv();
      descDiv.appendText("\u5982\u679C\u4F60\u7684\u7F51\u7EDC IP \u7ECF\u5E38\u53D8\u5316\uFF0C\u53EF\u914D\u7F6E\u4EE3\u7406\u670D\u52A1\u3002");
      descDiv.createEl("a", {
        text: "\u67E5\u770B\u90E8\u7F72\u6307\u5357",
        href: "https://xiaoweibox.top/chats/wechat-proxy",
        style: "margin-left: 5px;"
      });
      frag.createDiv({
        cls: "wechat-proxy-note",
        style: "margin-top: 6px; font-size: 12px; color: var(--text-muted); background: var(--background-secondary); padding: 8px; border-radius: 4px;"
      }, (el) => {
        el.createSpan({ text: "\u{1F512} \u5B89\u5168\u63D0\u793A\uFF1A\u4EE3\u7406\u670D\u52A1\u5C06\u4E2D\u8F6C\u60A8\u7684\u8BF7\u6C42\u3002\u8BF7\u786E\u4FDD\u4F7F\u7528\u53D7\u4FE1\u4EFB\u7684\u4EE3\u7406\uFF08\u81EA\u5EFA\u6216\u53EF\u9760\u7B2C\u4E09\u65B9\uFF09\uFF0C\u4EE5\u4FDD\u62A4 AppSecret \u5B89\u5168\u3002" });
      });
    })).addText((text) => text.setPlaceholder("https://your-proxy.workers.dev").setValue(this.plugin.settings.proxyUrl).onChange(async (value) => {
      this.plugin.settings.proxyUrl = value.trim();
      await this.plugin.saveSettings();
    }));
  }
  /**
   * 显示添加/编辑账号的模态框
   */
  showEditAccountModal(account) {
    const { Modal } = require("obsidian");
    const modal = new Modal(this.app);
    modal.titleEl.setText(account ? "\u7F16\u8F91\u8D26\u53F7" : "\u6DFB\u52A0\u8D26\u53F7");
    const form = modal.contentEl.createDiv();
    const nameGroup = form.createDiv({ cls: "wechat-form-group" });
    nameGroup.createEl("label", { text: "\u8D26\u53F7\u540D\u79F0" });
    const nameInput = nameGroup.createEl("input", {
      type: "text",
      placeholder: "\u4F8B\u5982\uFF1A\u6211\u7684\u516C\u4F17\u53F7",
      value: (account == null ? void 0 : account.name) || ""
    });
    const appIdGroup = form.createDiv({ cls: "wechat-form-group" });
    appIdGroup.createEl("label", { text: "AppID" });
    const appIdInput = appIdGroup.createEl("input", {
      type: "text",
      placeholder: "wx...",
      value: (account == null ? void 0 : account.appId) || ""
    });
    const secretGroup = form.createDiv({ cls: "wechat-form-group" });
    secretGroup.createEl("label", { text: "AppSecret" });
    const secretInput = secretGroup.createEl("input", {
      type: "password",
      placeholder: "\u5F00\u53D1\u8005\u5BC6\u94A5",
      value: (account == null ? void 0 : account.appSecret) || ""
    });
    const authorGroup = form.createDiv({ cls: "wechat-form-group" });
    authorGroup.createEl("label", { text: "\u9ED8\u8BA4\u4F5C\u8005\uFF08\u53EF\u9009\uFF09" });
    const authorInput = authorGroup.createEl("input", {
      type: "text",
      placeholder: "\u7559\u7A7A\u5219\u4E0D\u663E\u793A\u4F5C\u8005",
      value: (account == null ? void 0 : account.author) || ""
    });
    const btnRow = form.createDiv({ cls: "wechat-modal-buttons" });
    const cancelBtn = btnRow.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.onclick = () => modal.close();
    const testBtn = btnRow.createEl("button", { text: "\u6D4B\u8BD5\u8FDE\u63A5", cls: "wechat-btn-test" });
    testBtn.onclick = async () => {
      if (!appIdInput.value || !secretInput.value) {
        new Notice("\u8BF7\u586B\u5199 AppID \u548C AppSecret");
        return;
      }
      testBtn.disabled = true;
      testBtn.textContent = "\u6D4B\u8BD5\u4E2D...";
      try {
        const api = new WechatAPI(appIdInput.value.trim(), secretInput.value.trim(), this.plugin.settings.proxyUrl);
        await api.getAccessToken();
        new Notice("\u2705 \u8FDE\u63A5\u6210\u529F\uFF01");
      } catch (err) {
        new Notice(`\u274C \u8FDE\u63A5\u5931\u8D25: ${err.message}`);
      }
      testBtn.disabled = false;
      testBtn.textContent = "\u6D4B\u8BD5\u8FDE\u63A5";
    };
    const saveBtn = btnRow.createEl("button", { text: "\u4FDD\u5B58", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim() || "\u672A\u547D\u540D\u8D26\u53F7";
      const appId = appIdInput.value.trim();
      const appSecret = secretInput.value.trim();
      if (!appId || !appSecret) {
        new Notice("\u8BF7\u586B\u5199 AppID \u548C AppSecret");
        return;
      }
      if (account) {
        account.name = name;
        account.appId = appId;
        account.appSecret = appSecret;
        account.author = authorInput.value.trim();
      } else {
        const newAccount = {
          id: generateId(),
          name,
          appId,
          appSecret,
          author: authorInput.value.trim()
        };
        this.plugin.settings.wechatAccounts.push(newAccount);
        if (this.plugin.settings.wechatAccounts.length === 1) {
          this.plugin.settings.defaultAccountId = newAccount.id;
        }
      }
      await this.plugin.saveSettings();
      modal.close();
      this.display();
      new Notice(account ? "\u2705 \u8D26\u53F7\u5DF2\u66F4\u65B0" : "\u2705 \u8D26\u53F7\u5DF2\u6DFB\u52A0");
    };
    modal.open();
  }
};
var AppleStylePlugin = class extends Plugin {
  async onload() {
    console.log("\u{1F4DD} \u6B63\u5728\u52A0\u8F7D\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668...");
    await this.loadSettings();
    this.registerView(
      APPLE_STYLE_VIEW,
      (leaf) => new AppleStyleView(leaf, this)
    );
    this.addRibbonIcon("wand", "\u{1F4DD} \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668", async () => {
      await this.openConverter();
    });
    this.addCommand({
      id: "open-apple-converter",
      name: "\u6253\u5F00\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668",
      callback: async () => {
        await this.openConverter();
      }
    });
    this.addSettingTab(new AppleStyleSettingTab(this.app, this));
    console.log("\u2705 \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668\u52A0\u8F7D\u5B8C\u6210");
  }
  async openConverter() {
    let leaf = this.app.workspace.getLeavesOfType(APPLE_STYLE_VIEW)[0];
    if (!leaf) {
      const rightLeaf = this.app.workspace.getRightLeaf(false);
      await rightLeaf.setViewState({
        type: APPLE_STYLE_VIEW,
        active: true
      });
      leaf = rightLeaf;
    }
    this.app.workspace.revealLeaf(leaf);
  }
  getConverterView() {
    const leaves = this.app.workspace.getLeavesOfType(APPLE_STYLE_VIEW);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (this.settings.wechatAppId && this.settings.wechatAccounts.length === 0) {
      const migratedAccount = {
        id: generateId(),
        name: "\u6211\u7684\u516C\u4F17\u53F7",
        appId: this.settings.wechatAppId,
        appSecret: this.settings.wechatAppSecret
      };
      this.settings.wechatAccounts.push(migratedAccount);
      this.settings.defaultAccountId = migratedAccount.id;
      this.settings.wechatAppId = "";
      this.settings.wechatAppSecret = "";
      await this.saveSettings();
      console.log("\u2705 \u5DF2\u5C06\u65E7\u8D26\u53F7\u914D\u7F6E\u8FC1\u79FB\u5230\u65B0\u683C\u5F0F");
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    console.log("\u{1F4DD} \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668\u5DF2\u5378\u8F7D");
  }
};
module.exports = AppleStylePlugin;
module.exports.AppleStyleView = AppleStyleView;
module.exports.WechatAPI = WechatAPI;
