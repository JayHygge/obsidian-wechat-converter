/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// services/parity-gate.js
var require_parity_gate = __commonJS({
  "services/parity-gate.js"(exports2, module2) {
    function isStrictHtmlParity(legacyHtml, candidateHtml) {
      return String(legacyHtml || "") === String(candidateHtml || "");
    }
    function findFirstDiffIndex(a, b) {
      const left = String(a || "");
      const right = String(b || "");
      const minLength = Math.min(left.length, right.length);
      for (let i = 0; i < minLength; i += 1) {
        if (left[i] !== right[i])
          return i;
      }
      if (left.length !== right.length)
        return minLength;
      return -1;
    }
    function buildParityMismatchDetails(legacyHtml, candidateHtml, contextLength = 80) {
      const left = String(legacyHtml || "");
      const right = String(candidateHtml || "");
      const index = findFirstDiffIndex(left, right);
      if (index === -1) {
        return {
          index: -1,
          legacySnippet: "",
          candidateSnippet: ""
        };
      }
      const start = Math.max(0, index - contextLength);
      const endLeft = Math.min(left.length, index + contextLength);
      const endRight = Math.min(right.length, index + contextLength);
      return {
        index,
        legacySnippet: left.slice(start, endLeft),
        candidateSnippet: right.slice(start, endRight)
      };
    }
    module2.exports = {
      isStrictHtmlParity,
      findFirstDiffIndex,
      buildParityMismatchDetails
    };
  }
});

// services/render-pipeline.js
var require_render_pipeline = __commonJS({
  "services/render-pipeline.js"(exports2, module2) {
    var { isStrictHtmlParity, buildParityMismatchDetails } = require_parity_gate();
    var LegacyRenderPipeline = class {
      constructor(converter) {
        this.converter = converter;
      }
      async renderForPreview(markdown, context = {}) {
        if (!this.converter || typeof this.converter.convert !== "function") {
          throw new Error("Legacy converter is not ready");
        }
        if (typeof this.converter.updateSourcePath === "function") {
          this.converter.updateSourcePath(context.sourcePath || "");
        }
        return this.converter.convert(markdown);
      }
      async renderForExport(markdown, context = {}) {
        return {
          html: await this.renderForPreview(markdown, context),
          diagnostics: []
        };
      }
    };
    var NativeRenderPipeline = class {
      constructor({ nativeRenderer, legacyPipeline, getFlags }) {
        this.nativeRenderer = nativeRenderer;
        this.legacyPipeline = legacyPipeline;
        this.getFlags = typeof getFlags === "function" ? getFlags : () => ({});
      }
      async renderForPreview(markdown, context = {}) {
        const flags = this.getFlags() || {};
        const strictParity = flags.enforceNativeParity === true;
        const parityTransform = typeof flags.parityTransform === "function" ? flags.parityTransform : null;
        if (typeof this.nativeRenderer !== "function") {
          if (flags.enableLegacyFallback !== false && this.legacyPipeline) {
            return this.legacyPipeline.renderForPreview(markdown, context);
          }
          throw new Error("Native render pipeline is not implemented yet");
        }
        try {
          const nativeHtml = await this.nativeRenderer(markdown, context);
          if (!strictParity || !this.legacyPipeline) {
            return nativeHtml;
          }
          const legacyHtml = await this.legacyPipeline.renderForPreview(markdown, context);
          const parityLegacyHtml = parityTransform ? parityTransform(legacyHtml, { markdown, context, pipeline: "legacy" }) : legacyHtml;
          const parityNativeHtml = parityTransform ? parityTransform(nativeHtml, { markdown, context, pipeline: "native" }) : nativeHtml;
          if (isStrictHtmlParity(parityLegacyHtml, parityNativeHtml)) {
            return nativeHtml;
          }
          const mismatch = buildParityMismatchDetails(parityLegacyHtml, parityNativeHtml);
          const parityError = new Error(
            `[RenderPipeline] Parity mismatch at index ${mismatch.index}`
          );
          parityError.code = "PARITY_MISMATCH";
          parityError.parity = mismatch;
          if (typeof flags.onParityMismatch === "function") {
            flags.onParityMismatch({
              markdown,
              context,
              mismatch
            });
          }
          if (flags.enableLegacyFallback !== false && this.legacyPipeline) {
            console.warn("[RenderPipeline] Native parity mismatch, fallback to legacy:", mismatch.index);
            return legacyHtml;
          }
          throw parityError;
        } catch (error) {
          if (flags.enableLegacyFallback !== false && this.legacyPipeline) {
            console.warn("[RenderPipeline] Native render failed, fallback to legacy:", (error == null ? void 0 : error.message) || error);
            return this.legacyPipeline.renderForPreview(markdown, context);
          }
          throw error;
        }
      }
      async renderForExport(markdown, context = {}) {
        return {
          html: await this.renderForPreview(markdown, context),
          diagnostics: []
        };
      }
    };
    function createRenderPipelines2({ converter, getFlags, nativeRenderer }) {
      const legacyPipeline = new LegacyRenderPipeline(converter);
      const nativePipeline = new NativeRenderPipeline({
        nativeRenderer,
        legacyPipeline,
        getFlags
      });
      return { legacyPipeline, nativePipeline };
    }
    module2.exports = {
      LegacyRenderPipeline,
      NativeRenderPipeline,
      createRenderPipelines: createRenderPipelines2
    };
  }
});

// services/dependency-loader.js
var require_dependency_loader = __commonJS({
  "services/dependency-loader.js"(exports2, module2) {
    function getAvatarSrc(settings = {}) {
      if (!settings.enableWatermark)
        return "";
      return settings.avatarBase64 || settings.avatarUrl || "";
    }
    function toThemeOptions(settings = {}) {
      return {
        theme: settings.theme,
        themeColor: settings.themeColor,
        customColor: settings.customColor,
        fontFamily: settings.fontFamily,
        fontSize: settings.fontSize,
        macCodeBlock: settings.macCodeBlock,
        codeLineNumber: settings.codeLineNumber,
        sidePadding: settings.sidePadding,
        coloredHeader: settings.coloredHeader
      };
    }
    async function ensureGlobalLibrary({ adapter, path, isReady, execute }) {
      if (isReady())
        return;
      const content = await adapter.read(path);
      execute(content);
    }
    async function loadConverterDependencies({ adapter, basePath, execute, logger = console }) {
      await ensureGlobalLibrary({
        adapter,
        path: `${basePath}/lib/markdown-it.min.js`,
        isReady: () => typeof markdownit !== "undefined",
        execute
      });
      await ensureGlobalLibrary({
        adapter,
        path: `${basePath}/lib/highlight.min.js`,
        isReady: () => typeof hljs !== "undefined",
        execute
      });
      try {
        const mathPath = `${basePath}/lib/mathjax-plugin.js`;
        if (await adapter.exists(mathPath)) {
          const mathContent = await adapter.read(mathPath);
          execute(mathContent);
        }
      } catch (error) {
        logger.error("MathJax plugin load failed:", error);
      }
      const themeContent = await adapter.read(`${basePath}/themes/apple-theme.js`);
      execute(themeContent);
      const converterContent = await adapter.read(`${basePath}/converter.js`);
      execute(converterContent);
      if (!window.AppleTheme)
        throw new Error("AppleTheme failed to load");
      if (!window.AppleStyleConverter)
        throw new Error("AppleStyleConverter failed to load");
    }
    async function buildRenderRuntime2({
      settings,
      app,
      adapter,
      basePath,
      execute = (code) => (0, eval)(code),
      logger = console
    }) {
      await loadConverterDependencies({ adapter, basePath, execute, logger });
      const theme = new window.AppleTheme(toThemeOptions(settings));
      const converter = new window.AppleStyleConverter(
        theme,
        getAvatarSrc(settings),
        settings.showImageCaption,
        app
      );
      await converter.initMarkdownIt();
      return { theme, converter };
    }
    module2.exports = {
      getAvatarSrc,
      toThemeOptions,
      loadConverterDependencies,
      buildRenderRuntime: buildRenderRuntime2
    };
  }
});

// services/markdown-source.js
var require_markdown_source = __commonJS({
  "services/markdown-source.js"(exports2, module2) {
    async function resolveMarkdownSource2({ app, lastActiveFile, MarkdownViewType }) {
      const activeView = app.workspace.getActiveViewOfType(MarkdownViewType);
      if (!activeView && lastActiveFile) {
        try {
          const markdown = await app.vault.read(lastActiveFile);
          return {
            ok: true,
            markdown,
            sourcePath: lastActiveFile.path || ""
          };
        } catch (error) {
          return {
            ok: false,
            reason: "NO_ACTIVE_FILE",
            error
          };
        }
      }
      if (activeView) {
        return {
          ok: true,
          markdown: activeView.editor.getValue(),
          sourcePath: activeView.file ? activeView.file.path : ""
        };
      }
      return {
        ok: false,
        reason: "NO_ACTIVE_FILE"
      };
    }
    module2.exports = {
      resolveMarkdownSource: resolveMarkdownSource2
    };
  }
});

// services/path-utils.js
var require_path_utils = __commonJS({
  "services/path-utils.js"(exports2, module2) {
    function normalizeVaultPath2(vaultPath) {
      if (typeof vaultPath !== "string")
        return "";
      return vaultPath.trim().replace(/\\/g, "/").replace(/\/{2,}/g, "/").replace(/^\/+/, "").replace(/\/+$/, "");
    }
    function isAbsolutePathLike2(vaultPath) {
      if (typeof vaultPath !== "string")
        return false;
      const trimmed = vaultPath.trim();
      if (!trimmed)
        return false;
      if (trimmed.startsWith("/"))
        return true;
      return /^[a-zA-Z]:[\\/]/.test(trimmed);
    }
    module2.exports = {
      normalizeVaultPath: normalizeVaultPath2,
      isAbsolutePathLike: isAbsolutePathLike2
    };
  }
});

// services/native-renderer.js
var require_native_renderer = __commonJS({
  "services/native-renderer.js"(exports2, module2) {
    function isSafeRawImageSrc(src) {
      if (!src || typeof src !== "string")
        return false;
      const trimmed = src.trim();
      if (!trimmed || trimmed.startsWith("#"))
        return false;
      const safeProtocols = ["http:", "https:", "data:", "app:", "capacitor:", "obsidian:"];
      try {
        const parsed = new URL(trimmed);
        return safeProtocols.includes(parsed.protocol);
      } catch (error) {
        return false;
      }
    }
    function preprocessMarkdownForNative(markdown) {
      if (typeof markdown !== "string" || markdown.length === 0)
        return "";
      let output = markdown;
      output = output.replace(/<(script|iframe|object|embed|form|input|button|style)\b[^>]*>[\s\S]*?<\/\1>/gi, "\n");
      output = output.replace(/<(script|iframe|object|embed|form|input|button|style)\b[^>]*\/?>/gi, "\n");
      output = output.replace(/<img\b[^>]*>/gi, (tag) => {
        const hasEventHandler = /\son\w+\s*=/.test(tag);
        const srcMatch = tag.match(/\bsrc\s*=\s*(?:"([^"]*)"|'([^']*)'|([^\s>]+))/i);
        const src = srcMatch ? srcMatch[1] || srcMatch[2] || srcMatch[3] || "" : "";
        if (hasEventHandler || !isSafeRawImageSrc(src)) {
          return "\n";
        }
        return tag;
      });
      return output;
    }
    function cleanupNativeRenderedHtml(html) {
      if (typeof document === "undefined" || typeof html !== "string" || html.length === 0) {
        return html;
      }
      const container = document.createElement("div");
      container.innerHTML = html;
      Array.from(container.querySelectorAll("img")).forEach((img) => {
        const inFigure = !!img.closest("figure");
        const isMathImage = img.classList.contains("math-formula-image");
        if (!inFigure && !isMathImage) {
          img.remove();
        }
      });
      return container.innerHTML;
    }
    async function renderNativeMarkdown2({ converter, markdown, sourcePath = "" }) {
      if (!converter || typeof converter.convert !== "function") {
        throw new Error("Native converter is not ready");
      }
      if (typeof converter.updateSourcePath === "function") {
        converter.updateSourcePath(sourcePath);
      }
      const preprocessed = preprocessMarkdownForNative(markdown);
      const html = await converter.convert(preprocessed);
      return cleanupNativeRenderedHtml(html);
    }
    module2.exports = {
      isSafeRawImageSrc,
      preprocessMarkdownForNative,
      cleanupNativeRenderedHtml,
      renderNativeMarkdown: renderNativeMarkdown2
    };
  }
});

// services/wechat-sync.js
var require_wechat_sync = __commonJS({
  "services/wechat-sync.js"(exports2, module2) {
    function createWechatSyncService2(deps) {
      const {
        createApi,
        srcToBlob,
        processAllImages,
        processMathFormulas,
        cleanHtmlForDraft,
        cleanupConfiguredDirectory,
        getFirstImageFromArticle
      } = deps;
      return {
        async syncToDraft({
          account,
          proxyUrl,
          currentHtml,
          activeFile,
          publishMeta,
          sessionCoverBase64,
          sessionDigest,
          onStatus,
          onImageProgress,
          onMathProgress
        }) {
          const api = createApi(account.appId, account.appSecret, proxyUrl);
          if (onStatus)
            onStatus("cover");
          const coverSrc = sessionCoverBase64 || publishMeta.coverSrc || getFirstImageFromArticle();
          if (!coverSrc) {
            throw new Error("\u672A\u8BBE\u7F6E\u5C01\u9762\u56FE\uFF0C\u540C\u6B65\u5931\u8D25\u3002\u8BF7\u5728\u5F39\u7A97\u4E2D\u4E0A\u4F20\u5C01\u9762\u3002");
          }
          const coverBlob = await srcToBlob(coverSrc);
          const coverRes = await api.uploadCover(coverBlob);
          const thumbMediaId = coverRes.media_id;
          if (onStatus)
            onStatus("images");
          let processedHtml = await processAllImages(currentHtml, api, (current, total) => {
            if (onImageProgress)
              onImageProgress(current, total);
          });
          if (processedHtml.includes("mjx-container") || processedHtml.includes("<svg")) {
            if (onStatus)
              onStatus("math");
            processedHtml = await processMathFormulas(processedHtml, api, (current, total) => {
              if (onMathProgress)
                onMathProgress(current, total);
            });
          }
          const cleanedHtml = cleanHtmlForDraft(processedHtml);
          const base64Count = (cleanedHtml.match(/src=["']data:image/g) || []).length;
          if (base64Count > 0) {
            throw new Error(`\u68C0\u6D4B\u5230 ${base64Count} \u5F20\u56FE\u7247\u672A\u6210\u529F\u4E0A\u4F20\uFF08\u4ECD\u4E3A Base64 \u683C\u5F0F\uFF09\uFF0C\u8FD9\u4F1A\u5BFC\u81F4\u540C\u6B65\u5931\u8D25\u3002\u5EFA\u8BAE\u68C0\u67E5\u7F51\u7EDC\u8FDE\u63A5\u5E76\u91CD\u8BD5\u3002`);
          }
          const title = activeFile ? activeFile.basename : "\u65E0\u6807\u9898\u6587\u7AE0";
          const article = {
            title: title.substring(0, 64),
            content: cleanedHtml,
            thumb_media_id: thumbMediaId,
            author: account.author || "",
            digest: sessionDigest || "\u4E00\u952E\u540C\u6B65\u81EA Obsidian"
          };
          if (onStatus)
            onStatus("draft");
          await api.createDraft(article);
          const cleanupResult = await cleanupConfiguredDirectory(activeFile);
          return {
            article,
            cleanupResult
          };
        }
      };
    }
    module2.exports = {
      createWechatSyncService: createWechatSyncService2
    };
  }
});

// services/sync-context.js
var require_sync_context = __commonJS({
  "services/sync-context.js"(exports2, module2) {
    function resolveSyncAccount2({ accounts, selectedAccountId, defaultAccountId }) {
      const list = Array.isArray(accounts) ? accounts : [];
      const accountId = selectedAccountId || defaultAccountId;
      return list.find((account) => account.id === accountId) || null;
    }
    function toSyncFriendlyMessage2(errorMessage = "") {
      if (errorMessage.includes("45002")) {
        return "\u6587\u7AE0\u592A\u957F\uFF0C\u5FAE\u4FE1\u63A5\u53E3\u62D2\u6536\u3002\u5EFA\u8BAE\u5206\u7BC7\u53D1\u9001\uFF0C\u6216\u4F7F\u7528\u63D2\u4EF6\u9876\u90E8\u7684\u300C\u590D\u5236\u300D\u6309\u94AE\u624B\u52A8\u7C98\u8D34\u5230\u516C\u4F17\u53F7\u540E\u53F0\u3002";
      }
      return errorMessage;
    }
    module2.exports = {
      resolveSyncAccount: resolveSyncAccount2,
      toSyncFriendlyMessage: toSyncFriendlyMessage2
    };
  }
});

// services/wechat-media.js
var require_wechat_media = __commonJS({
  "services/wechat-media.js"(exports2, module2) {
    async function processAllImages({ html, api, progressCallback, pMap: pMap2, srcToBlob }) {
      const div = document.createElement("div");
      div.innerHTML = html;
      const imgs = Array.from(div.querySelectorAll("img"));
      const uniqueUrls = /* @__PURE__ */ new Set();
      const urlMap = /* @__PURE__ */ new Map();
      for (const img of imgs) {
        if (img.src)
          uniqueUrls.add(img.src);
      }
      const total = uniqueUrls.size;
      let completed = 0;
      const tasks = Array.from(uniqueUrls);
      await pMap2(tasks, async (src) => {
        try {
          const blob = await srcToBlob(src);
          const res = await api.uploadImage(blob);
          urlMap.set(src, res.url);
        } catch (error) {
          if (error.isFatal)
            throw error;
          console.error("\u56FE\u7247\u5904\u7406\u5931\u8D25\uFF0C\u5DF2\u8DF3\u8FC7:", src, error);
        }
        completed++;
        if (progressCallback) {
          progressCallback(completed, total);
        }
      }, 3);
      for (const img of imgs) {
        if (urlMap.has(img.src)) {
          img.src = urlMap.get(img.src);
        }
      }
      return div.innerHTML;
    }
    async function processMathFormulas({
      html,
      api,
      progressCallback,
      pMap: pMap2,
      simpleHash,
      svgUploadCache,
      svgToPngBlob
    }) {
      const container = document.createElement("div");
      container.style.position = "absolute";
      container.style.left = "-9999px";
      container.style.top = "0";
      container.style.width = "800px";
      container.innerHTML = html;
      document.body.appendChild(container);
      try {
        const mathNodes = Array.from(container.querySelectorAll("svg"));
        if (mathNodes.length === 0)
          return html;
        const total = mathNodes.length;
        let completed = 0;
        await pMap2(mathNodes, async (svg) => {
          try {
            const svgStr = new XMLSerializer().serializeToString(svg);
            const styleAttr = svg.getAttribute("style") || "";
            const fillAttr = svg.getAttribute("fill") || "";
            const fingerprint = simpleHash(svgStr + styleAttr + fillAttr);
            let wechatUrl = "";
            let logicalWidth, logicalHeight, rawStyle;
            if (svgUploadCache.has(fingerprint)) {
              const cachedData = svgUploadCache.get(fingerprint);
              wechatUrl = cachedData.url;
              logicalWidth = cachedData.width;
              logicalHeight = cachedData.height;
              rawStyle = cachedData.style;
            } else {
              const result = await svgToPngBlob(svg);
              const res = await api.uploadImage(result.blob);
              wechatUrl = res.url;
              logicalWidth = result.width;
              logicalHeight = result.height;
              rawStyle = result.style;
              svgUploadCache.set(fingerprint, {
                url: wechatUrl,
                width: logicalWidth,
                height: logicalHeight,
                style: rawStyle
              });
            }
            const img = document.createElement("img");
            img.src = wechatUrl;
            img.className = "math-formula-image";
            if (logicalWidth)
              img.setAttribute("width", logicalWidth);
            if (logicalHeight)
              img.setAttribute("height", logicalHeight);
            let finalStyle = "display: inline-block; margin: 0 2px;";
            const svgStyle = svg.getAttribute("style");
            if (svgStyle)
              finalStyle += svgStyle;
            const parent = svg.parentElement;
            if (parent && parent.tagName.toLowerCase().includes("mjx")) {
              const parentStyle = parent.getAttribute("style");
              if (parentStyle)
                finalStyle += parentStyle;
              img.setAttribute("style", finalStyle);
              parent.replaceWith(img);
            } else {
              if (rawStyle)
                finalStyle += rawStyle;
              img.setAttribute("style", finalStyle);
              svg.replaceWith(img);
            }
            completed++;
            if (progressCallback)
              progressCallback(completed, total);
          } catch (error) {
            if (error.isFatal)
              throw error;
            console.error("\u516C\u5F0F\u8F6C\u6362\u5931\u8D25\uFF0C\u4FDD\u7559\u539FSVG:", error);
          }
        }, 3);
        return container.innerHTML;
      } finally {
        document.body.removeChild(container);
      }
    }
    module2.exports = {
      processAllImages,
      processMathFormulas
    };
  }
});

// services/wechat-html-cleaner.js
var require_wechat_html_cleaner = __commonJS({
  "services/wechat-html-cleaner.js"(exports2, module2) {
    function cleanHtmlForDraft(html) {
      const div = document.createElement("div");
      div.innerHTML = html;
      const getInlineLabelPrefixInfo = (container) => {
        if (!container)
          return null;
        const nodes = Array.from(container.childNodes);
        const firstElementIdx = nodes.findIndex((node) => node.nodeType === Node.ELEMENT_NODE);
        if (firstElementIdx === -1)
          return null;
        const hasOnlyWhitespaceBefore = nodes.slice(0, firstElementIdx).every((node) => node.nodeType === Node.TEXT_NODE && !node.textContent.trim());
        if (!hasOnlyWhitespaceBefore)
          return null;
        const firstElement = nodes[firstElementIdx];
        if (!["STRONG", "CODE"].includes(firstElement.tagName))
          return null;
        const elementText = (firstElement.textContent || "").trim();
        if (/[：:]$/.test(elementText)) {
          return { firstElementIdx, prefixEndIdx: firstElementIdx };
        }
        const nextNode = nodes[firstElementIdx + 1];
        if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
          const nextText = nextNode.textContent || "";
          if (/^\s*[：:]/.test(nextText)) {
            return { firstElementIdx, prefixEndIdx: firstElementIdx + 1 };
          }
        }
        return null;
      };
      const hasInlineLabelPrefix = (container) => !!getInlineLabelPrefixInfo(container);
      const collapseLabelBreakInParagraph = (paragraph) => {
        const prefixInfo = getInlineLabelPrefixInfo(paragraph);
        if (!prefixInfo)
          return;
        const nodes = Array.from(paragraph.childNodes);
        const startIdx = prefixInfo.prefixEndIdx + 1;
        if (prefixInfo.prefixEndIdx > prefixInfo.firstElementIdx) {
          const colonNode = nodes[prefixInfo.prefixEndIdx];
          if (colonNode && colonNode.nodeType === Node.TEXT_NODE) {
            colonNode.textContent = (colonNode.textContent || "").replace(/^\s*([：:])\s*/, "$1 ");
          }
        }
        let sawBreak = false;
        for (let i = startIdx; i < nodes.length; i += 1) {
          const node = nodes[i];
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "BR") {
            node.remove();
            sawBreak = true;
            continue;
          }
          if (node.nodeType === Node.TEXT_NODE) {
            if (!node.textContent.trim())
              continue;
            const hasLeadingWhitespace = /^\s+/.test(node.textContent);
            if (sawBreak || hasLeadingWhitespace) {
              node.textContent = node.textContent.replace(/^\s+/, " ");
            }
            return;
          }
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (sawBreak)
              paragraph.insertBefore(document.createTextNode(" "), node);
            return;
          }
        }
      };
      const isInlineOnlyParagraph = (paragraph) => {
        if (!paragraph)
          return false;
        const blockLikeTags = /* @__PURE__ */ new Set(["UL", "OL", "TABLE", "PRE", "BLOCKQUOTE", "SECTION", "FIGURE", "DIV", "P"]);
        return !Array.from(paragraph.querySelectorAll("*")).some((el) => blockLikeTags.has(el.tagName));
      };
      const unwrapSimpleListParagraphs = (li) => {
        const hasDirectNestedList = Array.from(li.children).some((child) => child.tagName === "UL" || child.tagName === "OL");
        if (hasDirectNestedList)
          return;
        const meaningfulChildren = Array.from(li.childNodes).filter(
          (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
        );
        if (meaningfulChildren.length === 0)
          return;
        const allInlineParagraphs = meaningfulChildren.every(
          (node) => node.nodeType === Node.ELEMENT_NODE && node.tagName === "P" && isInlineOnlyParagraph(node)
        );
        if (!allInlineParagraphs)
          return;
        const fragment = document.createDocumentFragment();
        meaningfulChildren.forEach((paragraph, index) => {
          while (paragraph.firstChild) {
            fragment.appendChild(paragraph.firstChild);
          }
          if (index < meaningfulChildren.length - 1) {
            fragment.appendChild(document.createTextNode(" "));
          }
        });
        while (li.firstChild) {
          li.removeChild(li.firstChild);
        }
        li.appendChild(fragment);
      };
      const collapseLabelBreakInListItem = (li) => {
        const prefixInfo = getInlineLabelPrefixInfo(li);
        if (!prefixInfo)
          return;
        const nodes = Array.from(li.childNodes);
        const startIdx = prefixInfo.prefixEndIdx + 1;
        if (prefixInfo.prefixEndIdx > prefixInfo.firstElementIdx) {
          const colonNode = nodes[prefixInfo.prefixEndIdx];
          if (colonNode && colonNode.nodeType === Node.TEXT_NODE) {
            colonNode.textContent = (colonNode.textContent || "").replace(/^\s*([：:])\s*/, "$1 ");
          }
        }
        let sawBreak = false;
        for (let i = startIdx; i < nodes.length; i += 1) {
          const node = nodes[i];
          if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "BR") {
            node.remove();
            sawBreak = true;
            continue;
          }
          if (node.nodeType === Node.TEXT_NODE) {
            if (!node.textContent.trim())
              continue;
            const hasLeadingWhitespace = /^\s+/.test(node.textContent);
            if (sawBreak || hasLeadingWhitespace) {
              node.textContent = node.textContent.replace(/^\s+/, " ");
            }
            return;
          }
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (sawBreak)
              li.insertBefore(document.createTextNode(" "), node);
            return;
          }
        }
      };
      const convertLeadingStrongOrCodeToSpan = (li) => {
        const getFirstMeaningfulNode = (container) => {
          if (!container)
            return null;
          return Array.from(container.childNodes).find(
            (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
          ) || null;
        };
        let firstNode = getFirstMeaningfulNode(li);
        if (!firstNode)
          return;
        if (firstNode.nodeType === Node.ELEMENT_NODE && firstNode.tagName === "P") {
          firstNode = getFirstMeaningfulNode(firstNode);
        }
        if (!firstNode || firstNode.nodeType !== Node.ELEMENT_NODE)
          return;
        if (!["STRONG", "CODE"].includes(firstNode.tagName))
          return;
        const span = document.createElement("span");
        const currentStyle = firstNode.getAttribute("style") || "";
        const cleanedStyle = currentStyle.replace(/display\s*:\s*[^;]+;?/gi, "").replace(/width\s*:\s*[^;]+;?/gi, "").replace(/float\s*:\s*[^;]+;?/gi, "").trim();
        const normalizedStyle = cleanedStyle ? `${cleanedStyle}${cleanedStyle.trim().endsWith(";") ? "" : ";"}` : "";
        const extraStyle = firstNode.tagName === "CODE" ? " margin:0 2px !important; vertical-align:baseline;" : "";
        span.setAttribute("style", `${normalizedStyle}display:inline !important; width:auto !important; float:none !important;${extraStyle}`);
        span.innerHTML = firstNode.innerHTML;
        firstNode.replaceWith(span);
      };
      const wrapLeadingLabelInBlockSpan = (li) => {
        const hasDirectNestedList = Array.from(li.children).some((child) => child.tagName === "UL" || child.tagName === "OL");
        if (hasDirectNestedList)
          return;
        const nodes = Array.from(li.childNodes).filter(
          (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
        );
        if (nodes.length < 2)
          return;
        const firstNode = nodes[0];
        if (firstNode.nodeType !== Node.ELEMENT_NODE)
          return;
        if (firstNode.tagName !== "SPAN")
          return;
        const firstText = (firstNode.textContent || "").trim();
        const secondNode = nodes[1];
        const secondText = secondNode.nodeType === Node.TEXT_NODE ? secondNode.textContent || "" : "";
        const hasColon = /[：:]$/.test(firstText) || /^\s*[：:]/.test(secondText);
        if (!hasColon)
          return;
        const wrapper = document.createElement("span");
        const liStyle = li.getAttribute("style") || "";
        const lineHeightMatch = liStyle.match(/line-height:\s*[^;]+/i);
        const lineHeight = lineHeightMatch ? `${lineHeightMatch[0]};` : "";
        wrapper.setAttribute("style", `display:block;margin:0;padding:0;${lineHeight}`);
        while (li.firstChild) {
          wrapper.appendChild(li.firstChild);
        }
        li.appendChild(wrapper);
      };
      const mergeLabelParagraphs = (li) => {
        const directParagraphs = Array.from(li.children).filter((child) => child.tagName === "P");
        if (directParagraphs.length < 2)
          return;
        if (!hasInlineLabelPrefix(directParagraphs[0]))
          return;
        if (!isInlineOnlyParagraph(directParagraphs[0]) || !isInlineOnlyParagraph(directParagraphs[1]))
          return;
        const first = directParagraphs[0];
        const second = directParagraphs[1];
        if (!second.textContent || !second.textContent.trim())
          return;
        while (second.firstChild && second.firstChild.nodeType === Node.TEXT_NODE && !second.firstChild.textContent.trim()) {
          second.removeChild(second.firstChild);
        }
        if (first.lastChild && first.lastChild.nodeType === Node.TEXT_NODE) {
          first.lastChild.textContent = first.lastChild.textContent.replace(/\s*$/, " ");
        } else {
          first.appendChild(document.createTextNode(" "));
        }
        while (second.firstChild) {
          first.appendChild(second.firstChild);
        }
        second.remove();
      };
      div.querySelectorAll("li").forEach((li) => {
        const directParagraphs = Array.from(li.children).filter((child) => child.tagName === "P");
        directParagraphs.forEach((paragraph) => collapseLabelBreakInParagraph(paragraph));
        mergeLabelParagraphs(li);
        unwrapSimpleListParagraphs(li);
        collapseLabelBreakInListItem(li);
        convertLeadingStrongOrCodeToSpan(li);
        wrapLeadingLabelInBlockSpan(li);
        const hasNestedList = li.querySelector("ul, ol");
        if (!hasNestedList)
          return;
        Array.from(li.children).forEach((child) => {
          if (child.tagName === "P") {
            while (child.firstChild) {
              li.insertBefore(child.firstChild, child);
            }
            child.remove();
          }
        });
        const firstList = Array.from(li.children).find((child) => child.tagName === "UL" || child.tagName === "OL");
        if (!firstList)
          return;
        const nodesBeforeList = [];
        for (let node = li.firstChild; node && node !== firstList; node = node.nextSibling) {
          nodesBeforeList.push(node);
        }
        const meaningfulNodes = nodesBeforeList.filter(
          (node) => !(node.nodeType === Node.TEXT_NODE && !node.textContent.trim())
        );
        if (meaningfulNodes.length === 0)
          return;
        const blockTags = /* @__PURE__ */ new Set(["UL", "OL", "TABLE", "PRE", "BLOCKQUOTE", "SECTION", "FIGURE", "DIV"]);
        const hasBlock = meaningfulNodes.some(
          (node) => node.nodeType === Node.ELEMENT_NODE && blockTags.has(node.tagName)
        );
        if (hasBlock)
          return;
        const wrapper = document.createElement("span");
        const liStyle = li.getAttribute("style") || "";
        const lineHeightMatch = liStyle.match(/line-height:\s*[^;]+/i);
        const lineHeight = lineHeightMatch ? `${lineHeightMatch[0]};` : "";
        wrapper.setAttribute("style", `display:block;margin:0;padding:0;${lineHeight}`);
        meaningfulNodes.forEach((node) => wrapper.appendChild(node));
        li.insertBefore(wrapper, firstList);
      });
      const getListDepth = (list) => {
        let depth = 0;
        let current = list.parentElement;
        while (current) {
          if (current.tagName === "UL" || current.tagName === "OL")
            depth += 1;
          current = current.parentElement;
        }
        return depth;
      };
      const buildPseudoItems = (list, depth) => {
        const fragment = document.createDocumentFragment();
        const isOrdered = list.tagName === "OL";
        let index = 1;
        Array.from(list.children).forEach((li) => {
          if (li.tagName !== "LI")
            return;
          const nestedLists = Array.from(li.children).filter(
            (child) => child.tagName === "UL" || child.tagName === "OL"
          );
          const liStyle = li.getAttribute("style") || "";
          const indent = Math.max(0, depth - 1) * 20;
          const wrapper = document.createElement("p");
          wrapper.setAttribute(
            "style",
            `${liStyle} margin:0 0 4px ${indent}px; padding:0;`
          );
          const contentNodes = [];
          Array.from(li.childNodes).forEach((node) => {
            if (node.nodeType === Node.ELEMENT_NODE && (node.tagName === "UL" || node.tagName === "OL"))
              return;
            if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "P") {
              const children = Array.from(node.childNodes);
              if (children.length && contentNodes.length) {
                contentNodes.push(document.createTextNode(" "));
              }
              children.forEach((child) => contentNodes.push(child));
              return;
            }
            contentNodes.push(node);
          });
          while (contentNodes.length > 0 && contentNodes[0].nodeType === Node.TEXT_NODE && !contentNodes[0].textContent.trim()) {
            contentNodes.shift();
          }
          if (contentNodes.length > 0 && contentNodes[0].nodeType === Node.TEXT_NODE) {
            contentNodes[0].textContent = contentNodes[0].textContent.replace(/^\s+/, "");
            if (!contentNodes[0].textContent) {
              contentNodes.shift();
            }
          }
          const hasContent = contentNodes.some((node) => {
            if (node.nodeType === Node.TEXT_NODE)
              return node.textContent.trim();
            return true;
          });
          if (hasContent) {
            contentNodes.forEach((node) => {
              if (node.nodeType !== Node.TEXT_NODE)
                return;
              node.textContent = node.textContent.replace(/\s*\n\s*/g, " ").replace(/\s{2,}/g, " ");
              if (!node.textContent.trim()) {
                node.remove();
              }
            });
            const markerText = isOrdered ? `${index}. ` : "\u2022 ";
            const firstText = contentNodes.find((node) => node.nodeType === Node.TEXT_NODE && node.textContent.trim());
            if (firstText) {
              firstText.textContent = markerText + firstText.textContent;
            } else {
              contentNodes.unshift(document.createTextNode(markerText));
            }
            contentNodes.forEach((node) => wrapper.appendChild(node));
            fragment.appendChild(wrapper);
          }
          nestedLists.forEach((nested) => {
            fragment.appendChild(buildPseudoItems(nested, depth + 1));
          });
          index += 1;
        });
        return fragment;
      };
      Array.from(div.querySelectorAll("ul, ol")).forEach((list) => {
        if (!div.contains(list))
          return;
        const depth = getListDepth(list);
        if (depth < 2)
          return;
        const fragment = buildPseudoItems(list, depth);
        list.parentNode.insertBefore(fragment, list);
        list.remove();
      });
      div.querySelectorAll("li > ul, li > ol").forEach((nestedList) => {
        let style = nestedList.getAttribute("style") || "";
        style = style.replace(/margin(-[a-z]+)?:\s*[^;]+;?/gi, "");
        style = "margin: 0; " + style;
        nestedList.setAttribute("style", style);
      });
      div.querySelectorAll("li").forEach((li) => {
        if (!li.textContent.trim() && li.querySelectorAll("img, ul, ol").length === 0) {
          li.remove();
        }
      });
      div.querySelectorAll("ul, ol").forEach((list) => {
        Array.from(list.childNodes).forEach((node) => {
          if (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) {
            node.remove();
          }
        });
      });
      div.querySelectorAll("li").forEach((li) => {
        Array.from(li.childNodes).forEach((node) => {
          if (node.nodeType === Node.TEXT_NODE && !node.textContent.trim()) {
            node.remove();
          }
        });
      });
      const forceInlineStyle = (el, extraStyle = "") => {
        const currentStyle = el.getAttribute("style") || "";
        const cleanedStyle = currentStyle.replace(/display\s*:\s*[^;]+;?/gi, "").replace(/width\s*:\s*[^;]+;?/gi, "").replace(/float\s*:\s*[^;]+;?/gi, "").trim();
        const normalizedStyle = cleanedStyle ? `${cleanedStyle}${cleanedStyle.endsWith(";") ? "" : ";"}` : "";
        const finalStyle = `${normalizedStyle}display:inline !important; width:auto !important; float:none !important;${extraStyle}`;
        el.setAttribute("style", finalStyle);
      };
      div.querySelectorAll("li strong").forEach((strong) => {
        forceInlineStyle(strong);
      });
      div.querySelectorAll("li code").forEach((code) => {
        if (code.closest("pre, .code-block, .code-block-code"))
          return;
        forceInlineStyle(code, " margin:0 2px !important; vertical-align:baseline;");
      });
      return div.innerHTML;
    }
    module2.exports = {
      cleanHtmlForDraft
    };
  }
});

// input.js
var { Plugin, MarkdownView, ItemView, Notice } = require("obsidian");
var { PluginSettingTab, Setting } = require("obsidian");
var { createRenderPipelines } = require_render_pipeline();
var { buildRenderRuntime } = require_dependency_loader();
var { resolveMarkdownSource } = require_markdown_source();
var { normalizeVaultPath, isAbsolutePathLike } = require_path_utils();
var { renderNativeMarkdown } = require_native_renderer();
var { createWechatSyncService } = require_wechat_sync();
var { resolveSyncAccount, toSyncFriendlyMessage } = require_sync_context();
var { processAllImages: processAllImagesService, processMathFormulas: processMathFormulasService } = require_wechat_media();
var { cleanHtmlForDraft: cleanHtmlForDraftService } = require_wechat_html_cleaner();
var APPLE_STYLE_VIEW = "apple-style-converter";
var DEFAULT_SETTINGS = {
  theme: "github",
  themeColor: "blue",
  customColor: "#0366d6",
  fontFamily: "sans-serif",
  fontSize: 3,
  macCodeBlock: true,
  codeLineNumber: true,
  avatarUrl: "",
  avatarBase64: "",
  // Base64 编码的本地头像，优先级高于 avatarUrl
  enableWatermark: false,
  showImageCaption: true,
  // 关闭水印时是否显示图片说明文字
  // 多账号支持
  wechatAccounts: [],
  // [{ id, name, appId, appSecret }]
  defaultAccountId: "",
  // 代理设置
  proxyUrl: "",
  // Cloudflare Worker 等代理地址
  // 预览设置
  usePhoneFrame: true,
  // 是否使用手机框预览
  // 渲染管线开关（Phase 1: 兼容层实验）
  useNativePipeline: false,
  enableLegacyFallback: true,
  enforceNativeParity: true,
  // Phase 2: strict byte-level parity gate
  // 排版设置
  sidePadding: 16,
  // 页面两侧留白 (px)
  coloredHeader: false,
  // 标题是否使用主题色
  // 同步后清理资源（默认关闭，避免破坏性行为）
  cleanupAfterSync: false,
  cleanupUseSystemTrash: true,
  cleanupDirTemplate: "",
  // 发送成功后要清理的目录（支持 {{note}}）
  // 旧字段保留用于迁移检测
  wechatAppId: "",
  wechatAppSecret: ""
};
var MAX_ACCOUNTS = 5;
function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
}
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
async function pMap(array, mapper, concurrency = 3) {
  const results = [];
  const executing = [];
  let isFailed = false;
  for (const item of array) {
    if (isFailed)
      break;
    const p = Promise.resolve().then(() => mapper(item));
    results.push(p);
    const e = p.catch(() => {
      isFailed = true;
    }).then(() => executing.splice(executing.indexOf(e), 1));
    executing.push(e);
    if (executing.length >= concurrency) {
      await Promise.race(executing);
    }
  }
  return Promise.all(results);
}
var WechatAPI = class {
  constructor(appId, appSecret, proxyUrl = "") {
    this.appId = appId;
    this.appSecret = appSecret;
    this.proxyUrl = proxyUrl;
    this.accessToken = "";
    this.expireTime = 0;
  }
  /**
   * 通用重试机制 (仅处理网络层面的不稳定性)
   * 不再处理 Token 逻辑，专注于网络波动和配置错误
   */
  async requestWithRetry(operation, maxRetries = 3) {
    let lastError;
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (error.isFatal)
          throw error;
        const isConfigError = error.message && (error.message.includes("(40013)") || // invalid appid
        error.message.includes("(40125)") || // invalid appsecret
        error.message.includes("invalid appid"));
        if (isConfigError) {
          console.warn(`[WechatAPI] Configuration error detected, aborting retry: ${error.message}`);
          throw error;
        }
        if (error.message && (error.message.includes("45009") || error.message.includes("reach max api daily quota limit"))) {
          const fatalError = new Error("\u5FAE\u4FE1\u63A5\u53E3\u4ECA\u65E5\u989D\u5EA6\u5DF2\u7528\u5B8C (45009)\uFF0C\u8BF7\u660E\u5929\u518D\u8BD5\u6216\u5207\u6362\u8D26\u53F7\u3002");
          fatalError.isFatal = true;
          throw fatalError;
        }
        if (error.message && (error.message.includes("45001") || error.message.includes("media size out of limit"))) {
          const fatalError = new Error("\u5FAE\u4FE1\u540E\u53F0\u7D20\u6750\u5E93\u5DF2\u6EE1 (45001)\u3002\u8BF7\u767B\u5F55\u5FAE\u4FE1\u516C\u4F17\u5E73\u53F0 -> \u7D20\u6750\u7BA1\u7406\uFF0C\u624B\u52A8\u5220\u9664\u65E7\u56FE\u7247\u4EE5\u91CA\u653E\u7A7A\u95F4\u3002");
          fatalError.isFatal = true;
          throw fatalError;
        }
        const isTokenError = error.message && (error.message.includes("40001") || error.message.includes("42001") || error.message.includes("40014"));
        if (isTokenError) {
          throw error;
        }
        const isBusinessError = error.message && error.message.includes("\u5FAE\u4FE1API\u62A5\u9519") && !error.message.includes("(-1)");
        if (isBusinessError) {
          console.warn(`[WechatAPI] Business logic error detected, aborting retry: ${error.message}`);
          throw error;
        }
        console.warn(`[WechatAPI] Network request failed (attempt ${i + 1}/${maxRetries}): ${error.message}`);
        if (i < maxRetries - 1) {
          await sleep(1e3 * (i + 1));
        }
      }
    }
    throw lastError;
  }
  /**
   * 高阶函数：执行带 Token 生命周期管理的操作
   * 负责：获取 Token -> 执行操作 -> 捕获 Token 过期错误 -> 刷新 Token -> 重试
   * @param {Function} action - 接收 token 参数的异步函数
   */
  async actionWithTokenRetry(action) {
    let retryCount = 0;
    const maxRetries = 1;
    while (true) {
      try {
        const token = await this.getAccessToken();
        return await action(token);
      } catch (error) {
        const isTokenExpired = error.message && (error.message.includes("40001") || error.message.includes("42001") || error.message.includes("40014"));
        if (isTokenExpired && retryCount < maxRetries) {
          console.warn(`[WechatAPI] Token expired (${error.message}), refreshing and retrying...`);
          this.accessToken = "";
          retryCount++;
          continue;
        }
        throw error;
      }
    }
  }
  /**
   * 验证代理 URL 安全性 (必须使用 HTTPS)
   */
  validateProxyUrl(proxyUrl) {
    if (proxyUrl && !proxyUrl.toLowerCase().startsWith("https://")) {
      const error = new Error("Security Error: Insecure HTTP proxy blocked. Proxy URL must use HTTPS.");
      error.isFatal = true;
      throw error;
    }
  }
  /**
   * 发送请求（如果配置了代理，通过代理发送）
   * 纯粹的 HTTP 请求封装，不包含重试逻辑
   */
  async sendRequest(url, options = {}) {
    const { requestUrl } = require("obsidian");
    if (this.proxyUrl) {
      this.validateProxyUrl(this.proxyUrl);
      const proxyResponse = await requestUrl({
        url: this.proxyUrl,
        method: "POST",
        body: JSON.stringify({
          url,
          method: options.method || "GET",
          data: options.body ? JSON.parse(options.body) : void 0
        }),
        contentType: "application/json"
      });
      return proxyResponse.json;
    } else {
      const response = await requestUrl({ url, ...options });
      return response.json;
    }
  }
  async getAccessToken() {
    if (this.accessToken && Date.now() < this.expireTime - 3e5) {
      return this.accessToken;
    }
    const url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${this.appId}&secret=${this.appSecret}`;
    const data = await this.requestWithRetry(() => this.sendRequest(url));
    if (data.access_token) {
      this.accessToken = data.access_token;
      this.expireTime = Date.now() + data.expires_in * 1e3;
      return this.accessToken;
    } else {
      throw new Error(`\u83B7\u53D6 Token \u5931\u8D25: ${data.errmsg || "\u672A\u77E5\u9519\u8BEF"} (${data.errcode || "??"})`);
    }
  }
  async uploadCover(blob) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/material/add_material?access_token=${token}&type=image`;
      return await this.uploadMultipart(url, blob, "media");
    });
  }
  async uploadImage(blob) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/media/uploadimg?access_token=${token}`;
      return await this.uploadMultipart(url, blob, "media");
    });
  }
  async createDraft(article) {
    return this.actionWithTokenRetry(async (token) => {
      const url = `https://api.weixin.qq.com/cgi-bin/draft/add?access_token=${token}`;
      const data = await this.sendRequest(url, {
        method: "POST",
        body: JSON.stringify({ articles: [article] })
      });
      if (data.media_id) {
        return data;
      }
      throw new Error(`\u521B\u5EFA\u8349\u7A3F\u5931\u8D25: ${data.errmsg || JSON.stringify(data)} (${data.errcode || "N/A"})`);
    });
  }
  async uploadMultipart(url, blob, fieldName) {
    return this.requestWithRetry(async () => {
      const { requestUrl } = require("obsidian");
      const mimeType = blob.type || "image/jpeg";
      const ext = mimeType.includes("gif") ? "gif" : mimeType.includes("png") ? "png" : "jpg";
      if (this.proxyUrl) {
        this.validateProxyUrl(this.proxyUrl);
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        const base64Data = await new Promise((resolve, reject) => {
          reader.onload = () => resolve(reader.result.split(",")[1]);
          reader.onerror = reject;
        });
        const proxyResponse = await requestUrl({
          url: this.proxyUrl,
          method: "POST",
          body: JSON.stringify({
            url,
            method: "UPLOAD",
            // 特殊标记，告诉代理这是文件上传
            fileData: base64Data,
            fileName: `image.${ext}`,
            mimeType,
            fieldName
          }),
          contentType: "application/json"
        });
        const data = proxyResponse.json;
        if (data.media_id || data.url) {
          return data;
        } else {
          throw new Error(`\u5FAE\u4FE1API\u62A5\u9519: ${data.errmsg} (${data.errcode})`);
        }
      } else {
        const boundary = "----ObsidianWechatConverterBoundary" + Math.random().toString(36).substring(2);
        const arrayBuffer = await blob.arrayBuffer();
        const bytes = new Uint8Array(arrayBuffer);
        let header = `--${boundary}\r
`;
        header += `Content-Disposition: form-data; name="${fieldName}"; filename="image.${ext}"\r
`;
        header += `Content-Type: ${mimeType}\r
\r
`;
        const footer = `\r
--${boundary}--\r
`;
        const headerBytes = new TextEncoder().encode(header);
        const footerBytes = new TextEncoder().encode(footer);
        const bodyBytes = new Uint8Array(headerBytes.length + bytes.length + footerBytes.length);
        bodyBytes.set(headerBytes, 0);
        bodyBytes.set(bytes, headerBytes.length);
        bodyBytes.set(footerBytes, headerBytes.length + bytes.length);
        try {
          const response = await requestUrl({
            url,
            method: "POST",
            body: bodyBytes.buffer,
            headers: {
              "Content-Type": `multipart/form-data; boundary=${boundary}`
            }
          });
          const data = response.json;
          if (data.media_id || data.url) {
            return data;
          } else {
            throw new Error(`\u5FAE\u4FE1API\u62A5\u9519: ${data.errmsg} (${data.errcode})`);
          }
        } catch (error) {
          console.error("Upload Error:", error);
          throw new Error(`\u7F51\u7EDC\u8BF7\u6C42\u5931\u8D25: ${error.message}`);
        }
      }
    });
  }
};
var AppleStyleView = class extends ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.currentHtml = null;
    this.converter = null;
    this.legacyRenderPipeline = null;
    this.nativeRenderPipeline = null;
    this.theme = null;
    this.lastActiveFile = null;
    this.sessionCoverBase64 = "";
    this.sessionDigest = "";
    this.articleStates = /* @__PURE__ */ new Map();
    this.svgUploadCache = /* @__PURE__ */ new Map();
    this.renderGeneration = 0;
  }
  getViewType() {
    return APPLE_STYLE_VIEW;
  }
  getDisplayText() {
    return "\u{1F4DD} \u5FAE\u4FE1\u6392\u7248\u8F6C\u6362";
  }
  getIcon() {
    return "wand";
  }
  async onOpen() {
    console.log("\u{1F34E} \u8F6C\u6362\u5668\u9762\u677F\u6253\u5F00");
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("apple-converter-container");
    await this.loadDependencies();
    this.createSettingsPanel(container);
    const previewWrapper = container.createEl("div", {
      cls: `apple-preview-wrapper ${this.plugin.settings.usePhoneFrame ? "mode-phone" : "mode-classic"}`
    });
    previewWrapper.addEventListener("click", (e) => {
      if (this.settingsOverlay && this.settingsOverlay.classList.contains("visible")) {
        this.settingsOverlay.classList.remove("visible");
        const btn = container.querySelector('.apple-icon-btn[aria-label="\u6837\u5F0F\u8BBE\u7F6E"]');
        if (btn)
          btn.classList.remove("active");
      }
    });
    if (this.plugin.settings.usePhoneFrame) {
      const phoneFrame = previewWrapper.createEl("div", { cls: "apple-phone-frame" });
      const header = phoneFrame.createEl("div", { cls: "apple-phone-header" });
      header.createEl("span", { cls: "title", text: "\u516C\u4F17\u53F7\u9884\u89C8" });
      header.createEl("span", { cls: "dots", text: "\u2022\u2022\u2022" });
      this.previewContainer = phoneFrame.createEl("div", {
        cls: "apple-converter-preview"
      });
      phoneFrame.createEl("div", { cls: "apple-home-indicator" });
    } else {
      this.previewContainer = previewWrapper.createEl("div", {
        cls: "apple-converter-preview"
      });
    }
    this.setPlaceholder();
    this.registerActiveFileChange();
    const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (activeView)
      this.registerScrollSync(activeView);
    setTimeout(async () => {
      const activeView2 = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (activeView2 && this.converter) {
        await this.convertCurrent(true);
      }
    }, 500);
  }
  /**
   * 监听活动文件切换
   */
  registerActiveFileChange() {
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", async () => {
        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
        if (activeView && activeView.file) {
          this.lastActiveFile = activeView.file;
        }
        this.updateCurrentDoc();
        if (activeView) {
          this.registerScrollSync(activeView);
        }
        if (activeView && this.converter) {
          setTimeout(async () => {
            await this.convertCurrent(true);
          }, 300);
        }
      })
    );
    const debounce = (func, wait) => {
      let timeout;
      return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    };
    const debouncedConvert = debounce(async () => {
      if (!this.containerEl.offsetParent)
        return;
      const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
      if (activeView && activeView.file && this.lastActiveFile && activeView.file.path === this.lastActiveFile.path) {
        await this.convertCurrent(true);
      }
    }, 500);
    this.registerEvent(
      this.app.workspace.on("editor-change", debouncedConvert)
    );
  }
  /**
   * 注册同步滚动 (双向: Editor <-> Preview)
   * 采用"原子锁"机制 + "差值检测"机制，彻底解决死循环和精度问题
   */
  registerScrollSync(activeView) {
    if (this.activeEditorScroller && this.editorScrollListener) {
      this.activeEditorScroller.removeEventListener("scroll", this.editorScrollListener);
    }
    if (this.previewContainer && this.previewScrollListener) {
      this.previewContainer.removeEventListener("scroll", this.previewScrollListener);
    }
    this.activeEditorScroller = null;
    this.editorScrollListener = null;
    this.previewScrollListener = null;
    this.ignoreNextPreviewScroll = false;
    this.ignoreNextEditorScroll = false;
    if (!activeView)
      return;
    const editorScroller = activeView.contentEl.querySelector(".cm-scroller");
    if (!editorScroller)
      return;
    this.activeEditorScroller = editorScroller;
    this.editorScrollListener = () => {
      if (!this.containerEl.offsetParent)
        return;
      if (this.ignoreNextEditorScroll) {
        this.ignoreNextEditorScroll = false;
        return;
      }
      if (!this.previewContainer)
        return;
      const editorHeight = editorScroller.scrollHeight - editorScroller.clientHeight;
      const previewHeight = this.previewContainer.scrollHeight - this.previewContainer.clientHeight;
      if (editorHeight <= 0 || previewHeight <= 0)
        return;
      let targetScrollTop;
      if (editorScroller.scrollTop === 0) {
        targetScrollTop = 0;
      } else if (Math.abs(editorScroller.scrollTop - editorHeight) < 2) {
        targetScrollTop = previewHeight;
      } else {
        const ratio = editorScroller.scrollTop / editorHeight;
        targetScrollTop = ratio * previewHeight;
      }
      if (Math.abs(this.previewContainer.scrollTop - targetScrollTop) > 1) {
        this.ignoreNextPreviewScroll = true;
        this.previewContainer.scrollTop = targetScrollTop;
      }
    };
    this.previewScrollListener = () => {
      if (!this.containerEl.offsetParent)
        return;
      if (this.ignoreNextPreviewScroll) {
        this.ignoreNextPreviewScroll = false;
        return;
      }
      const editorHeight = editorScroller.scrollHeight - editorScroller.clientHeight;
      const previewHeight = this.previewContainer.scrollHeight - this.previewContainer.clientHeight;
      if (editorHeight <= 0 || previewHeight <= 0)
        return;
      let targetScrollTop;
      if (this.previewContainer.scrollTop === 0) {
        targetScrollTop = 0;
      } else if (Math.abs(this.previewContainer.scrollTop - previewHeight) < 2) {
        targetScrollTop = editorHeight;
      } else {
        const ratio = this.previewContainer.scrollTop / previewHeight;
        targetScrollTop = ratio * editorHeight;
      }
      if (Math.abs(editorScroller.scrollTop - targetScrollTop) > 1) {
        this.ignoreNextEditorScroll = true;
        editorScroller.scrollTop = targetScrollTop;
      }
    };
    editorScroller.addEventListener("scroll", this.editorScrollListener, { passive: true });
    this.previewContainer.addEventListener("scroll", this.previewScrollListener, { passive: true });
  }
  /**
   * 加载依赖库
   */
  async loadDependencies() {
    const adapter = this.app.vault.adapter;
    const basePath = this.plugin.manifest.dir;
    try {
      const runtime = await buildRenderRuntime({
        settings: this.plugin.settings,
        app: this.app,
        adapter,
        basePath
      });
      this.theme = runtime.theme;
      this.converter = runtime.converter;
      const { legacyPipeline, nativePipeline } = createRenderPipelines({
        converter: this.converter,
        getFlags: () => this.getRenderPipelineFlags(),
        nativeRenderer: async (markdown, context = {}) => renderNativeMarkdown({
          converter: this.converter,
          markdown,
          sourcePath: context.sourcePath || ""
        })
      });
      this.legacyRenderPipeline = legacyPipeline;
      this.nativeRenderPipeline = nativePipeline;
      console.log("\u2705 \u4F9D\u8D56\u52A0\u8F7D\u5B8C\u6210");
    } catch (error) {
      console.error("\u274C \u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25:", error);
      new Notice("\u4F9D\u8D56\u52A0\u8F7D\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 创建设置面板（重构为：顶部工具栏 + 悬浮设置层）
   */
  createSettingsPanel(container) {
    const { setIcon } = require("obsidian");
    const toolbar = container.createEl("div", { cls: "apple-top-toolbar" });
    this.currentDocLabel = toolbar.createEl("div", { cls: "apple-toolbar-title" });
    this.currentDocLabel.createDiv({ text: "\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668", cls: "apple-toolbar-plugin-name" });
    this.docTitleText = this.currentDocLabel.createDiv({ text: "\u672A\u9009\u62E9\u6587\u6863", cls: "apple-toolbar-doc-name" });
    const actions = toolbar.createEl("div", { cls: "apple-toolbar-actions" });
    const createIconBtn = (icon, title, onClick) => {
      const btn = actions.createEl("div", {
        cls: "apple-icon-btn",
        attr: { "aria-label": title }
        // Tooltip
      });
      setIcon(btn, icon);
      btn.addEventListener("click", onClick);
      return btn;
    };
    const settingsBtn = createIconBtn("sliders-horizontal", "\u6837\u5F0F\u8BBE\u7F6E", () => {
      this.settingsOverlay.classList.toggle("visible");
      settingsBtn.classList.toggle("active");
    });
    this.copyBtn = createIconBtn("copy", "\u590D\u5236\u5230\u516C\u4F17\u53F7", () => this.copyHTML());
    const accounts = this.plugin.settings.wechatAccounts || [];
    if (accounts.length > 0) {
      createIconBtn("send", "\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1", () => this.showSyncModal());
    }
    this.settingsOverlay = container.createEl("div", { cls: "apple-settings-overlay" });
    const settingsArea = this.settingsOverlay.createEl("div", { cls: "apple-settings-area" });
    this.createSection(settingsArea, "\u4E3B\u9898", (section) => {
      const grid = section.createEl("div", { cls: "apple-btn-grid" });
      const themes = AppleTheme.getThemeList();
      themes.forEach((t) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-theme ${this.plugin.settings.theme === t.value ? "active" : ""}`,
          text: t.label
        });
        btn.dataset.value = t.value;
        btn.addEventListener("click", () => this.onThemeChange(t.value, grid));
      });
    });
    this.createSection(settingsArea, "\u5B57\u4F53", (section) => {
      const select = section.createEl("select", { cls: "apple-select" });
      [
        { value: "sans-serif", label: "\u65E0\u886C\u7EBF" },
        { value: "serif", label: "\u886C\u7EBF" },
        { value: "monospace", label: "\u7B49\u5BBD" }
      ].forEach((opt) => {
        const option = select.createEl("option", { value: opt.value, text: opt.label });
        if (this.plugin.settings.fontFamily === opt.value)
          option.selected = true;
      });
      select.addEventListener("change", (e) => this.onFontFamilyChange(e.target.value));
    });
    this.createSection(settingsArea, "\u5B57\u53F7", (section) => {
      const grid = section.createEl("div", { cls: "apple-btn-row" });
      const sizeOpts = [
        { value: 1, label: "\u5C0F" },
        { value: 2, label: "\u8F83\u5C0F" },
        { value: 3, label: "\u63A8\u8350" },
        { value: 4, label: "\u8F83\u5927" },
        { value: 5, label: "\u5927" }
      ];
      sizeOpts.forEach((s) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-size ${this.plugin.settings.fontSize === s.value ? "active" : ""}`,
          text: s.label
        });
        btn.dataset.value = s.value;
        btn.addEventListener("click", () => this.onFontSizeChange(s.value, grid));
      });
    });
    this.createSection(settingsArea, "\u4E3B\u9898\u8272", (section) => {
      const grid = section.createEl("div", { cls: "apple-color-grid" });
      const colors = AppleTheme.getColorList();
      colors.forEach((c) => {
        const btn = grid.createEl("button", {
          cls: `apple-btn-color ${this.plugin.settings.themeColor === c.value ? "active" : ""}`
        });
        btn.dataset.value = c.value;
        btn.style.setProperty("--btn-color", c.color);
        btn.addEventListener("click", () => this.onColorChange(c.value, grid));
      });
      const customBtn = grid.createEl("button", {
        cls: `apple-btn-custom-text ${this.plugin.settings.themeColor === "custom" ? "active" : ""}`,
        text: "\u81EA\u5B9A\u4E49",
        title: "\u81EA\u5B9A\u4E49\u989C\u8272"
      });
      customBtn.dataset.value = "custom";
      const colorInput = grid.createEl("input", {
        type: "color",
        cls: "apple-color-picker-hidden"
      });
      colorInput.value = this.plugin.settings.customColor || "#000000";
      colorInput.style.visibility = "hidden";
      colorInput.style.width = "0";
      colorInput.style.height = "0";
      colorInput.style.position = "absolute";
      customBtn.addEventListener("click", () => {
        colorInput.click();
      });
      colorInput.addEventListener("input", (e) => {
        customBtn.style.setProperty("--btn-color", e.target.value);
      });
      colorInput.addEventListener("change", async (e) => {
        const newColor = e.target.value;
        customBtn.style.setProperty("--btn-color", newColor);
        this.plugin.settings.customColor = newColor;
        this.theme.update({ customColor: newColor });
        await this.onColorChange("custom", grid);
      });
    });
    this.createSection(settingsArea, "\u6807\u9898\u6837\u5F0F", (section) => {
      section.style.display = "flex";
      section.style.alignItems = "center";
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.coloredHeader;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      section.createEl("span", {
        text: "\u6807\u9898\u4F7F\u7528\u52A0\u6DF1\u4E3B\u9898\u8272",
        attr: {
          style: "font-size: 11px; color: var(--apple-secondary); margin-left: 12px; opacity: 0.8; font-weight: 500; transform: translateY(-1px);"
        }
      });
      checkbox.addEventListener("change", async () => {
        this.plugin.settings.coloredHeader = checkbox.checked;
        await this.plugin.saveSettings();
        this.theme.update({ coloredHeader: checkbox.checked });
        await this.convertCurrent(true);
      });
    });
    this.createSection(settingsArea, "Mac \u98CE\u683C\u4EE3\u7801\u5757", (section) => {
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.macCodeBlock;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      checkbox.addEventListener("change", () => this.onMacCodeBlockChange(checkbox.checked));
    });
    this.createSection(settingsArea, "\u663E\u793A\u4EE3\u7801\u884C\u53F7", (section) => {
      const toggle = section.createEl("label", { cls: "apple-toggle" });
      const checkbox = toggle.createEl("input", { type: "checkbox", cls: "apple-toggle-input" });
      checkbox.checked = this.plugin.settings.codeLineNumber;
      toggle.createEl("span", { cls: "apple-toggle-slider" });
      checkbox.addEventListener("change", () => this.onCodeLineNumberChange(checkbox.checked));
    });
    this.createSection(settingsArea, "\u9875\u9762\u4E24\u4FA7\u7559\u767D", (section) => {
      const container2 = section.createEl("div", {
        cls: "apple-slider-container",
        style: "width: 100%; display: flex; align-items: center; gap: 10px;"
      });
      const slider = container2.createEl("input", {
        type: "range",
        cls: "apple-slider",
        attr: { min: 0, max: 40, step: 1 }
      });
      slider.value = this.plugin.settings.sidePadding;
      slider.style.flex = "1";
      const valueLabel = container2.createEl("span", {
        text: `${this.plugin.settings.sidePadding}px`,
        style: "font-size: 12px; color: var(--apple-secondary); min-width: 32px; text-align: right;"
      });
      slider.addEventListener("input", async (e) => {
        const val = parseInt(e.target.value);
        valueLabel.setText(`${val}px`);
        this.plugin.settings.sidePadding = val;
        this.theme.update({ sidePadding: val });
        if (this.saveTimeout)
          clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(async () => {
          await this.plugin.saveSettings();
        }, 500);
        await this.convertCurrent(true);
      });
    });
    const captionSetting = new Setting(settingsArea).setName("\u663E\u793A\u56FE\u7247\u8BF4\u660E\u6587\u5B57").setDesc("\u5173\u95ED\u6C34\u5370\u65F6\uFF0C\u5728\u56FE\u7247\u4E0B\u65B9\u663E\u793A\u8BF4\u660E\u6587\u5B57").addToggle((toggle) => toggle.setValue(this.plugin.settings.showImageCaption).onChange(async (value) => {
      this.plugin.settings.showImageCaption = value;
      await this.plugin.saveSettings();
      if (this.converter) {
        this.converter.updateConfig({ showImageCaption: value });
        await this.convertCurrent(true);
      }
    }));
    if (this.plugin.settings.enableWatermark) {
      captionSetting.setDesc("\u56E0\u5168\u5C40\u8BBE\u7F6E\u4E2D\u5DF2\u5F00\u542F\u6C34\u5370\uFF0C\u6B64\u9009\u9879\u9ED8\u8BA4\u5F00\u542F");
      const toggleComp = captionSetting.components[0];
      toggleComp.setValue(true);
      toggleComp.setDisabled(true);
      if (toggleComp.toggleEl) {
        toggleComp.toggleEl.style.pointerEvents = "none";
        toggleComp.toggleEl.style.opacity = "0.6";
        toggleComp.toggleEl.style.filter = "grayscale(100%)";
      }
    }
  }
  /**
   * 创建账号选择器
   */
  createAccountSelector(parent) {
    const accounts = this.plugin.settings.wechatAccounts || [];
    if (accounts.length === 0)
      return;
    const section = parent.createEl("div", { cls: "apple-setting-section wechat-account-selector" });
    section.createEl("label", { cls: "apple-setting-label", text: "\u540C\u6B65\u8D26\u53F7" });
    const select = section.createEl("select", { cls: "wechat-account-select" });
    const defaultId = this.plugin.settings.defaultAccountId;
    for (const account of accounts) {
      const option = select.createEl("option", {
        value: account.id,
        text: account.id === defaultId ? `${account.name} (\u9ED8\u8BA4)` : account.name
      });
      if (account.id === defaultId) {
        option.selected = true;
      }
    }
    this.selectedAccountId = defaultId;
    select.addEventListener("change", (e) => {
      this.selectedAccountId = e.target.value;
    });
  }
  /**
   * 从文章内容中提取第一张图片作为封面
   */
  getFirstImageFromArticle() {
    if (!this.currentHtml)
      return null;
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.currentHtml;
    const imgs = Array.from(tempDiv.querySelectorAll("img"));
    for (const img of imgs) {
      if (img.alt === "logo")
        continue;
      if (img.src)
        return img.src;
    }
    return null;
  }
  /**
   * 获取当前发布上下文文件：
   * 1) 优先当前活动文件
   * 2) 回退到最近一次活动文件（侧边栏切换 tab 后常见）
   */
  getPublishContextFile() {
    var _a, _b, _c;
    const activeFile = (_c = (_b = (_a = this.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.getActiveFile) == null ? void 0 : _c.call(_b);
    if (activeFile)
      return activeFile;
    if (this.lastActiveFile)
      return this.lastActiveFile;
    return null;
  }
  /**
   * 读取当前文档 frontmatter 中的发布元数据
   * @returns {{ excerpt: string, cover: string, cover_dir: string, coverSrc: string|null }}
   */
  getFrontmatterPublishMeta(activeFile) {
    var _a;
    if (!activeFile) {
      return { excerpt: "", cover: "", cover_dir: "", coverSrc: null };
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter;
    const excerpt = this.getFrontmatterString(frontmatter, ["excerpt"]);
    const cover = this.getFrontmatterString(frontmatter, ["cover"]);
    const cover_dir = this.getFrontmatterString(frontmatter, ["cover_dir", "coverDir", "cover-dir", "coverdir", "CoverDIR"]);
    const coverSrc = cover ? this.resolveVaultPathToResourceSrc(cover) : null;
    return { excerpt, cover, cover_dir, coverSrc };
  }
  getFrontmatterString(frontmatter, keys) {
    if (!frontmatter || typeof frontmatter !== "object")
      return "";
    if (!Array.isArray(keys) || keys.length === 0)
      return "";
    const normalizedTargets = new Set(keys.map((key) => this.normalizeFrontmatterKey(key)));
    for (const key of keys) {
      const value = frontmatter[key];
      if (typeof value === "string" && value.trim())
        return value.trim();
    }
    for (const [key, value] of Object.entries(frontmatter)) {
      if (!normalizedTargets.has(this.normalizeFrontmatterKey(key)))
        continue;
      if (typeof value === "string" && value.trim())
        return value.trim();
    }
    return "";
  }
  normalizeFrontmatterKey(key) {
    return String(key || "").toLowerCase().replace(/[_-]/g, "");
  }
  getFrontmatterKeyMap(frontmatter, keys) {
    const result = {};
    if (!frontmatter || typeof frontmatter !== "object")
      return result;
    if (!Array.isArray(keys) || keys.length === 0)
      return result;
    const normalizedTargets = new Set(keys.map((key) => this.normalizeFrontmatterKey(key)));
    for (const [key, value] of Object.entries(frontmatter)) {
      if (!normalizedTargets.has(this.normalizeFrontmatterKey(key)))
        continue;
      if (typeof value !== "string")
        continue;
      const normalizedValue = this.normalizeVaultPath(value);
      if (!normalizedValue)
        continue;
      result[key] = normalizedValue;
    }
    return result;
  }
  isPathInsideDirectory(filePath, dirPath) {
    const file = this.normalizeVaultPath(filePath);
    const dir = this.normalizeVaultPath(dirPath);
    if (!file || !dir)
      return false;
    if (file === dir)
      return true;
    return file.startsWith(`${dir}/`);
  }
  isPathInsideDirectoryByTail(filePath, dirPath) {
    const file = this.normalizeVaultPath(filePath);
    const dir = this.normalizeVaultPath(dirPath);
    if (!file || !dir)
      return false;
    const dirSegments = dir.split("/").filter(Boolean);
    if (dirSegments.length < 2)
      return false;
    for (let i = 1; i <= dirSegments.length - 2; i++) {
      const tailDir = dirSegments.slice(i).join("/");
      if (this.isPathInsideDirectory(file, tailDir)) {
        return true;
      }
    }
    return false;
  }
  shouldClearFrontmatterPathAfterCleanup(pathValue, cleanedDir) {
    const normalized = this.normalizeVaultPath(pathValue);
    if (!normalized)
      return false;
    if (this.isPathInsideDirectory(normalized, cleanedDir))
      return true;
    return this.isPathInsideDirectoryByTail(normalized, cleanedDir);
  }
  async clearInvalidPublishMetaAfterCleanup(activeFile, cleanedDirPath) {
    if (!activeFile || !cleanedDirPath)
      return null;
    const cleanedDir = this.normalizeVaultPath(cleanedDirPath);
    if (!cleanedDir)
      return null;
    try {
      await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
        if (!frontmatter || typeof frontmatter !== "object")
          return;
        const coverMap = this.getFrontmatterKeyMap(frontmatter, ["cover"]);
        const coverDirMap = this.getFrontmatterKeyMap(frontmatter, ["cover_dir", "coverDir", "cover-dir", "coverdir", "CoverDIR"]);
        for (const [key, value] of Object.entries(coverMap)) {
          if (this.shouldClearFrontmatterPathAfterCleanup(value, cleanedDir)) {
            frontmatter[key] = "";
          }
        }
        for (const [key, value] of Object.entries(coverDirMap)) {
          if (this.shouldClearFrontmatterPathAfterCleanup(value, cleanedDir)) {
            frontmatter[key] = "";
          }
        }
      });
    } catch (error) {
      return `\u8D44\u6E90\u5DF2\u5220\u9664\uFF0C\u4F46\u6E05\u7406 frontmatter \u4E2D\u5931\u6548\u7684 cover/cover_dir \u5931\u8D25: ${error.message}`;
    }
    return null;
  }
  /**
   * 将 vault 相对路径解析为可预览/上传的资源 src（通常是 app://）
   */
  resolveVaultPathToResourceSrc(vaultPath) {
    if (typeof vaultPath !== "string")
      return null;
    const normalized = vaultPath.trim().replace(/\\/g, "/").replace(/^\/+/, "");
    if (!normalized)
      return null;
    try {
      const file = this.app.vault.getAbstractFileByPath(normalized);
      if (!file)
        return null;
      if (typeof file.extension !== "string")
        return null;
      return this.app.vault.getResourcePath(file);
    } catch (error) {
      return null;
    }
  }
  normalizeVaultPath(vaultPath) {
    return normalizeVaultPath(vaultPath);
  }
  getCleanupDirTemplate() {
    var _a, _b;
    const raw = typeof ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.cleanupDirTemplate) === "string" ? this.plugin.settings.cleanupDirTemplate : "";
    return this.normalizeVaultPath(raw);
  }
  resolveCleanupDirPath(activeFile) {
    const template = this.getCleanupDirTemplate();
    if (!template) {
      return { path: "", warning: "\u672A\u914D\u7F6E\u6E05\u7406\u76EE\u5F55\uFF0C\u8BF7\u5728\u63D2\u4EF6\u8BBE\u7F6E\u4E2D\u5148\u586B\u5199\u76EE\u5F55\u540E\u518D\u542F\u7528\u81EA\u52A8\u6E05\u7406" };
    }
    const hasNotePlaceholder = /\{\{\s*note\s*\}\}/i.test(template);
    if (hasNotePlaceholder && !activeFile) {
      return { path: "", warning: "\u5F53\u524D\u6CA1\u6709\u6D3B\u52A8\u6587\u6863\uFF0C\u65E0\u6CD5\u89E3\u6790\u6E05\u7406\u76EE\u5F55\u4E2D\u7684 {{note}}" };
    }
    const noteName = ((activeFile == null ? void 0 : activeFile.basename) || "").trim();
    const resolved = template.replace(/\{\{\s*note\s*\}\}/gi, noteName);
    const normalized = this.normalizeVaultPath(resolved);
    if (!normalized) {
      return { path: "", warning: "\u6E05\u7406\u76EE\u5F55\u4E3A\u7A7A\uFF0C\u8BF7\u68C0\u67E5\u8BBE\u7F6E\u503C" };
    }
    return { path: normalized };
  }
  /**
   * 清理目录安全校验：禁止空路径、上跳路径、系统配置目录等危险路径
   */
  isSafeCleanupDirPath(vaultPath) {
    const normalized = this.normalizeVaultPath(vaultPath);
    if (!normalized)
      return false;
    if (normalized === ".")
      return false;
    if (normalized.includes(".."))
      return false;
    if (normalized === ".obsidian" || normalized.startsWith(".obsidian/"))
      return false;
    return true;
  }
  /**
   * 在同步成功后按配置清理目录
   * 失败返回 warning，不抛错（避免影响同步成功状态）
   */
  async cleanupConfiguredDirectory(activeFile) {
    if (!this.plugin.settings.cleanupAfterSync) {
      return { attempted: false };
    }
    const useSystemTrash = this.plugin.settings.cleanupUseSystemTrash !== false;
    const resolved = this.resolveCleanupDirPath(activeFile);
    if (!resolved.path) {
      return { attempted: true, success: false, warning: resolved.warning || "\u672A\u89E3\u6790\u5230\u6E05\u7406\u76EE\u5F55" };
    }
    const normalized = resolved.path;
    if (!this.isSafeCleanupDirPath(normalized)) {
      return { attempted: true, success: false, warning: `\u6E05\u7406\u76EE\u5F55\u4E0D\u5B89\u5168\uFF0C\u5DF2\u8DF3\u8FC7: ${normalized}` };
    }
    const abstractFile = this.app.vault.getAbstractFileByPath(normalized);
    if (!abstractFile) {
      return { attempted: true, success: false, warning: `\u6E05\u7406\u76EE\u5F55\u4E0D\u5B58\u5728: ${normalized}` };
    }
    const isFile = typeof abstractFile.extension === "string";
    if (isFile) {
      return { attempted: true, success: false, warning: `\u6E05\u7406\u8DEF\u5F84\u4E0D\u662F\u76EE\u5F55\uFF0C\u5DF2\u8DF3\u8FC7: ${normalized}` };
    }
    try {
      if (typeof this.app.vault.trash === "function") {
        await this.app.vault.trash(abstractFile, useSystemTrash);
      } else if (typeof this.app.vault.delete === "function") {
        await this.app.vault.delete(abstractFile, true);
      } else {
        throw new Error("\u5F53\u524D Obsidian \u7248\u672C\u4E0D\u652F\u6301\u5220\u9664\u63A5\u53E3");
      }
    } catch (error) {
      return { attempted: true, success: false, warning: `\u5220\u9664\u5931\u8D25 (${normalized}): ${error.message}` };
    }
    const frontmatterWarning = await this.clearInvalidPublishMetaAfterCleanup(activeFile, normalized);
    if (frontmatterWarning) {
      return { attempted: true, success: true, cleanedPath: normalized, warning: frontmatterWarning };
    }
    return { attempted: true, success: true, cleanedPath: normalized };
  }
  /**
   * 创建设置区块
   */
  createSection(parent, label, builder) {
    const section = parent.createEl("div", { cls: "apple-setting-section" });
    section.createEl("label", { cls: "apple-setting-label", text: label });
    const content = section.createEl("div", { cls: "apple-setting-content" });
    builder(content);
  }
  /**
   * 显示同步选项 Modal
   */
  showSyncModal() {
    if (!this.currentHtml) {
      new Notice("\u26A0\uFE0F \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    const { Modal } = require("obsidian");
    const modal = new Modal(this.app);
    modal.titleEl.setText("\u540C\u6B65\u5230\u5FAE\u4FE1\u8349\u7A3F\u7BB1");
    modal.contentEl.addClass("wechat-sync-modal");
    const activeFile = this.getPublishContextFile();
    const currentPath = activeFile ? activeFile.path : null;
    const frontmatterMeta = this.getFrontmatterPublishMeta(activeFile);
    let cachedState = null;
    if (currentPath && this.articleStates.has(currentPath)) {
      cachedState = this.articleStates.get(currentPath);
    }
    const accounts = this.plugin.settings.wechatAccounts || [];
    const defaultId = this.plugin.settings.defaultAccountId;
    let selectedAccountId = defaultId;
    let coverBase64 = (cachedState == null ? void 0 : cachedState.coverBase64) || frontmatterMeta.coverSrc || this.getFirstImageFromArticle();
    this.sessionCoverBase64 = coverBase64;
    const accountSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    accountSection.createEl("label", { text: "\u8D26\u53F7", cls: "wechat-modal-label" });
    const accountSelect = accountSection.createEl("select", { cls: "wechat-account-select" });
    for (const account of accounts) {
      const option = accountSelect.createEl("option", {
        value: account.id,
        text: account.id === defaultId ? `${account.name} (\u9ED8\u8BA4)` : account.name
      });
      if (account.id === defaultId)
        option.selected = true;
    }
    accountSelect.addEventListener("change", (e) => {
      selectedAccountId = e.target.value;
    });
    const coverSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    coverSection.createEl("label", { text: "\u5C01\u9762\u56FE", cls: "wechat-modal-label" });
    const coverContent = coverSection.createDiv({ cls: "wechat-modal-cover-content" });
    const coverPreview = coverContent.createDiv({ cls: "wechat-modal-cover-preview" });
    const updatePreview = () => {
      coverPreview.empty();
      if (coverBase64) {
        coverPreview.createEl("img", { attr: { src: coverBase64 } });
        syncBtn.disabled = false;
        syncBtn.setText("\u5F00\u59CB\u540C\u6B65");
        syncBtn.removeClass("apple-btn-disabled");
      } else {
        coverPreview.createEl("div", {
          text: "\u6682\u65E0\u5C01\u9762",
          cls: "wechat-modal-no-cover"
        });
        syncBtn.disabled = true;
        syncBtn.setText("\u8BF7\u5148\u8BBE\u7F6E\u5C01\u9762");
        syncBtn.addClass("apple-btn-disabled");
      }
    };
    const coverBtns = coverContent.createDiv({ cls: "wechat-modal-cover-btns" });
    const uploadBtn = coverBtns.createEl("button", { text: "\u4E0A\u4F20" });
    const digestSection = modal.contentEl.createDiv({ cls: "wechat-modal-section" });
    digestSection.createEl("label", { text: "\u6587\u7AE0\u6458\u8981\uFF08\u53EF\u9009\uFF09", cls: "wechat-modal-label" });
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = this.currentHtml || "";
    const autoDigest = (tempDiv.textContent || "").replace(/\s+/g, " ").trim().substring(0, 45);
    const initialDigest = (cachedState == null ? void 0 : cachedState.digest) !== void 0 ? cachedState.digest : frontmatterMeta.excerpt || autoDigest;
    const digestInput = digestSection.createEl("textarea", {
      cls: "wechat-modal-digest-input",
      placeholder: "\u7559\u7A7A\u5219\u81EA\u52A8\u63D0\u53D6\u6587\u7AE0\u524D 45 \u5B57"
    });
    digestInput.value = initialDigest;
    digestInput.rows = 3;
    digestInput.style.width = "100%";
    digestInput.style.resize = "vertical";
    digestInput.maxLength = 120;
    const charCount = digestSection.createEl("div", {
      cls: "wechat-digest-count",
      text: `${digestInput.value.length}/120`,
      style: "text-align: right; font-size: 11px; color: var(--text-muted); margin-top: 4px; opacity: 0.7;"
    });
    digestInput.addEventListener("input", () => {
      charCount.setText(`${digestInput.value.length}/120`);
      if (currentPath) {
        const state = this.articleStates.get(currentPath) || {};
        state.digest = digestInput.value.trim();
        this.articleStates.set(currentPath, { ...state, digest: digestInput.value });
      }
    });
    const btnRow = modal.contentEl.createDiv({ cls: "wechat-modal-buttons" });
    const cancelBtn = btnRow.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.onclick = () => modal.close();
    const syncBtn = btnRow.createEl("button", { text: "\u5F00\u59CB\u540C\u6B65", cls: "mod-cta" });
    updatePreview();
    syncBtn.onclick = async () => {
      if (!coverBase64) {
        new Notice("\u274C \u8BF7\u5148\u8BBE\u7F6E\u5C01\u9762\u56FE");
        return;
      }
      modal.close();
      this.selectedAccountId = selectedAccountId;
      this.sessionCoverBase64 = coverBase64;
      this.sessionDigest = digestInput.value.trim() || autoDigest || "\u4E00\u952E\u540C\u6B65\u81EA Obsidian";
      await this.onSyncToWechat();
    };
    uploadBtn.onclick = () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file)
          return;
        const reader = new FileReader();
        reader.onload = (event) => {
          coverBase64 = event.target.result;
          this.sessionCoverBase64 = coverBase64;
          updatePreview();
          if (currentPath) {
            const state = this.articleStates.get(currentPath) || {};
            this.articleStates.set(currentPath, { ...state, coverBase64 });
          }
        };
        reader.readAsDataURL(file);
      };
      input.click();
    };
    modal.open();
  }
  /**
   * 处理同步到微信逻辑
   */
  async onSyncToWechat() {
    const account = resolveSyncAccount({
      accounts: this.plugin.settings.wechatAccounts || [],
      selectedAccountId: this.selectedAccountId,
      defaultAccountId: this.plugin.settings.defaultAccountId
    });
    if (!account) {
      new Notice("\u274C \u8BF7\u5148\u5728\u63D2\u4EF6\u8BBE\u7F6E\u4E2D\u6DFB\u52A0\u5FAE\u4FE1\u516C\u4F17\u53F7\u8D26\u53F7");
      return;
    }
    if (!this.currentHtml) {
      new Notice("\u274C \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    const notice = new Notice(`\u{1F680} \u6B63\u5728\u4F7F\u7528 ${account.name} \u540C\u6B65...`, 0);
    const activeFile = this.getPublishContextFile();
    const publishMeta = this.getFrontmatterPublishMeta(activeFile);
    try {
      const syncService = createWechatSyncService({
        createApi: (appId, appSecret, proxyUrl) => new WechatAPI(appId, appSecret, proxyUrl),
        srcToBlob: this.srcToBlob.bind(this),
        processAllImages: this.processAllImages.bind(this),
        processMathFormulas: this.processMathFormulas.bind(this),
        cleanHtmlForDraft: this.cleanHtmlForDraft.bind(this),
        cleanupConfiguredDirectory: this.cleanupConfiguredDirectory.bind(this),
        getFirstImageFromArticle: this.getFirstImageFromArticle.bind(this)
      });
      const { cleanupResult } = await syncService.syncToDraft({
        account,
        proxyUrl: this.plugin.settings.proxyUrl,
        currentHtml: this.currentHtml,
        activeFile,
        publishMeta,
        sessionCoverBase64: this.sessionCoverBase64,
        sessionDigest: this.sessionDigest,
        onStatus: (stage) => {
          if (stage === "cover")
            notice.setMessage("\u{1F5BC}\uFE0F \u6B63\u5728\u5904\u7406\u5C01\u9762\u56FE...");
          if (stage === "images")
            notice.setMessage("\u{1F4F8} \u6B63\u5728\u540C\u6B65\u6B63\u6587\u56FE\u7247...");
          if (stage === "math")
            notice.setMessage("\u{1F9EE} \u6B63\u5728\u8F6C\u6362\u77E2\u91CF\u56FE/\u6570\u5B66\u516C\u5F0F...");
          if (stage === "draft")
            notice.setMessage("\u{1F4DD} \u6B63\u5728\u53D1\u9001\u5230\u5FAE\u4FE1\u8349\u7A3F\u7BB1...");
        },
        onImageProgress: (current, total) => {
          notice.setMessage(`\u{1F4F8} \u6B63\u5728\u540C\u6B65\u6B63\u6587\u56FE\u7247 (${current}/${total})...`);
        },
        onMathProgress: (current, total) => {
          notice.setMessage(`\u{1F9EE} \u6B63\u5728\u8F6C\u6362\u77E2\u91CF\u56FE/\u6570\u5B66\u516C\u5F0F (${current}/${total})...`);
        }
      });
      notice.hide();
      new Notice("\u2705 \u540C\u6B65\u6210\u529F\uFF01\u8BF7\u524D\u5F80\u5FAE\u4FE1\u516C\u4F17\u53F7\u540E\u53F0\u8349\u7A3F\u7BB1\u67E5\u770B");
      if (cleanupResult == null ? void 0 : cleanupResult.warning) {
        new Notice(`\u26A0\uFE0F \u8D44\u6E90\u6E05\u7406\u5931\u8D25\uFF1A${cleanupResult.warning}`, 7e3);
      }
    } catch (error) {
      notice.hide();
      console.error("Wechat Sync Error:", error);
      const friendlyMsg = toSyncFriendlyMessage(error.message);
      new Notice(`\u274C \u540C\u6B65\u5931\u8D25: ${friendlyMsg}`);
    }
  }
  /**
   * 将各种形式的 src (Base64, URL, 路径) 转为 Blob
   */
  async srcToBlob(src) {
    if (src.startsWith("data:")) {
      const resp = await fetch(src);
      return await resp.blob();
    }
    if (src.startsWith("app://") || src.startsWith("capacitor://")) {
      const resp = await fetch(src);
      return await resp.blob();
    }
    if (src.startsWith("http")) {
      const { requestUrl } = require("obsidian");
      const response = await requestUrl({ url: src });
      const contentType = response.headers["content-type"] || response.headers["Content-Type"] || "image/jpeg";
      return new Blob([response.arrayBuffer], { type: contentType });
    }
    throw new Error("\u4E0D\u652F\u6301\u7684\u56FE\u7247\u6765\u6E90\uFF0C\u8BF7\u5C1D\u8BD5\u91CD\u65B0\u4E0A\u4F20\u5C01\u9762");
  }
  /**
   * 处理 HTML 中的所有图片，上传到微信并替换链接
   * 支持并发上传 (Limit 3) 和进度回调
   */
  async processAllImages(html, api, progressCallback) {
    return processAllImagesService({
      html,
      api,
      progressCallback,
      pMap,
      srcToBlob: this.srcToBlob.bind(this)
    });
  }
  /**
   * 处理 HTML 中的数学公式 (MathJax SVG -> Wechat Image)
   * 解决微信接口内容长度限制问题
   */
  async processMathFormulas(html, api, progressCallback) {
    return processMathFormulasService({
      html,
      api,
      progressCallback,
      pMap,
      simpleHash: this.simpleHash.bind(this),
      svgUploadCache: this.svgUploadCache,
      svgToPngBlob: this.svgToPngBlob.bind(this)
    });
  }
  /**
   * 将 SVG 元素转换为高分辨率 PNG Blob
   * 返回: { blob, width, height, style }
   */
  async svgToPngBlob(svgElement, scale = 3) {
    return new Promise((resolve, reject) => {
      try {
        const clonedSvg = svgElement.cloneNode(true);
        const rect = svgElement.getBoundingClientRect();
        let logicalWidth = rect.width;
        let logicalHeight = rect.height;
        const rawWidth = svgElement.getAttribute("width");
        const rawHeight = svgElement.getAttribute("height");
        const rawStyle = svgElement.getAttribute("style");
        if (logicalWidth === 0 || logicalHeight === 0) {
          logicalWidth = parseFloat(rawWidth) || 100;
          logicalHeight = parseFloat(rawHeight) || 20;
        }
        const isMathJax = svgElement.getAttribute("role") === "img" || svgElement.getAttribute("focusable") === "false" || svgElement.classList.contains("MathJax");
        if (isMathJax) {
          clonedSvg.setAttribute("fill", "#333333");
          clonedSvg.style.color = "#333333";
          clonedSvg.querySelectorAll("*").forEach((el) => {
            if (el.getAttribute("fill") === "currentColor" || !el.getAttribute("fill")) {
              el.setAttribute("fill", "#333333");
            }
            if (el.getAttribute("stroke") === "currentColor") {
              el.setAttribute("stroke", "#333333");
            }
          });
        }
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(clonedSvg);
        const svgBlob = new Blob([svgString], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = () => {
          try {
            const canvas = document.createElement("canvas");
            canvas.width = logicalWidth * scale;
            canvas.height = logicalHeight * scale;
            const ctx = canvas.getContext("2d");
            ctx.scale(scale, scale);
            ctx.drawImage(img, 0, 0, logicalWidth, logicalHeight);
            URL.revokeObjectURL(url);
            canvas.toBlob((blob) => {
              if (blob) {
                resolve({
                  blob,
                  width: logicalWidth,
                  // 返回逻辑宽度 (例如 20.5)
                  height: logicalHeight,
                  style: rawStyle
                });
              } else
                reject(new Error("Canvas conversion failed"));
            }, "image/png");
          } catch (e) {
            reject(e);
          }
        };
        img.onerror = (e) => {
          URL.revokeObjectURL(url);
          reject(new Error("SVG Image load failed"));
        };
        img.src = url;
      } catch (e) {
        reject(e);
      }
    });
  }
  /**
   * 清理 HTML 以适配微信编辑器
   * 微信编辑器对嵌套列表支持不佳，需要：
   * 1. 处理嵌套列表父级 li 内的段落与行内内容（避免嵌套层级被打散）
   * 2. 将深层嵌套列表转为伪列表（避免微信扁平化）
   * 3. 移除嵌套 ul/ol 的 margin（避免被当成独立块）
   * 4. 移除空的 li 元素和空白文本节点
   */
  cleanHtmlForDraft(html) {
    return cleanHtmlForDraftService(html);
  }
  // === 设置变更处理 ===
  async onThemeChange(value, grid) {
    this.plugin.settings.theme = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ theme: value });
    await this.convertCurrent(true);
  }
  async onFontFamilyChange(value) {
    this.plugin.settings.fontFamily = value;
    await this.plugin.saveSettings();
    this.theme.update({ fontFamily: value });
    await this.convertCurrent(true);
  }
  async onFontSizeChange(value, grid) {
    this.plugin.settings.fontSize = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ fontSize: value });
    await this.convertCurrent(true);
  }
  async onColorChange(value, grid) {
    this.plugin.settings.themeColor = value;
    await this.plugin.saveSettings();
    this.updateButtonActive(grid, value);
    this.theme.update({ themeColor: value });
    await this.convertCurrent(true);
  }
  async onMacCodeBlockChange(checked) {
    this.plugin.settings.macCodeBlock = checked;
    await this.plugin.saveSettings();
    this.theme.update({ macCodeBlock: checked });
    if (this.converter) {
      this.converter.reinit();
      await this.converter.initMarkdownIt();
    }
    await this.convertCurrent(true);
  }
  async onCodeLineNumberChange(checked) {
    this.plugin.settings.codeLineNumber = checked;
    await this.plugin.saveSettings();
    this.theme.update({ codeLineNumber: checked });
    if (this.converter) {
      this.converter.reinit();
      await this.converter.initMarkdownIt();
    }
    await this.convertCurrent(true);
  }
  updateButtonActive(grid, value) {
    grid.querySelectorAll("button").forEach((btn) => {
      btn.classList.toggle("active", btn.dataset.value == value);
    });
  }
  getRenderPipelineFlags() {
    var _a, _b, _c, _d, _e, _f;
    return {
      useNativePipeline: ((_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.useNativePipeline) === true,
      enableLegacyFallback: ((_d = (_c = this.plugin) == null ? void 0 : _c.settings) == null ? void 0 : _d.enableLegacyFallback) !== false,
      enforceNativeParity: ((_f = (_e = this.plugin) == null ? void 0 : _e.settings) == null ? void 0 : _f.enforceNativeParity) !== false,
      parityTransform: (html) => this.cleanHtmlForDraft(html)
    };
  }
  getActiveRenderPipeline() {
    const flags = this.getRenderPipelineFlags();
    if (flags.useNativePipeline && this.nativeRenderPipeline) {
      return this.nativeRenderPipeline;
    }
    return this.legacyRenderPipeline;
  }
  async renderMarkdownForPreview(markdown, sourcePath) {
    const pipeline = this.getActiveRenderPipeline();
    if (!pipeline) {
      throw new Error("\u6E32\u67D3\u7BA1\u7EBF\u672A\u521D\u59CB\u5316");
    }
    return pipeline.renderForPreview(markdown, { sourcePath });
  }
  /**
   * 更新当前文档显示
   */
  updateCurrentDoc() {
    const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
    if (activeView && this.docTitleText) {
      this.docTitleText.setText(activeView.file.basename);
      this.docTitleText.style.color = "var(--apple-primary)";
    } else if (this.lastActiveFile && this.docTitleText) {
      this.docTitleText.setText(this.lastActiveFile.basename);
      this.docTitleText.style.color = "var(--apple-primary)";
    } else if (this.docTitleText) {
      this.docTitleText.setText("\u672A\u9009\u62E9\u6587\u6863");
      this.docTitleText.style.color = "var(--apple-tertiary)";
    }
  }
  /**
   * 设置占位符
   */
  setPlaceholder() {
    this.previewContainer.empty();
    this.previewContainer.removeClass("apple-has-content");
    const placeholder = this.previewContainer.createEl("div", { cls: "apple-placeholder" });
    placeholder.createEl("div", { cls: "apple-placeholder-icon", text: "\u{1F4DD}" });
    placeholder.createEl("h2", { text: "\u5FAE\u4FE1\u516C\u4F17\u53F7\u6392\u7248\u8F6C\u6362\u5668" });
    placeholder.createEl("p", { text: "\u5C06 Markdown \u8F6C\u6362\u4E3A\u7CBE\u7F8E\u7684 HTML\uFF0C\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1" });
    const steps = placeholder.createEl("div", { cls: "apple-steps" });
    steps.createEl("div", { text: "1\uFE0F\u20E3 \u6253\u5F00\u9700\u8981\u8F6C\u6362\u7684 Markdown \u6587\u4EF6" });
    steps.createEl("div", { text: "2\uFE0F\u20E3 \u9884\u89C8\u533A\u4F1A\u81EA\u52A8\u663E\u793A\u8F6C\u6362\u6548\u679C" });
    steps.createEl("div", { text: "3\uFE0F\u20E3 \u70B9\u51FB\u300C\u4E00\u952E\u540C\u6B65\u5230\u8349\u7A3F\u7BB1\u300D\u5373\u53EF\u53D1\u9001" });
    const note = placeholder.createEl("p", {
      text: "\u6CE8\u610F\uFF1A\u5982\u5F53\u524D\u5DF2\u6253\u5F00\u6587\u6863\u4F46\u672A\u663E\u793A\uFF0C\u8BF7\u91CD\u65B0\u70B9\u51FB\u4E00\u4E0B\u6587\u6863\u5373\u53EF\u89E6\u53D1",
      cls: "apple-placeholder-note"
    });
  }
  /**
   * 转换当前文档
   */
  async convertCurrent(silent = false) {
    const generation = ++this.renderGeneration;
    const source = await resolveMarkdownSource({
      app: this.app,
      lastActiveFile: this.lastActiveFile,
      MarkdownViewType: MarkdownView
    });
    if (!source.ok) {
      if (!silent)
        new Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A Markdown \u6587\u4EF6");
      return;
    }
    const markdown = source.markdown;
    const sourcePath = source.sourcePath;
    if (!markdown.trim()) {
      if (!silent)
        new Notice("\u5F53\u524D\u6587\u4EF6\u5185\u5BB9\u4E3A\u7A7A");
      return;
    }
    try {
      if (!silent)
        new Notice("\u26A1 \u6B63\u5728\u8F6C\u6362...");
      const html = await this.renderMarkdownForPreview(markdown, sourcePath);
      if (generation !== this.renderGeneration)
        return;
      this.currentHtml = html;
      this.sessionCoverBase64 = null;
      const scrollTop = this.previewContainer.scrollTop;
      this.previewContainer.innerHTML = html;
      this.previewContainer.scrollTop = scrollTop;
      this.previewContainer.addClass("apple-has-content");
      this.updateCurrentDoc();
      if (!silent)
        new Notice("\u2705 \u8F6C\u6362\u6210\u529F\uFF01");
    } catch (error) {
      console.error("\u8F6C\u6362\u5931\u8D25:", error);
      if (!silent)
        new Notice("\u274C \u8F6C\u6362\u5931\u8D25: " + error.message);
    }
  }
  /**
   * 视图改变大小时触发 (包括侧边栏展开、Tab切换等导致的大小变化)
   */
  onResize() {
    super.onResize();
    if (this.resizeTimeout)
      clearTimeout(this.resizeTimeout);
    if (!this.containerEl.offsetParent)
      return;
    this.resizeTimeout = setTimeout(() => {
      this.convertCurrent(true);
    }, 300);
  }
  /**
   * 渲染 HTML
   */
  renderHTML(html) {
    this.previewContainer.empty();
    this.previewContainer.innerHTML = html;
  }
  /**
   * 复制 HTML
   */
  async copyHTML() {
    if (this.isCopying)
      return;
    if (!this.currentHtml) {
      new Notice("\u26A0\uFE0F \u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u6587\u7AE0\u8FDB\u884C\u8F6C\u6362");
      return;
    }
    this.isCopying = true;
    if (this.copyBtn) {
      this.copyBtn.classList.add("active");
    }
    try {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = this.currentHtml;
      const images = Array.from(tempDiv.querySelectorAll("img"));
      const localImages = images.filter((img) => img.src.startsWith("app://"));
      if (localImages.length > 0) {
        new Notice("\u23F3 \u6B63\u5728\u5904\u7406\u56FE\u7247...");
      }
      const processed = await this.processImagesToDataURL(tempDiv);
      const cleanedHtml = this.cleanHtmlForDraft(tempDiv.innerHTML);
      const plainDiv = document.createElement("div");
      plainDiv.innerHTML = cleanedHtml;
      const text = plainDiv.textContent || "";
      const htmlContent = cleanedHtml;
      window.__OWC_LAST_CLIPBOARD_HTML = htmlContent;
      window.__OWC_LAST_CLIPBOARD_TEXT = text;
      if (navigator.clipboard && navigator.clipboard.write) {
        try {
          const htmlOnlyItem = new ClipboardItem({
            "text/html": new Blob([htmlContent], { type: "text/html" })
          });
          await navigator.clipboard.write([htmlOnlyItem]);
        } catch (htmlOnlyError) {
          const clipboardItem = new ClipboardItem({
            "text/html": new Blob([htmlContent], { type: "text/html" }),
            "text/plain": new Blob([text], { type: "text/plain" })
          });
          await navigator.clipboard.write([clipboardItem]);
        }
        new Notice("\u2705 \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\uFF01");
        if (this.copyBtn) {
          const { setIcon } = require("obsidian");
          setIcon(this.copyBtn, "check");
          setTimeout(() => {
            if (this.copyBtn) {
              setIcon(this.copyBtn, "copy");
              this.copyBtn.classList.remove("active");
            }
          }, 2e3);
        }
        return;
      }
      throw new Error("Clipboard API unavailable");
    } catch (error) {
      console.error("\u590D\u5236\u5931\u8D25:", error);
      new Notice(`\u274C \u590D\u5236\u5931\u8D25: ${error.message}`);
      if (this.copyBtn) {
        this.copyBtn.classList.remove("active");
      }
    } finally {
      this.isCopying = false;
    }
  }
  /**
   * 将 HTML 中的本地图片转换为 Base64 (Canvas Compressed)
   */
  async processImagesToDataURL(container) {
    const images = Array.from(container.querySelectorAll("img"));
    const localImages = images.filter((img) => img.src.startsWith("app://") || img.src.startsWith("capacitor://"));
    if (localImages.length === 0)
      return false;
    const startTime = Date.now();
    const concurrency = 3;
    for (let i = 0; i < localImages.length; i += concurrency) {
      const chunk = localImages.slice(i, i + concurrency);
      await Promise.all(chunk.map((img) => this.convertImageToLocally(img)));
    }
    const elapsed = Date.now() - startTime;
    const minDuration = 800;
    if (elapsed < minDuration) {
      await new Promise((resolve) => setTimeout(resolve, minDuration - elapsed));
    }
    return true;
  }
  async convertImageToLocally(img) {
    try {
      const response = await fetch(img.src);
      const blob = await response.blob();
      if (blob.size > 10 * 1024 * 1024) {
        new Notice(`\u26A0\uFE0F \u53D1\u73B0\u5927\u56FE (${(blob.size / 1024 / 1024).toFixed(1)}MB)\uFF0C\u5904\u7406\u53EF\u80FD\u8F83\u6162`, 5e3);
      }
      let dataUrl;
      if (blob.type === "image/gif") {
        dataUrl = await this.blobToDataUrl(blob);
      } else {
        dataUrl = await this.blobToJpegDataUrl(blob);
      }
      img.src = dataUrl;
      delete img.dataset.src;
    } catch (error) {
      console.error("Image processing failed:", error);
    }
  }
  // Helper: Direct Blob to Base64 (for GIFs)
  blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
  blobToJpegDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const url = URL.createObjectURL(blob);
      const image = new Image();
      image.onload = () => {
        const canvas = document.createElement("canvas");
        let width = image.width;
        let height = image.height;
        if (width > 1920) {
          height = Math.round(height * (1920 / width));
          width = 1920;
        }
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, width, height);
        const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
        URL.revokeObjectURL(url);
        resolve(dataUrl);
      };
      image.onerror = () => {
        URL.revokeObjectURL(url);
        reject(new Error("Image load failed"));
      };
      image.src = url;
    });
  }
  async onClose() {
    var _a;
    if (this.activeEditorScroller && this.editorScrollListener) {
      this.activeEditorScroller.removeEventListener("scroll", this.editorScrollListener);
    }
    if (this.previewContainer && this.previewScrollListener) {
      this.previewContainer.removeEventListener("scroll", this.previewScrollListener);
    }
    (_a = this.previewContainer) == null ? void 0 : _a.empty();
    if (this.articleStates) {
      this.articleStates.clear();
    }
    console.log("\u{1F34E} \u8F6C\u6362\u5668\u9762\u677F\u5DF2\u5173\u95ED");
  }
  /**
   * 简单的字符串哈希函数 (DJB2算法)
   */
  simpleHash(str) {
    let hash = 5381;
    for (let i = 0; i < str.length; i++) {
      hash = hash * 33 ^ str.charCodeAt(i);
    }
    return hash >>> 0;
  }
};
var AppleStyleSettingTab = class extends PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  normalizeVaultPath(vaultPath) {
    return normalizeVaultPath(vaultPath);
  }
  isAbsolutePathLike(vaultPath) {
    return isAbsolutePathLike(vaultPath);
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new Setting(containerEl).setDesc("\u66F4\u591A\u6392\u7248\u6837\u5F0F\u9009\u9879\uFF08\u4E3B\u9898\u3001\u5B57\u53F7\u3001\u4EE3\u7801\u5757\u7B49\uFF09\u8BF7\u5728\u63D2\u4EF6\u4FA7\u8FB9\u680F\u9762\u677F\u4E2D\u8FDB\u884C\u8BBE\u7F6E\u3002");
    new Setting(containerEl).setName("\u9884\u89C8\u6A21\u5F0F").setHeading();
    new Setting(containerEl).setName("\u4F7F\u7528\u624B\u673A\u4EFF\u771F\u6846").setDesc("\u5F00\u542F\u540E\uFF0C\u9884\u89C8\u533A\u57DF\u5C06\u663E\u793A\u4E3A iPhone X \u624B\u673A\u6846\u6837\u5F0F\uFF1B\u5173\u95ED\u5219\u6062\u590D\u4E3A\u7ECF\u5178\u5168\u5BBD\u9884\u89C8\u6A21\u5F0F\uFF08\u9700\u91CD\u542F\u63D2\u4EF6\u9762\u677F\u751F\u6548\uFF09").addToggle((toggle) => toggle.setValue(this.plugin.settings.usePhoneFrame).onChange(async (value) => {
      this.plugin.settings.usePhoneFrame = value;
      await this.plugin.saveSettings();
      new Notice("\u8BBE\u7F6E\u5DF2\u4FDD\u5B58\uFF0C\u8BF7\u5173\u95ED\u5E76\u91CD\u65B0\u6253\u5F00\u8F6C\u6362\u5668\u9762\u677F\u4EE5\u751F\u6548");
    }));
    new Setting(containerEl).setName("\u56FE\u7247\u6C34\u5370").setHeading();
    new Setting(containerEl).setName("\u542F\u7528\u56FE\u7247\u6C34\u5370").setDesc("\u5728\u6BCF\u5F20\u56FE\u7247\u4E0A\u65B9\u663E\u793A\u5934\u50CF").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableWatermark).onChange(async (value) => {
      this.plugin.settings.enableWatermark = value;
      await this.plugin.saveSettings();
    }));
    const uploadSetting = new Setting(containerEl).setName("\u4E0A\u4F20\u672C\u5730\u5934\u50CF").setDesc(this.plugin.settings.avatarBase64 ? "\u2705 \u5DF2\u4E0A\u4F20\u672C\u5730\u5934\u50CF\uFF08\u4F18\u5148\u4F7F\u7528\uFF09" : "\u9009\u62E9\u672C\u5730\u56FE\u7247\uFF0C\u8F6C\u6362\u4E3A Base64 \u5B58\u50A8\uFF0C\u65E0\u9700\u7F51\u7EDC\u8BF7\u6C42");
    uploadSetting.addButton((button) => button.setButtonText(this.plugin.settings.avatarBase64 ? "\u91CD\u65B0\u4E0A\u4F20" : "\u9009\u62E9\u56FE\u7247").onClick(() => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = "image/*";
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file)
          return;
        if (file.size > 100 * 1024) {
          new Notice("\u274C \u56FE\u7247\u592A\u5927\uFF0C\u8BF7\u9009\u62E9\u5C0F\u4E8E 100KB \u7684\u56FE\u7247");
          return;
        }
        const reader = new FileReader();
        reader.onload = async (event) => {
          this.plugin.settings.avatarBase64 = event.target.result;
          await this.plugin.saveSettings();
          new Notice("\u2705 \u5934\u50CF\u5DF2\u4E0A\u4F20");
          this.display();
        };
        reader.readAsDataURL(file);
      };
      input.click();
    }));
    if (this.plugin.settings.avatarBase64) {
      uploadSetting.addButton((button) => button.setButtonText("\u6E05\u9664").setWarning().onClick(async () => {
        this.plugin.settings.avatarBase64 = "";
        await this.plugin.saveSettings();
        new Notice("\u5DF2\u6E05\u9664\u672C\u5730\u5934\u50CF");
        this.display();
      }));
    }
    new Setting(containerEl).setName("\u5934\u50CF URL\uFF08\u5907\u7528\uFF09").setDesc("\u5982\u672A\u4E0A\u4F20\u672C\u5730\u5934\u50CF\uFF0C\u5C06\u4F7F\u7528\u6B64 URL").addText((text) => text.setPlaceholder("https://example.com/avatar.jpg").setValue(this.plugin.settings.avatarUrl).onChange(async (value) => {
      this.plugin.settings.avatarUrl = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u5FAE\u4FE1\u516C\u4F17\u53F7\u8D26\u53F7").setDesc("\u8BF7\u5728\u5FAE\u4FE1\u516C\u4F17\u53F7\u540E\u53F0 [\u8BBE\u7F6E\u4E0E\u5F00\u53D1] -> [\u57FA\u672C\u914D\u7F6E] \u4E2D\u83B7\u53D6 AppID \u548C AppSecret\uFF0C\u5E76\u786E\u4FDD\u5DF2\u5C06\u5F53\u524D IP \u52A0\u5165\u767D\u540D\u5355\u3002").setHeading();
    const accounts = this.plugin.settings.wechatAccounts || [];
    const defaultId = this.plugin.settings.defaultAccountId;
    if (accounts.length === 0) {
      containerEl.createEl("p", {
        text: "\u6682\u65E0\u8D26\u53F7\uFF0C\u8BF7\u70B9\u51FB\u4E0B\u65B9\u6309\u94AE\u6DFB\u52A0",
        cls: "setting-item-description",
        attr: { style: "color: var(--text-muted); font-style: italic;" }
      });
    } else {
      const listContainer = containerEl.createDiv({ cls: "wechat-account-list" });
      for (const account of accounts) {
        const isDefault = account.id === defaultId;
        const card = listContainer.createDiv({ cls: "wechat-account-card" });
        const info = card.createDiv({ cls: "wechat-account-info" });
        const nameRow = info.createDiv({ cls: "wechat-account-name-row" });
        nameRow.createSpan({ text: account.name, cls: "wechat-account-name" });
        if (isDefault) {
          nameRow.createSpan({ text: "\u9ED8\u8BA4", cls: "wechat-account-badge" });
        }
        info.createDiv({
          text: `AppID: ${account.appId.substring(0, 8)}...`,
          cls: "wechat-account-appid"
        });
        const actions = card.createDiv({ cls: "wechat-account-actions" });
        if (!isDefault) {
          const defaultBtn = actions.createEl("button", { text: "\u8BBE\u4E3A\u9ED8\u8BA4", cls: "wechat-btn-small" });
          defaultBtn.onclick = async () => {
            this.plugin.settings.defaultAccountId = account.id;
            await this.plugin.saveSettings();
            this.display();
          };
        }
        const editBtn = actions.createEl("button", { text: "\u7F16\u8F91", cls: "wechat-btn-small" });
        editBtn.onclick = () => this.showEditAccountModal(account);
        const testBtn = actions.createEl("button", { text: "\u6D4B\u8BD5", cls: "wechat-btn-small wechat-btn-test" });
        testBtn.onclick = async () => {
          testBtn.disabled = true;
          testBtn.textContent = "\u6D4B\u8BD5\u4E2D...";
          try {
            const api = new WechatAPI(account.appId, account.appSecret, this.plugin.settings.proxyUrl);
            await api.getAccessToken();
            new Notice(`\u2705 ${account.name} \u8FDE\u63A5\u6210\u529F\uFF01`);
          } catch (err) {
            new Notice(`\u274C ${account.name} \u8FDE\u63A5\u5931\u8D25: ${err.message}`);
          }
          testBtn.disabled = false;
          testBtn.textContent = "\u6D4B\u8BD5";
        };
        const deleteBtn = actions.createEl("button", { text: "\u5220\u9664", cls: "wechat-btn-small wechat-btn-danger" });
        deleteBtn.onclick = async () => {
          if (confirm(`\u786E\u5B9A\u8981\u5220\u9664\u8D26\u53F7 "${account.name}" \u5417\uFF1F`)) {
            this.plugin.settings.wechatAccounts = accounts.filter((a) => a.id !== account.id);
            if (account.id === defaultId && this.plugin.settings.wechatAccounts.length > 0) {
              this.plugin.settings.defaultAccountId = this.plugin.settings.wechatAccounts[0].id;
            } else if (this.plugin.settings.wechatAccounts.length === 0) {
              this.plugin.settings.defaultAccountId = "";
            }
            await this.plugin.saveSettings();
            this.display();
          }
        };
      }
    }
    const addBtnContainer = containerEl.createDiv({ cls: "wechat-add-account-container" });
    if (accounts.length < MAX_ACCOUNTS) {
      const addBtn = addBtnContainer.createEl("button", {
        text: "+ \u6DFB\u52A0\u8D26\u53F7",
        cls: "wechat-btn-add"
      });
      addBtn.onclick = () => this.showEditAccountModal(null);
    } else {
      addBtnContainer.createEl("p", {
        text: `\u5DF2\u8FBE\u5230\u6700\u5927\u8D26\u53F7\u6570\u91CF (${MAX_ACCOUNTS})`,
        cls: "setting-item-description",
        attr: { style: "color: var(--text-muted);" }
      });
    }
    new Setting(containerEl).setName("\u9AD8\u7EA7\u8BBE\u7F6E").setHeading();
    new Setting(containerEl).setName("\u4F7F\u7528\u5B9E\u9A8C\u6E32\u67D3\u7BA1\u7EBF\uFF08Phase 1\uFF09").setDesc("\u5F53\u524D\u9636\u6BB5\u4ECD\u590D\u7528 Legacy Converter\uFF0C\u5E76\u589E\u52A0\u5B89\u5168\u9884\u5904\u7406/\u540E\u5904\u7406\uFF1B\u5E76\u975E\u5B8C\u6574 Obsidian \u539F\u751F\u4E09\u4EF6\u5957\u5B9E\u73B0\u3002\u5F00\u542F\u540E\u53EF\u80FD\u4E0E Legacy \u6709\u5C11\u91CF\u8F93\u51FA\u5DEE\u5F02\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.useNativePipeline === true).onChange(async (value) => {
      this.plugin.settings.useNativePipeline = value;
      await this.plugin.saveSettings();
      new Notice(value ? "\u5DF2\u542F\u7528\u5B9E\u9A8C\u6E32\u67D3\u7BA1\u7EBF\uFF08Phase 1\uFF0C\u53EF\u80FD\u6709\u5C11\u91CF\u8F93\u51FA\u5DEE\u5F02\uFF09" : "\u5DF2\u5207\u56DE Legacy \u6E32\u67D3\u5165\u53E3");
      const converterView = this.plugin.getConverterView();
      if (converterView) {
        await converterView.convertCurrent(true);
      }
    }));
    new Setting(containerEl).setName("\u539F\u751F\u5931\u8D25\u65F6\u56DE\u9000 Legacy").setDesc("\u5EFA\u8BAE\u4FDD\u6301\u5F00\u542F\u3002\u539F\u751F\u7BA1\u7EBF\u5931\u8D25\u65F6\u81EA\u52A8\u4F7F\u7528\u73B0\u6709\u7A33\u5B9A\u6E32\u67D3\u94FE\u8DEF\uFF0C\u907F\u514D\u5F71\u54CD\u65E5\u5E38\u4F7F\u7528\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableLegacyFallback !== false).onChange(async (value) => {
      this.plugin.settings.enableLegacyFallback = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u96F6\u5DEE\u5F02\u95E8\u7981\uFF08Phase 2\uFF09").setDesc("\u5F00\u542F\u540E\u4F1A\u5C06\u5B9E\u9A8C\u6E32\u67D3\u8F93\u51FA\u4E0E Legacy \u8F93\u51FA\u8FDB\u884C\u5B57\u8282\u7EA7\u5BF9\u6BD4\uFF1B\u82E5\u4E0D\u4E00\u81F4\u5219\u81EA\u52A8\u56DE\u9000 Legacy\u3002\u5EFA\u8BAE\u4FDD\u6301\u5F00\u542F\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.enforceNativeParity !== false).onChange(async (value) => {
      this.plugin.settings.enforceNativeParity = value;
      await this.plugin.saveSettings();
      const converterView = this.plugin.getConverterView();
      if (converterView) {
        await converterView.convertCurrent(true);
      }
    }));
    new Setting(containerEl).setName("\u53D1\u9001\u6210\u529F\u540E\u81EA\u52A8\u6E05\u7406\u8D44\u6E90").setDesc("\u9ED8\u8BA4\u5173\u95ED\u3002\u5F00\u542F\u540E\u4F1A\u5728\u521B\u5EFA\u8349\u7A3F\u6210\u529F\u540E\uFF0C\u5220\u9664\u4F60\u5728\u4E0B\u65B9\u914D\u7F6E\u7684\u76EE\u5F55\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.cleanupAfterSync).onChange(async (value) => {
      this.plugin.settings.cleanupAfterSync = value;
      await this.plugin.saveSettings();
    }));
    let hasWarnedAbsoluteCleanupPath = false;
    new Setting(containerEl).setName("\u6E05\u7406\u76EE\u5F55").setDesc("\u586B\u5199 vault \u5185\u76F8\u5BF9\u8DEF\u5F84\uFF08\u4E0D\u8981\u586B /Users/... \u8FD9\u7C7B\u7EDD\u5BF9\u8DEF\u5F84\uFF09\uFF0C\u652F\u6301 {{note}} \u5360\u4F4D\u7B26\uFF0C\u4F8B\u5982 published/{{note}}_img\u3002").addText((text) => text.setPlaceholder("published/{{note}}_img").setValue(this.plugin.settings.cleanupDirTemplate || "").onChange(async (value) => {
      if (this.isAbsolutePathLike(value)) {
        if (!hasWarnedAbsoluteCleanupPath) {
          new Notice("\u26A0\uFE0F \u6E05\u7406\u76EE\u5F55\u8BF7\u586B\u5199 vault \u5185\u76F8\u5BF9\u8DEF\u5F84\uFF0C\u4E0D\u8981\u4F7F\u7528\u7EDD\u5BF9\u8DEF\u5F84\uFF08\u5982 /Users/... \u6216 C:\\...\uFF09");
          hasWarnedAbsoluteCleanupPath = true;
        }
      } else {
        hasWarnedAbsoluteCleanupPath = false;
      }
      const normalized = this.normalizeVaultPath(value);
      if (normalized.includes("..")) {
        new Notice("\u274C \u6E05\u7406\u76EE\u5F55\u4E0D\u80FD\u5305\u542B ..");
        return;
      }
      this.plugin.settings.cleanupDirTemplate = normalized;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("\u4F7F\u7528\u7CFB\u7EDF\u56DE\u6536\u7AD9").setDesc("\u5F00\u542F\u65F6\u4F18\u5148\u79FB\u52A8\u5230\u7CFB\u7EDF\u56DE\u6536\u7AD9\uFF1B\u5173\u95ED\u65F6\u76F4\u63A5\u4ECE vault \u5220\u9664\u3002").addToggle((toggle) => toggle.setValue(this.plugin.settings.cleanupUseSystemTrash !== false).onChange(async (value) => {
      this.plugin.settings.cleanupUseSystemTrash = value;
      await this.plugin.saveSettings();
    }));
    new Setting(containerEl).setName("API \u4EE3\u7406\u5730\u5740").setDesc(createFragment((frag) => {
      const descDiv = frag.createDiv();
      descDiv.appendText("\u5982\u679C\u4F60\u7684\u7F51\u7EDC IP \u7ECF\u5E38\u53D8\u5316\uFF0C\u53EF\u914D\u7F6E\u4EE3\u7406\u670D\u52A1\u3002");
      descDiv.createEl("a", {
        text: "\u67E5\u770B\u90E8\u7F72\u6307\u5357",
        href: "https://xiaoweibox.top/chats/wechat-proxy",
        style: "margin-left: 5px;"
      });
      frag.createDiv({
        cls: "wechat-proxy-note",
        style: "margin-top: 6px; font-size: 12px; color: var(--text-muted); background: var(--background-secondary); padding: 8px; border-radius: 4px;"
      }, (el) => {
        el.createSpan({ text: "\u{1F512} \u5B89\u5168\u63D0\u793A\uFF1A\u4EE3\u7406\u670D\u52A1\u5C06\u4E2D\u8F6C\u60A8\u7684\u8BF7\u6C42\u3002\u8BF7\u786E\u4FDD\u4F7F\u7528\u53D7\u4FE1\u4EFB\u7684\u4EE3\u7406\uFF08\u81EA\u5EFA\u6216\u53EF\u9760\u7B2C\u4E09\u65B9\uFF09\uFF0C\u4EE5\u4FDD\u62A4 AppSecret \u5B89\u5168\u3002" });
      });
    })).addText((text) => text.setPlaceholder("https://your-proxy.workers.dev").setValue(this.plugin.settings.proxyUrl).onChange(async (value) => {
      const trimmedValue = value.trim();
      if (trimmedValue && !trimmedValue.startsWith("https://")) {
        new Notice("\u26A0\uFE0F \u5B89\u5168\u98CE\u9669\uFF1A\u4EE3\u7406\u5730\u5740\u5FC5\u987B\u4F7F\u7528 HTTPS \u4EE5\u4FDD\u62A4\u60A8\u7684 AppSecret\u3002");
      }
      this.plugin.settings.proxyUrl = trimmedValue;
      await this.plugin.saveSettings();
    }));
  }
  /**
   * 显示添加/编辑账号的模态框
   */
  showEditAccountModal(account) {
    const { Modal } = require("obsidian");
    const modal = new Modal(this.app);
    modal.titleEl.setText(account ? "\u7F16\u8F91\u8D26\u53F7" : "\u6DFB\u52A0\u8D26\u53F7");
    const form = modal.contentEl.createDiv();
    const nameGroup = form.createDiv({ cls: "wechat-form-group" });
    nameGroup.createEl("label", { text: "\u8D26\u53F7\u540D\u79F0" });
    const nameInput = nameGroup.createEl("input", {
      type: "text",
      placeholder: "\u4F8B\u5982\uFF1A\u6211\u7684\u516C\u4F17\u53F7",
      value: (account == null ? void 0 : account.name) || ""
    });
    const appIdGroup = form.createDiv({ cls: "wechat-form-group" });
    appIdGroup.createEl("label", { text: "AppID" });
    const appIdInput = appIdGroup.createEl("input", {
      type: "text",
      placeholder: "wx...",
      value: (account == null ? void 0 : account.appId) || ""
    });
    const secretGroup = form.createDiv({ cls: "wechat-form-group" });
    secretGroup.createEl("label", { text: "AppSecret" });
    const secretInput = secretGroup.createEl("input", {
      type: "password",
      placeholder: "\u5F00\u53D1\u8005\u5BC6\u94A5",
      value: (account == null ? void 0 : account.appSecret) || ""
    });
    const authorGroup = form.createDiv({ cls: "wechat-form-group" });
    authorGroup.createEl("label", { text: "\u9ED8\u8BA4\u4F5C\u8005\uFF08\u53EF\u9009\uFF09" });
    const authorInput = authorGroup.createEl("input", {
      type: "text",
      placeholder: "\u7559\u7A7A\u5219\u4E0D\u663E\u793A\u4F5C\u8005",
      value: (account == null ? void 0 : account.author) || ""
    });
    const btnRow = form.createDiv({ cls: "wechat-modal-buttons" });
    const cancelBtn = btnRow.createEl("button", { text: "\u53D6\u6D88" });
    cancelBtn.onclick = () => modal.close();
    const testBtn = btnRow.createEl("button", { text: "\u6D4B\u8BD5\u8FDE\u63A5", cls: "wechat-btn-test" });
    testBtn.onclick = async () => {
      if (!appIdInput.value || !secretInput.value) {
        new Notice("\u8BF7\u586B\u5199 AppID \u548C AppSecret");
        return;
      }
      testBtn.disabled = true;
      testBtn.textContent = "\u6D4B\u8BD5\u4E2D...";
      try {
        const api = new WechatAPI(appIdInput.value.trim(), secretInput.value.trim(), this.plugin.settings.proxyUrl);
        await api.getAccessToken();
        new Notice("\u2705 \u8FDE\u63A5\u6210\u529F\uFF01");
      } catch (err) {
        new Notice(`\u274C \u8FDE\u63A5\u5931\u8D25: ${err.message}`);
      }
      testBtn.disabled = false;
      testBtn.textContent = "\u6D4B\u8BD5\u8FDE\u63A5";
    };
    const saveBtn = btnRow.createEl("button", { text: "\u4FDD\u5B58", cls: "mod-cta" });
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim() || "\u672A\u547D\u540D\u8D26\u53F7";
      const appId = appIdInput.value.trim();
      const appSecret = secretInput.value.trim();
      if (!appId || !appSecret) {
        new Notice("\u8BF7\u586B\u5199 AppID \u548C AppSecret");
        return;
      }
      if (account) {
        account.name = name;
        account.appId = appId;
        account.appSecret = appSecret;
        account.author = authorInput.value.trim();
      } else {
        const newAccount = {
          id: generateId(),
          name,
          appId,
          appSecret,
          author: authorInput.value.trim()
        };
        this.plugin.settings.wechatAccounts.push(newAccount);
        if (this.plugin.settings.wechatAccounts.length === 1) {
          this.plugin.settings.defaultAccountId = newAccount.id;
        }
      }
      await this.plugin.saveSettings();
      modal.close();
      this.display();
      new Notice(account ? "\u2705 \u8D26\u53F7\u5DF2\u66F4\u65B0" : "\u2705 \u8D26\u53F7\u5DF2\u6DFB\u52A0");
    };
    modal.open();
  }
};
var AppleStylePlugin = class extends Plugin {
  async onload() {
    console.log("\u{1F4DD} \u6B63\u5728\u52A0\u8F7D\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668...");
    await this.loadSettings();
    this.registerView(
      APPLE_STYLE_VIEW,
      (leaf) => new AppleStyleView(leaf, this)
    );
    this.addRibbonIcon("wand", "\u{1F4DD} \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668", async () => {
      await this.openConverter();
    });
    this.addCommand({
      id: "open-apple-converter",
      name: "\u6253\u5F00\u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668",
      callback: async () => {
        await this.openConverter();
      }
    });
    this.addSettingTab(new AppleStyleSettingTab(this.app, this));
    console.log("\u2705 \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668\u52A0\u8F7D\u5B8C\u6210");
  }
  async openConverter() {
    let leaf = this.app.workspace.getLeavesOfType(APPLE_STYLE_VIEW)[0];
    if (!leaf) {
      const rightLeaf = this.app.workspace.getRightLeaf(false);
      await rightLeaf.setViewState({
        type: APPLE_STYLE_VIEW,
        active: true
      });
      leaf = rightLeaf;
    }
    this.app.workspace.revealLeaf(leaf);
  }
  getConverterView() {
    const leaves = this.app.workspace.getLeavesOfType(APPLE_STYLE_VIEW);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    let didMigrate = false;
    if (this.settings.wechatAppId && this.settings.wechatAccounts.length === 0) {
      const migratedAccount = {
        id: generateId(),
        name: "\u6211\u7684\u516C\u4F17\u53F7",
        appId: this.settings.wechatAppId,
        appSecret: this.settings.wechatAppSecret
      };
      this.settings.wechatAccounts.push(migratedAccount);
      this.settings.defaultAccountId = migratedAccount.id;
      this.settings.wechatAppId = "";
      this.settings.wechatAppSecret = "";
      didMigrate = true;
      console.log("\u2705 \u5DF2\u5C06\u65E7\u8D26\u53F7\u914D\u7F6E\u8FC1\u79FB\u5230\u65B0\u683C\u5F0F");
    }
    const currentTemplate = normalizeVaultPath(this.settings.cleanupDirTemplate || "");
    const legacyRootDir = normalizeVaultPath(this.settings.cleanupRootDir || "");
    const legacyTarget = this.settings.cleanupTarget;
    if (!currentTemplate && legacyRootDir && legacyTarget === "folder") {
      this.settings.cleanupDirTemplate = `${legacyRootDir}/{{note}}_img`;
      didMigrate = true;
      console.log("\u2705 \u5DF2\u5C06\u65E7\u6E05\u7406\u914D\u7F6E\u8FC1\u79FB\u4E3A\u76EE\u5F55\u6A21\u677F cleanupDirTemplate");
    }
    if (Object.prototype.hasOwnProperty.call(this.settings, "cleanupRootDir")) {
      delete this.settings.cleanupRootDir;
      didMigrate = true;
    }
    if (Object.prototype.hasOwnProperty.call(this.settings, "cleanupTarget")) {
      delete this.settings.cleanupTarget;
      didMigrate = true;
    }
    if (didMigrate) {
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    console.log("\u{1F4DD} \u5FAE\u4FE1\u516C\u4F17\u53F7\u8F6C\u6362\u5668\u5DF2\u5378\u8F7D");
  }
};
module.exports = AppleStylePlugin;
module.exports.AppleStyleView = AppleStyleView;
module.exports.WechatAPI = WechatAPI;
module.exports.AppleStyleSettingTab = AppleStyleSettingTab;
