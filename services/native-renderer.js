function isSafeRawImageSrc(src) {
  if (!src || typeof src !== 'string') return false;
  const trimmed = src.trim();
  if (!trimmed || trimmed.startsWith('#')) return false;

  const safeProtocols = ['http:', 'https:', 'data:', 'app:', 'capacitor:', 'obsidian:'];

  try {
    const parsed = new URL(trimmed);
    return safeProtocols.includes(parsed.protocol);
  } catch (error) {
    // Raw HTML <img src="relative/path"> bypasses converter path resolution and
    // frequently becomes broken icons in WeChat preview, so native path removes it.
    return false;
  }
}

function preprocessMarkdownForNative(markdown) {
  if (typeof markdown !== 'string' || markdown.length === 0) return '';

  let output = markdown;

  // Remove dangerous raw HTML blocks before markdown-it parsing so they do not
  // poison following markdown lines as raw HTML context.
  output = output.replace(/<(script|iframe|object|embed|form|input|button|style)\b[^>]*>[\s\S]*?<\/\1>/gi, '\n');
  output = output.replace(/<(script|iframe|object|embed|form|input|button|style)\b[^>]*\/?>/gi, '\n');

  // Handle raw <img> tags separately to avoid broken placeholder images.
  output = output.replace(/<img\b[^>]*>/gi, (tag) => {
    const hasEventHandler = /\son\w+\s*=/.test(tag);
    const srcMatch = tag.match(/\bsrc\s*=\s*(?:"([^"]*)"|'([^']*)'|([^\s>]+))/i);
    const src = srcMatch ? (srcMatch[1] || srcMatch[2] || srcMatch[3] || '') : '';

    if (hasEventHandler || !isSafeRawImageSrc(src)) {
      return '\n';
    }

    return tag;
  });

  return output;
}

function cleanupNativeRenderedHtml(html) {
  if (typeof document === 'undefined' || typeof html !== 'string' || html.length === 0) {
    return html;
  }

  const container = document.createElement('div');
  container.innerHTML = html;

  // Remove orphan raw <img> tags that are not generated by the markdown image renderer.
  Array.from(container.querySelectorAll('img')).forEach((img) => {
    const inFigure = !!img.closest('figure');
    const isMathImage = img.classList.contains('math-formula-image');
    if (!inFigure && !isMathImage) {
      img.remove();
    }
  });

  return container.innerHTML;
}

async function renderNativeMarkdown({
  converter,
  markdown,
  sourcePath = '',
  strictLegacyParity = false,
}) {
  if (!converter || typeof converter.convert !== 'function') {
    throw new Error('Native converter is not ready');
  }

  if (typeof converter.updateSourcePath === 'function') {
    converter.updateSourcePath(sourcePath);
  }

  // Phase 2 strict mode: preserve byte-level compatibility with legacy converter output.
  if (strictLegacyParity) {
    return converter.convert(markdown);
  }

  const preprocessed = preprocessMarkdownForNative(markdown);
  const html = await converter.convert(preprocessed);
  return cleanupNativeRenderedHtml(html);
}

module.exports = {
  isSafeRawImageSrc,
  preprocessMarkdownForNative,
  cleanupNativeRenderedHtml,
  renderNativeMarkdown,
};
